// Generated by Haxe 4.1.0-rc.1+1c31a5912
(function ($hx_exports, $global) { "use strict";
$hx_exports["hxGeomAlgo"] = $hx_exports["hxGeomAlgo"] || {};
$hx_exports["hxGeomAlgo"]["_HxPoint"] = $hx_exports["hxGeomAlgo"]["_HxPoint"] || {};
$hx_exports["hxPixels"] = $hx_exports["hxPixels"] || {};
var $hxClasses = {},$estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
$hxClasses["EReg"] = EReg;
EReg.__name__ = "EReg";
EReg.escape = function(s) {
	return s.replace(EReg.escapeRe,"\\$&");
};
EReg.prototype = {
	r: null
	,match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,matched: function(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw haxe_Exception.thrown("EReg::matched");
		}
	}
	,matchedLeft: function() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		return HxOverrides.substr(this.r.s,0,this.r.m.index);
	}
	,matchedRight: function() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		var sz = this.r.m.index + this.r.m[0].length;
		return HxOverrides.substr(this.r.s,sz,this.r.s.length - sz);
	}
	,matchedPos: function() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		return { pos : this.r.m.index, len : this.r.m[0].length};
	}
	,matchSub: function(s,pos,len) {
		if(len == null) {
			len = -1;
		}
		if(this.r.global) {
			this.r.lastIndex = pos;
			this.r.m = this.r.exec(len < 0 ? s : HxOverrides.substr(s,0,pos + len));
			var b = this.r.m != null;
			if(b) {
				this.r.s = s;
			}
			return b;
		} else {
			var b = this.match(len < 0 ? HxOverrides.substr(s,pos,null) : HxOverrides.substr(s,pos,len));
			if(b) {
				this.r.s = s;
				this.r.m.index += pos;
			}
			return b;
		}
	}
	,split: function(s) {
		var d = "#__delim__#";
		return s.replace(this.r,d).split(d);
	}
	,replace: function(s,by) {
		return s.replace(this.r,by);
	}
	,map: function(s,f) {
		var offset = 0;
		var buf_b = "";
		while(true) {
			if(offset >= s.length) {
				break;
			} else if(!this.matchSub(s,offset)) {
				buf_b += Std.string(HxOverrides.substr(s,offset,null));
				break;
			}
			var p = this.matchedPos();
			buf_b += Std.string(HxOverrides.substr(s,offset,p.pos - offset));
			buf_b += Std.string(f(this));
			if(p.len == 0) {
				buf_b += Std.string(HxOverrides.substr(s,p.pos,1));
				offset = p.pos + 1;
			} else {
				offset = p.pos + p.len;
			}
			if(!this.r.global) {
				break;
			}
		}
		if(!this.r.global && offset > 0 && offset < s.length) {
			buf_b += Std.string(HxOverrides.substr(s,offset,null));
		}
		return buf_b;
	}
	,__class__: EReg
};
var EnumValue = {};
EnumValue.match = function(this1,pattern) {
	return false;
};
var HxOverrides = function() { };
$hxClasses["HxOverrides"] = HxOverrides;
HxOverrides.__name__ = "HxOverrides";
HxOverrides.dateStr = function(date) {
	var m = date.getMonth() + 1;
	var d = date.getDate();
	var h = date.getHours();
	var mi = date.getMinutes();
	var s = date.getSeconds();
	return date.getFullYear() + "-" + (m < 10 ? "0" + m : "" + m) + "-" + (d < 10 ? "0" + d : "" + d) + " " + (h < 10 ? "0" + h : "" + h) + ":" + (mi < 10 ? "0" + mi : "" + mi) + ":" + (s < 10 ? "0" + s : "" + s);
};
HxOverrides.strDate = function(s) {
	switch(s.length) {
	case 8:
		var k = s.split(":");
		var d = new Date();
		d["setTime"](0);
		d["setUTCHours"](k[0]);
		d["setUTCMinutes"](k[1]);
		d["setUTCSeconds"](k[2]);
		return d;
	case 10:
		var k = s.split("-");
		return new Date(k[0],k[1] - 1,k[2],0,0,0);
	case 19:
		var k = s.split(" ");
		var y = k[0].split("-");
		var t = k[1].split(":");
		return new Date(y[0],y[1] - 1,y[2],t[0],t[1],t[2]);
	default:
		throw haxe_Exception.thrown("Invalid date format : " + s);
	}
};
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.indexOf = function(a,obj,i) {
	var len = a.length;
	if(i < 0) {
		i += len;
		if(i < 0) {
			i = 0;
		}
	}
	while(i < len) {
		if(((a[i]) === obj)) {
			return i;
		}
		++i;
	}
	return -1;
};
HxOverrides.lastIndexOf = function(a,obj,i) {
	var len = a.length;
	if(i >= len) {
		i = len - 1;
	} else if(i < 0) {
		i += len;
	}
	while(i >= 0) {
		if(((a[i]) === obj)) {
			return i;
		}
		--i;
	}
	return -1;
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
HxOverrides.keyValueIter = function(a) {
	return new haxe_iterators_ArrayKeyValueIterator(a);
};
HxOverrides.now = function() {
	return Date.now();
};
var IntIterator = function(min,max) {
	this.min = min;
	this.max = max;
};
$hxClasses["IntIterator"] = IntIterator;
IntIterator.__name__ = "IntIterator";
IntIterator.prototype = {
	min: null
	,max: null
	,hasNext: function() {
		return this.min < this.max;
	}
	,next: function() {
		return this.min++;
	}
	,__class__: IntIterator
};
Math.__name__ = "Math";
var Reflect = function() { };
$hxClasses["Reflect"] = Reflect;
Reflect.__name__ = "Reflect";
Reflect.hasField = function(o,field) {
	return Object.prototype.hasOwnProperty.call(o,field);
};
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		return null;
	}
};
Reflect.setField = function(o,field,value) {
	o[field] = value;
};
Reflect.getProperty = function(o,field) {
	var tmp;
	if(o == null) {
		return null;
	} else {
		var tmp1;
		if(o.__properties__) {
			tmp = o.__properties__["get_" + field];
			tmp1 = tmp;
		} else {
			tmp1 = false;
		}
		if(tmp1) {
			return o[tmp]();
		} else {
			return o[field];
		}
	}
};
Reflect.setProperty = function(o,field,value) {
	var tmp;
	var tmp1;
	if(o.__properties__) {
		tmp = o.__properties__["set_" + field];
		tmp1 = tmp;
	} else {
		tmp1 = false;
	}
	if(tmp1) {
		o[tmp](value);
	} else {
		o[field] = value;
	}
};
Reflect.callMethod = function(o,func,args) {
	return func.apply(o,args);
};
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
			a.push(f);
		}
		}
	}
	return a;
};
Reflect.isFunction = function(f) {
	if(typeof(f) == "function") {
		return !(f.__name__ || f.__ename__);
	} else {
		return false;
	}
};
Reflect.compare = function(a,b) {
	if(a == b) {
		return 0;
	} else if(a > b) {
		return 1;
	} else {
		return -1;
	}
};
Reflect.compareMethods = function(f1,f2) {
	if(f1 == f2) {
		return true;
	}
	if(!Reflect.isFunction(f1) || !Reflect.isFunction(f2)) {
		return false;
	}
	if(f1.scope == f2.scope && f1.method == f2.method) {
		return f1.method != null;
	} else {
		return false;
	}
};
Reflect.isObject = function(v) {
	if(v == null) {
		return false;
	}
	var t = typeof(v);
	if(!(t == "string" || t == "object" && v.__enum__ == null)) {
		if(t == "function") {
			return (v.__name__ || v.__ename__) != null;
		} else {
			return false;
		}
	} else {
		return true;
	}
};
Reflect.isEnumValue = function(v) {
	if(v != null) {
		return v.__enum__ != null;
	} else {
		return false;
	}
};
Reflect.deleteField = function(o,field) {
	if(!Object.prototype.hasOwnProperty.call(o,field)) {
		return false;
	}
	delete(o[field]);
	return true;
};
Reflect.copy = function(o) {
	if(o == null) {
		return null;
	}
	var o2 = { };
	var _g = 0;
	var _g1 = Reflect.fields(o);
	while(_g < _g1.length) {
		var f = _g1[_g];
		++_g;
		o2[f] = Reflect.field(o,f);
	}
	return o2;
};
Reflect.makeVarArgs = function(f) {
	return function() {
		var a = Array.prototype.slice;
		var a1 = arguments;
		var a2 = a.call(a1);
		return f(a2);
	};
};
var Std = function() { };
$hxClasses["Std"] = Std;
Std.__name__ = "Std";
Std.is = function(v,t) {
	return js_Boot.__instanceof(v,t);
};
Std.isOfType = function(v,t) {
	return js_Boot.__instanceof(v,t);
};
Std.downcast = function(value,c) {
	if(js_Boot.__downcastCheck(value,c)) {
		return value;
	} else {
		return null;
	}
};
Std.instance = function(value,c) {
	if(js_Boot.__downcastCheck(value,c)) {
		return value;
	} else {
		return null;
	}
};
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.int = function(x) {
	return x | 0;
};
Std.parseInt = function(x) {
	if(x != null) {
		var _g = 0;
		var _g1 = x.length;
		while(_g < _g1) {
			var i = _g++;
			var c = x.charCodeAt(i);
			if(c <= 8 || c >= 14 && c != 32 && c != 45) {
				var nc = x.charCodeAt(i + 1);
				var v = parseInt(x,nc == 120 || nc == 88 ? 16 : 10);
				if(isNaN(v)) {
					return null;
				} else {
					return v;
				}
			}
		}
	}
	return null;
};
Std.parseFloat = function(x) {
	return parseFloat(x);
};
Std.random = function(x) {
	if(x <= 0) {
		return 0;
	} else {
		return Math.floor(Math.random() * x);
	}
};
var StringBuf = function() {
	this.b = "";
};
$hxClasses["StringBuf"] = StringBuf;
StringBuf.__name__ = "StringBuf";
StringBuf.prototype = {
	b: null
	,get_length: function() {
		return this.b.length;
	}
	,add: function(x) {
		this.b += Std.string(x);
	}
	,addChar: function(c) {
		this.b += String.fromCodePoint(c);
	}
	,addSub: function(s,pos,len) {
		this.b += len == null ? HxOverrides.substr(s,pos,null) : HxOverrides.substr(s,pos,len);
	}
	,toString: function() {
		return this.b;
	}
	,__class__: StringBuf
	,__properties__: {get_length:"get_length"}
};
var haxe_SysTools = function() { };
$hxClasses["haxe.SysTools"] = haxe_SysTools;
haxe_SysTools.__name__ = "haxe.SysTools";
haxe_SysTools.quoteUnixArg = function(argument) {
	if(argument == "") {
		return "''";
	}
	if(!new EReg("[^a-zA-Z0-9_@%+=:,./-]","").match(argument)) {
		return argument;
	}
	return "'" + StringTools.replace(argument,"'","'\"'\"'") + "'";
};
haxe_SysTools.quoteWinArg = function(argument,escapeMetaCharacters) {
	if(!new EReg("^[^ \t\\\\\"]+$","").match(argument)) {
		var result_b = "";
		var needquote = argument.indexOf(" ") != -1 || argument.indexOf("\t") != -1 || argument == "";
		if(needquote) {
			result_b += "\"";
		}
		var bs_buf = new StringBuf();
		var _g = 0;
		var _g1 = argument.length;
		while(_g < _g1) {
			var i = _g++;
			var _g2 = HxOverrides.cca(argument,i);
			if(_g2 == null) {
				var c = _g2;
				if(bs_buf.b.length > 0) {
					result_b += Std.string(bs_buf.b);
					bs_buf = new StringBuf();
				}
				result_b += String.fromCodePoint(c);
			} else {
				switch(_g2) {
				case 34:
					var bs = bs_buf.b;
					result_b += bs == null ? "null" : "" + bs;
					result_b += bs == null ? "null" : "" + bs;
					bs_buf = new StringBuf();
					result_b += "\\\"";
					break;
				case 92:
					bs_buf.b += "\\";
					break;
				default:
					var c1 = _g2;
					if(bs_buf.b.length > 0) {
						result_b += Std.string(bs_buf.b);
						bs_buf = new StringBuf();
					}
					result_b += String.fromCodePoint(c1);
				}
			}
		}
		result_b += Std.string(bs_buf.b);
		if(needquote) {
			result_b += Std.string(bs_buf.b);
			result_b += "\"";
		}
		argument = result_b;
	}
	if(escapeMetaCharacters) {
		var result_b = "";
		var _g = 0;
		var _g1 = argument.length;
		while(_g < _g1) {
			var i = _g++;
			var c = HxOverrides.cca(argument,i);
			if(haxe_SysTools.winMetaCharacters.indexOf(c) >= 0) {
				result_b += String.fromCodePoint(94);
			}
			result_b += String.fromCodePoint(c);
		}
		return result_b;
	} else {
		return argument;
	}
};
var StringTools = function() { };
$hxClasses["StringTools"] = StringTools;
StringTools.__name__ = "StringTools";
StringTools.urlEncode = function(s) {
	return encodeURIComponent(s);
};
StringTools.urlDecode = function(s) {
	return decodeURIComponent(s.split("+").join(" "));
};
StringTools.htmlEscape = function(s,quotes) {
	var buf_b = "";
	var _g_offset = 0;
	var _g_s = s;
	while(_g_offset < _g_s.length) {
		var s = _g_s;
		var index = _g_offset++;
		var c = s.charCodeAt(index);
		if(c >= 55296 && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
		}
		var c1 = c;
		if(c1 >= 65536) {
			++_g_offset;
		}
		var code = c1;
		switch(code) {
		case 34:
			if(quotes) {
				buf_b += "&quot;";
			} else {
				buf_b += String.fromCodePoint(code);
			}
			break;
		case 38:
			buf_b += "&amp;";
			break;
		case 39:
			if(quotes) {
				buf_b += "&#039;";
			} else {
				buf_b += String.fromCodePoint(code);
			}
			break;
		case 60:
			buf_b += "&lt;";
			break;
		case 62:
			buf_b += "&gt;";
			break;
		default:
			buf_b += String.fromCodePoint(code);
		}
	}
	return buf_b;
};
StringTools.htmlUnescape = function(s) {
	return s.split("&gt;").join(">").split("&lt;").join("<").split("&quot;").join("\"").split("&#039;").join("'").split("&amp;").join("&");
};
StringTools.contains = function(s,value) {
	return s.indexOf(value) != -1;
};
StringTools.startsWith = function(s,start) {
	if(s.length >= start.length) {
		return s.lastIndexOf(start,0) == 0;
	} else {
		return false;
	}
};
StringTools.endsWith = function(s,end) {
	var elen = end.length;
	var slen = s.length;
	if(slen >= elen) {
		return s.indexOf(end,slen - elen) == slen - elen;
	} else {
		return false;
	}
};
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
StringTools.lpad = function(s,c,l) {
	if(c.length <= 0) {
		return s;
	}
	var buf_b = "";
	l -= s.length;
	while(buf_b.length < l) buf_b += c == null ? "null" : "" + c;
	buf_b += s == null ? "null" : "" + s;
	return buf_b;
};
StringTools.rpad = function(s,c,l) {
	if(c.length <= 0) {
		return s;
	}
	var buf_b = "";
	buf_b += s == null ? "null" : "" + s;
	while(buf_b.length < l) buf_b += c == null ? "null" : "" + c;
	return buf_b;
};
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
StringTools.hex = function(n,digits) {
	var s = "";
	var hexChars = "0123456789ABCDEF";
	while(true) {
		s = hexChars.charAt(n & 15) + s;
		n >>>= 4;
		if(!(n > 0)) {
			break;
		}
	}
	if(digits != null) {
		while(s.length < digits) s = "0" + s;
	}
	return s;
};
StringTools.fastCodeAt = function(s,index) {
	return s.charCodeAt(index);
};
StringTools.iterator = function(s) {
	return new haxe_iterators_StringIterator(s);
};
StringTools.keyValueIterator = function(s) {
	return new haxe_iterators_StringKeyValueIterator(s);
};
StringTools.isEof = function(c) {
	return c != c;
};
StringTools.quoteUnixArg = function(argument) {
	if(argument == "") {
		return "''";
	} else if(!new EReg("[^a-zA-Z0-9_@%+=:,./-]","").match(argument)) {
		return argument;
	} else {
		return "'" + StringTools.replace(argument,"'","'\"'\"'") + "'";
	}
};
StringTools.quoteWinArg = function(argument,escapeMetaCharacters) {
	var argument1 = argument;
	if(!new EReg("^[^ \t\\\\\"]+$","").match(argument1)) {
		var result_b = "";
		var needquote = argument1.indexOf(" ") != -1 || argument1.indexOf("\t") != -1 || argument1 == "";
		if(needquote) {
			result_b += "\"";
		}
		var bs_buf = new StringBuf();
		var _g = 0;
		var _g1 = argument1.length;
		while(_g < _g1) {
			var i = _g++;
			var _g2 = HxOverrides.cca(argument1,i);
			if(_g2 == null) {
				var c = _g2;
				if(bs_buf.b.length > 0) {
					result_b += Std.string(bs_buf.b);
					bs_buf = new StringBuf();
				}
				result_b += String.fromCodePoint(c);
			} else {
				switch(_g2) {
				case 34:
					var bs = bs_buf.b;
					result_b += Std.string(bs);
					result_b += Std.string(bs);
					bs_buf = new StringBuf();
					result_b += "\\\"";
					break;
				case 92:
					bs_buf.b += "\\";
					break;
				default:
					var c1 = _g2;
					if(bs_buf.b.length > 0) {
						result_b += Std.string(bs_buf.b);
						bs_buf = new StringBuf();
					}
					result_b += String.fromCodePoint(c1);
				}
			}
		}
		result_b += Std.string(bs_buf.b);
		if(needquote) {
			result_b += Std.string(bs_buf.b);
			result_b += "\"";
		}
		argument1 = result_b;
	}
	if(escapeMetaCharacters) {
		var result_b = "";
		var _g = 0;
		var _g1 = argument1.length;
		while(_g < _g1) {
			var i = _g++;
			var c = HxOverrides.cca(argument1,i);
			if(haxe_SysTools.winMetaCharacters.indexOf(c) >= 0) {
				result_b += String.fromCodePoint(94);
			}
			result_b += String.fromCodePoint(c);
		}
		return result_b;
	} else {
		return argument1;
	}
};
StringTools.utf16CodePointAt = function(s,index) {
	var c = s.charCodeAt(index);
	if(c >= 55296 && c <= 56319) {
		c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
	}
	return c;
};
var ValueType = $hxEnums["ValueType"] = { __ename__ : "ValueType", __constructs__ : ["TNull","TInt","TFloat","TBool","TObject","TFunction","TClass","TEnum","TUnknown"]
	,TNull: {_hx_index:0,__enum__:"ValueType",toString:$estr}
	,TInt: {_hx_index:1,__enum__:"ValueType",toString:$estr}
	,TFloat: {_hx_index:2,__enum__:"ValueType",toString:$estr}
	,TBool: {_hx_index:3,__enum__:"ValueType",toString:$estr}
	,TObject: {_hx_index:4,__enum__:"ValueType",toString:$estr}
	,TFunction: {_hx_index:5,__enum__:"ValueType",toString:$estr}
	,TClass: ($_=function(c) { return {_hx_index:6,c:c,__enum__:"ValueType",toString:$estr}; },$_.__params__ = ["c"],$_)
	,TEnum: ($_=function(e) { return {_hx_index:7,e:e,__enum__:"ValueType",toString:$estr}; },$_.__params__ = ["e"],$_)
	,TUnknown: {_hx_index:8,__enum__:"ValueType",toString:$estr}
};
ValueType.__empty_constructs__ = [ValueType.TNull,ValueType.TInt,ValueType.TFloat,ValueType.TBool,ValueType.TObject,ValueType.TFunction,ValueType.TUnknown];
var Type = function() { };
$hxClasses["Type"] = Type;
Type.__name__ = "Type";
Type.getClass = function(o) {
	return js_Boot.getClass(o);
};
Type.getEnum = function(o) {
	if(o == null) {
		return null;
	}
	return $hxEnums[o.__enum__];
};
Type.getSuperClass = function(c) {
	return c.__super__;
};
Type.getClassName = function(c) {
	return c.__name__;
};
Type.getEnumName = function(e) {
	return e.__ename__;
};
Type.resolveClass = function(name) {
	return $hxClasses[name];
};
Type.resolveEnum = function(name) {
	return $hxEnums[name];
};
Type.createInstance = function(cl,args) {
	var ctor = Function.prototype.bind.apply(cl,[null].concat(args));
	return new (ctor);
};
Type.createEmptyInstance = function(cl) {
	return Object.create(cl.prototype);
};
Type.createEnum = function(e,constr,params) {
	var f = Reflect.field(e,constr);
	if(f == null) {
		throw haxe_Exception.thrown("No such constructor " + constr);
	}
	if(Reflect.isFunction(f)) {
		if(params == null) {
			throw haxe_Exception.thrown("Constructor " + constr + " need parameters");
		}
		return f.apply(e,params);
	}
	if(params != null && params.length != 0) {
		throw haxe_Exception.thrown("Constructor " + constr + " does not need parameters");
	}
	return f;
};
Type.createEnumIndex = function(e,index,params) {
	var c = e.__constructs__[index];
	if(c == null) {
		throw haxe_Exception.thrown(index + " is not a valid enum constructor index");
	}
	return Type.createEnum(e,c,params);
};
Type.getInstanceFields = function(c) {
	var a = [];
	for(var i in c.prototype) a.push(i);
	HxOverrides.remove(a,"__class__");
	HxOverrides.remove(a,"__properties__");
	return a;
};
Type.getClassFields = function(c) {
	var a = Reflect.fields(c);
	HxOverrides.remove(a,"__name__");
	HxOverrides.remove(a,"__interfaces__");
	HxOverrides.remove(a,"__properties__");
	HxOverrides.remove(a,"__super__");
	HxOverrides.remove(a,"__meta__");
	HxOverrides.remove(a,"prototype");
	return a;
};
Type.getEnumConstructs = function(e) {
	return e.__constructs__.slice();
};
Type.typeof = function(v) {
	switch(typeof(v)) {
	case "boolean":
		return ValueType.TBool;
	case "function":
		if(v.__name__ || v.__ename__) {
			return ValueType.TObject;
		}
		return ValueType.TFunction;
	case "number":
		if(Math.ceil(v) == v % 2147483648.0) {
			return ValueType.TInt;
		}
		return ValueType.TFloat;
	case "object":
		if(v == null) {
			return ValueType.TNull;
		}
		var e = v.__enum__;
		if(e != null) {
			return ValueType.TEnum($hxEnums[e]);
		}
		var c = js_Boot.getClass(v);
		if(c != null) {
			return ValueType.TClass(c);
		}
		return ValueType.TObject;
	case "string":
		return ValueType.TClass(String);
	case "undefined":
		return ValueType.TNull;
	default:
		return ValueType.TUnknown;
	}
};
Type.enumEq = function(a,b) {
	if(a == b) {
		return true;
	}
	try {
		var e = a.__enum__;
		if(e == null || e != b.__enum__) {
			return false;
		}
		if(a._hx_index != b._hx_index) {
			return false;
		}
		var enm = $hxEnums[e];
		var ctorName = enm.__constructs__[a._hx_index];
		var params = enm[ctorName].__params__;
		var _g = 0;
		while(_g < params.length) {
			var f = params[_g];
			++_g;
			if(!Type.enumEq(a[f],b[f])) {
				return false;
			}
		}
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		return false;
	}
	return true;
};
Type.enumConstructor = function(e) {
	return $hxEnums[e.__enum__].__constructs__[e._hx_index];
};
Type.enumParameters = function(e) {
	var enm = $hxEnums[e.__enum__];
	var ctorName = enm.__constructs__[e._hx_index];
	var params = enm[ctorName].__params__;
	if(params != null) {
		var _g = [];
		var _g1 = 0;
		while(_g1 < params.length) {
			var p = params[_g1];
			++_g1;
			_g.push(e[p]);
		}
		return _g;
	} else {
		return [];
	}
};
Type.enumIndex = function(e) {
	return e._hx_index;
};
Type.allEnums = function(e) {
	return e.__empty_constructs__.slice();
};
var UInt = {};
UInt.add = function(a,b) {
	return a + b;
};
UInt.div = function(a,b) {
	return UInt.toFloat(a) / UInt.toFloat(b);
};
UInt.mul = function(a,b) {
	return a * b;
};
UInt.sub = function(a,b) {
	return a - b;
};
UInt.gt = function(a,b) {
	var aNeg = a < 0;
	var bNeg = b < 0;
	if(aNeg != bNeg) {
		return aNeg;
	} else {
		return a > b;
	}
};
UInt.gte = function(a,b) {
	var aNeg = a < 0;
	var bNeg = b < 0;
	if(aNeg != bNeg) {
		return aNeg;
	} else {
		return a >= b;
	}
};
UInt.lt = function(a,b) {
	return UInt.gt(b,a);
};
UInt.lte = function(a,b) {
	return UInt.gte(b,a);
};
UInt.and = function(a,b) {
	return a & b;
};
UInt.or = function(a,b) {
	return a | b;
};
UInt.xor = function(a,b) {
	return a ^ b;
};
UInt.shl = function(a,b) {
	return a << b;
};
UInt.shr = function(a,b) {
	return a >>> b;
};
UInt.ushr = function(a,b) {
	return a >>> b;
};
UInt.mod = function(a,b) {
	return UInt.toFloat(a) % UInt.toFloat(b) | 0;
};
UInt.addWithFloat = function(a,b) {
	return UInt.toFloat(a) + b;
};
UInt.mulWithFloat = function(a,b) {
	return UInt.toFloat(a) * b;
};
UInt.divFloat = function(a,b) {
	return UInt.toFloat(a) / b;
};
UInt.floatDiv = function(a,b) {
	return a / UInt.toFloat(b);
};
UInt.subFloat = function(a,b) {
	return UInt.toFloat(a) - b;
};
UInt.floatSub = function(a,b) {
	return a - UInt.toFloat(b);
};
UInt.gtFloat = function(a,b) {
	return UInt.toFloat(a) > b;
};
UInt.equalsInt = function(a,b) {
	return a == b;
};
UInt.notEqualsInt = function(a,b) {
	return a != b;
};
UInt.equalsFloat = function(a,b) {
	return UInt.toFloat(a) == b;
};
UInt.notEqualsFloat = function(a,b) {
	return UInt.toFloat(a) != b;
};
UInt.gteFloat = function(a,b) {
	return UInt.toFloat(a) >= b;
};
UInt.floatGt = function(a,b) {
	return a > UInt.toFloat(b);
};
UInt.floatGte = function(a,b) {
	return a >= UInt.toFloat(b);
};
UInt.ltFloat = function(a,b) {
	return UInt.toFloat(a) < b;
};
UInt.lteFloat = function(a,b) {
	return UInt.toFloat(a) <= b;
};
UInt.floatLt = function(a,b) {
	return a < UInt.toFloat(b);
};
UInt.floatLte = function(a,b) {
	return a <= UInt.toFloat(b);
};
UInt.modFloat = function(a,b) {
	return UInt.toFloat(a) % b;
};
UInt.floatMod = function(a,b) {
	return a % UInt.toFloat(b);
};
UInt.negBits = function(this1) {
	return ~this1;
};
UInt.prefixIncrement = function(this1) {
	return ++this1;
};
UInt.postfixIncrement = function(this1) {
	return this1++;
};
UInt.prefixDecrement = function(this1) {
	return --this1;
};
UInt.postfixDecrement = function(this1) {
	return this1--;
};
UInt.toString = function(this1,radix) {
	return Std.string(UInt.toFloat(this1));
};
UInt.toInt = function(this1) {
	return this1;
};
UInt.toFloat = function(this1) {
	var int = this1;
	if(int < 0) {
		return 4294967296.0 + int;
	} else {
		return int + 0.0;
	}
};
var haxe_StackItem = $hxEnums["haxe.StackItem"] = { __ename__ : "haxe.StackItem", __constructs__ : ["CFunction","Module","FilePos","Method","LocalFunction"]
	,CFunction: {_hx_index:0,__enum__:"haxe.StackItem",toString:$estr}
	,Module: ($_=function(m) { return {_hx_index:1,m:m,__enum__:"haxe.StackItem",toString:$estr}; },$_.__params__ = ["m"],$_)
	,FilePos: ($_=function(s,file,line,column) { return {_hx_index:2,s:s,file:file,line:line,column:column,__enum__:"haxe.StackItem",toString:$estr}; },$_.__params__ = ["s","file","line","column"],$_)
	,Method: ($_=function(classname,method) { return {_hx_index:3,classname:classname,method:method,__enum__:"haxe.StackItem",toString:$estr}; },$_.__params__ = ["classname","method"],$_)
	,LocalFunction: ($_=function(v) { return {_hx_index:4,v:v,__enum__:"haxe.StackItem",toString:$estr}; },$_.__params__ = ["v"],$_)
};
haxe_StackItem.__empty_constructs__ = [haxe_StackItem.CFunction];
var haxe_CallStack = {};
haxe_CallStack.__properties__ = {get_length:"get_length"};
haxe_CallStack.get_length = function(this1) {
	return this1.length;
};
haxe_CallStack.callStack = function() {
	return haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.callStack());
};
haxe_CallStack.exceptionStack = function() {
	var eStack = haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.exceptionStack());
	return haxe_CallStack.subtract(eStack,haxe_CallStack.callStack());
};
haxe_CallStack.toString = function(stack) {
	var b = new StringBuf();
	var _g = 0;
	var _g1 = stack;
	while(_g < _g1.length) {
		var s = _g1[_g];
		++_g;
		b.b += "\nCalled from ";
		haxe_CallStack.itemToString(b,s);
	}
	return b.b;
};
haxe_CallStack.subtract = function(this1,stack) {
	var startIndex = -1;
	var i = -1;
	while(++i < this1.length) {
		var _g = 0;
		var _g1 = stack.length;
		while(_g < _g1) {
			var j = _g++;
			if(haxe_CallStack.equalItems(this1[i],stack[j])) {
				if(startIndex < 0) {
					startIndex = i;
				}
				++i;
				if(i >= this1.length) {
					break;
				}
			} else {
				startIndex = -1;
			}
		}
		if(startIndex >= 0) {
			break;
		}
	}
	if(startIndex >= 0) {
		return this1.slice(0,startIndex);
	} else {
		return this1;
	}
};
haxe_CallStack.copy = function(this1) {
	return this1.slice();
};
haxe_CallStack.get = function(this1,index) {
	return this1[index];
};
haxe_CallStack.asArray = function(this1) {
	return this1;
};
haxe_CallStack.equalItems = function(item1,item2) {
	if(item1 == null) {
		if(item2 == null) {
			return true;
		} else {
			return false;
		}
	} else {
		switch(item1._hx_index) {
		case 0:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 0) {
				return true;
			} else {
				return false;
			}
			break;
		case 1:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 1) {
				var m1 = item1.m;
				var m2 = item2.m;
				return m1 == m2;
			} else {
				return false;
			}
			break;
		case 2:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 2) {
				var item11 = item1.s;
				var file1 = item1.file;
				var line1 = item1.line;
				var col1 = item1.column;
				var col2 = item2.column;
				var line2 = item2.line;
				var file2 = item2.file;
				var item21 = item2.s;
				if(file1 == file2 && line1 == line2 && col1 == col2) {
					return haxe_CallStack.equalItems(item11,item21);
				} else {
					return false;
				}
			} else {
				return false;
			}
			break;
		case 3:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 3) {
				var class1 = item1.classname;
				var method1 = item1.method;
				var method2 = item2.method;
				var class2 = item2.classname;
				if(class1 == class2) {
					return method1 == method2;
				} else {
					return false;
				}
			} else {
				return false;
			}
			break;
		case 4:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 4) {
				var v1 = item1.v;
				var v2 = item2.v;
				return v1 == v2;
			} else {
				return false;
			}
			break;
		}
	}
};
haxe_CallStack.exceptionToString = function(e) {
	if(e.get_previous() == null) {
		var tmp = "Exception: " + e.get_message();
		var tmp1 = e.get_stack();
		return tmp + (tmp1 == null ? "null" : haxe_CallStack.toString(tmp1));
	}
	var result = "";
	var e1 = e;
	var prev = null;
	while(e1 != null) {
		if(prev == null) {
			var result1 = "Exception: " + e1.get_message();
			var tmp = e1.get_stack();
			result = result1 + (tmp == null ? "null" : haxe_CallStack.toString(tmp)) + result;
		} else {
			var prevStack = haxe_CallStack.subtract(e1.get_stack(),prev.get_stack());
			result = "Exception: " + e1.get_message() + (prevStack == null ? "null" : haxe_CallStack.toString(prevStack)) + "\n\nNext " + result;
		}
		prev = e1;
		e1 = e1.get_previous();
	}
	return result;
};
haxe_CallStack.itemToString = function(b,s) {
	switch(s._hx_index) {
	case 0:
		b.b += "a C function";
		break;
	case 1:
		var m = s.m;
		b.b += "module ";
		b.b += m == null ? "null" : "" + m;
		break;
	case 2:
		var col = s.column;
		var line = s.line;
		var file = s.file;
		var s1 = s.s;
		if(s1 != null) {
			haxe_CallStack.itemToString(b,s1);
			b.b += " (";
		}
		b.b += file == null ? "null" : "" + file;
		b.b += " line ";
		b.b += line == null ? "null" : "" + line;
		if(col != null) {
			b.b += " column ";
			b.b += col == null ? "null" : "" + col;
		}
		if(s1 != null) {
			b.b += ")";
		}
		break;
	case 3:
		var meth = s.method;
		var cname = s.classname;
		b.b += Std.string(cname == null ? "<unknown>" : cname);
		b.b += ".";
		b.b += meth == null ? "null" : "" + meth;
		break;
	case 4:
		var n = s.v;
		b.b += "local function #";
		b.b += n == null ? "null" : "" + n;
		break;
	}
};
var haxe_IMap = function() { };
$hxClasses["haxe.IMap"] = haxe_IMap;
haxe_IMap.__name__ = "haxe.IMap";
haxe_IMap.__isInterface__ = true;
haxe_IMap.prototype = {
	get: null
	,set: null
	,exists: null
	,remove: null
	,keys: null
	,iterator: null
	,keyValueIterator: null
	,copy: null
	,toString: null
	,clear: null
	,__class__: haxe_IMap
};
var haxe_DynamicAccess = {};
haxe_DynamicAccess._new = function() {
	var this1 = { };
	return this1;
};
haxe_DynamicAccess.get = function(this1,key) {
	return this1[key];
};
haxe_DynamicAccess.set = function(this1,key,value) {
	return this1[key] = value;
};
haxe_DynamicAccess.exists = function(this1,key) {
	return Object.prototype.hasOwnProperty.call(this1,key);
};
haxe_DynamicAccess.remove = function(this1,key) {
	return Reflect.deleteField(this1,key);
};
haxe_DynamicAccess.keys = function(this1) {
	return Reflect.fields(this1);
};
haxe_DynamicAccess.copy = function(this1) {
	return Reflect.copy(this1);
};
haxe_DynamicAccess.iterator = function(this1) {
	return new haxe_iterators_DynamicAccessIterator(this1);
};
haxe_DynamicAccess.keyValueIterator = function(this1) {
	return new haxe_iterators_DynamicAccessKeyValueIterator(this1);
};
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
	this.__skipStack = 0;
	var old = Error.prepareStackTrace;
	Error.prepareStackTrace = function(e) { return e.stack; }
	if(((native) instanceof Error)) {
		this.stack = native.stack;
	} else {
		var e = null;
		if(Error.captureStackTrace) {
			Error.captureStackTrace(this,haxe_Exception);
			e = this;
		} else {
			e = new Error();
			if(typeof(e.stack) == "undefined") {
				try { throw e; } catch(_) {}
				this.__skipStack++;
			}
		}
		this.stack = e.stack;
	}
	Error.prepareStackTrace = old;
};
$hxClasses["haxe.Exception"] = haxe_Exception;
haxe_Exception.__name__ = "haxe.Exception";
haxe_Exception.caught = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value;
	} else if(((value) instanceof Error)) {
		return new haxe_Exception(value.message,null,value);
	} else {
		return new haxe_ValueException(value,null,value);
	}
};
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		e.__skipStack++;
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	__skipStack: null
	,__nativeException: null
	,__previousException: null
	,unwrap: function() {
		return this.__nativeException;
	}
	,toString: function() {
		return this.get_message();
	}
	,details: function() {
		if(this.get_previous() == null) {
			var tmp = "Exception: " + this.get_message();
			var tmp1 = this.get_stack();
			return tmp + (tmp1 == null ? "null" : haxe_CallStack.toString(tmp1));
		} else {
			var result = "";
			var e = this;
			var prev = null;
			while(e != null) {
				if(prev == null) {
					var result1 = "Exception: " + e.get_message();
					var tmp = e.get_stack();
					result = result1 + (tmp == null ? "null" : haxe_CallStack.toString(tmp)) + result;
				} else {
					var prevStack = haxe_CallStack.subtract(e.get_stack(),prev.get_stack());
					result = "Exception: " + e.get_message() + (prevStack == null ? "null" : haxe_CallStack.toString(prevStack)) + "\n\nNext " + result;
				}
				prev = e;
				e = e.get_previous();
			}
			return result;
		}
	}
	,__shiftStack: function() {
		this.__skipStack++;
	}
	,get_message: function() {
		return this.message;
	}
	,get_previous: function() {
		return this.__previousException;
	}
	,get_native: function() {
		return this.__nativeException;
	}
	,get_stack: function() {
		var _g = this.__exceptionStack;
		if(_g == null) {
			var value = haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.normalize(this.stack),this.__skipStack);
			this.setProperty("__exceptionStack",value);
			return value;
		} else {
			var s = _g;
			return s;
		}
	}
	,setProperty: function(name,value) {
		try {
			Object.defineProperty(this,name,{ value : value});
		} catch( _g ) {
			this[name] = value;
		}
	}
	,get___exceptionStack: function() {
		return this.__exceptionStack;
	}
	,set___exceptionStack: function(value) {
		this.setProperty("__exceptionStack",value);
		return value;
	}
	,get___skipStack: function() {
		return this.__skipStack;
	}
	,set___skipStack: function(value) {
		this.setProperty("__skipStack",value);
		return value;
	}
	,get___nativeException: function() {
		return this.__nativeException;
	}
	,set___nativeException: function(value) {
		this.setProperty("__nativeException",value);
		return value;
	}
	,get___previousException: function() {
		return this.__previousException;
	}
	,set___previousException: function(value) {
		this.setProperty("__previousException",value);
		return value;
	}
	,__class__: haxe_Exception
	,__properties__: {set___exceptionStack:"set___exceptionStack",get___exceptionStack:"get___exceptionStack",get_native:"get_native",get_previous:"get_previous",get_stack:"get_stack",get_message:"get_message"}
});
var haxe_Int32 = {};
haxe_Int32.negate = function(this1) {
	return ~this1 + 1 | 0;
};
haxe_Int32.preIncrement = function(this1) {
	this1 = ++this1 | 0;
	return this1;
};
haxe_Int32.postIncrement = function(this1) {
	var ret = this1++;
	this1 |= 0;
	return ret;
};
haxe_Int32.preDecrement = function(this1) {
	this1 = --this1 | 0;
	return this1;
};
haxe_Int32.postDecrement = function(this1) {
	var ret = this1--;
	this1 |= 0;
	return ret;
};
haxe_Int32.add = function(a,b) {
	return a + b | 0;
};
haxe_Int32.addInt = function(a,b) {
	return a + b | 0;
};
haxe_Int32.sub = function(a,b) {
	return a - b | 0;
};
haxe_Int32.subInt = function(a,b) {
	return a - b | 0;
};
haxe_Int32.intSub = function(a,b) {
	return a - b | 0;
};
haxe_Int32.mul = function(a,b) {
	return haxe_Int32._mul(a,b);
};
haxe_Int32.mulInt = function(a,b) {
	return haxe_Int32._mul(a,b);
};
haxe_Int32.toFloat = function(this1) {
	return this1;
};
haxe_Int32.ucompare = function(a,b) {
	if(a < 0) {
		if(b < 0) {
			return ~b - ~a | 0;
		} else {
			return 1;
		}
	}
	if(b < 0) {
		return -1;
	} else {
		return a - b | 0;
	}
};
haxe_Int32.clamp = function(x) {
	return x | 0;
};
var haxe_Int64 = {};
haxe_Int64.__properties__ = {get_low:"get_low",get_high:"get_high"};
haxe_Int64._new = function(x) {
	var this1 = x;
	return this1;
};
haxe_Int64.copy = function(this1) {
	var this2 = new haxe__$Int64__$_$_$Int64(this1.high,this1.low);
	return this2;
};
haxe_Int64.make = function(high,low) {
	var this1 = new haxe__$Int64__$_$_$Int64(high,low);
	return this1;
};
haxe_Int64.ofInt = function(x) {
	var this1 = new haxe__$Int64__$_$_$Int64(x >> 31,x);
	return this1;
};
haxe_Int64.toInt = function(x) {
	if(x.high != x.low >> 31) {
		throw haxe_Exception.thrown("Overflow");
	}
	return x.low;
};
haxe_Int64.is = function(val) {
	return ((val) instanceof haxe__$Int64__$_$_$Int64);
};
haxe_Int64.isInt64 = function(val) {
	return ((val) instanceof haxe__$Int64__$_$_$Int64);
};
haxe_Int64.getHigh = function(x) {
	return x.high;
};
haxe_Int64.getLow = function(x) {
	return x.low;
};
haxe_Int64.isNeg = function(x) {
	return x.high < 0;
};
haxe_Int64.isZero = function(x) {
	var b_high = 0;
	var b_low = 0;
	if(x.high == b_high) {
		return x.low == b_low;
	} else {
		return false;
	}
};
haxe_Int64.compare = function(a,b) {
	var v = a.high - b.high | 0;
	if(v == 0) {
		v = haxe_Int32.ucompare(a.low,b.low);
	}
	if(a.high < 0) {
		if(b.high < 0) {
			return v;
		} else {
			return -1;
		}
	} else if(b.high >= 0) {
		return v;
	} else {
		return 1;
	}
};
haxe_Int64.ucompare = function(a,b) {
	var v = haxe_Int32.ucompare(a.high,b.high);
	if(v != 0) {
		return v;
	} else {
		return haxe_Int32.ucompare(a.low,b.low);
	}
};
haxe_Int64.toStr = function(x) {
	return haxe_Int64.toString(x);
};
haxe_Int64.toString = function(this1) {
	var i = this1;
	var b_high = 0;
	var b_low = 0;
	if(i.high == b_high && i.low == b_low) {
		return "0";
	}
	var str = "";
	var neg = false;
	if(i.high < 0) {
		neg = true;
	}
	var this1 = new haxe__$Int64__$_$_$Int64(0,10);
	var ten = this1;
	while(true) {
		var b_high = 0;
		var b_low = 0;
		if(!(i.high != b_high || i.low != b_low)) {
			break;
		}
		var r = haxe_Int64.divMod(i,ten);
		if(r.modulus.high < 0) {
			var x = r.modulus;
			var high = ~x.high;
			var low = ~x.low + 1 | 0;
			if(low == 0) {
				var ret = high++;
				high = high | 0;
			}
			var this_high = high;
			var this_low = low;
			str = this_low + str;
			var x1 = r.quotient;
			var high1 = ~x1.high;
			var low1 = ~x1.low + 1 | 0;
			if(low1 == 0) {
				var ret1 = high1++;
				high1 = high1 | 0;
			}
			var this1 = new haxe__$Int64__$_$_$Int64(high1,low1);
			i = this1;
		} else {
			str = r.modulus.low + str;
			i = r.quotient;
		}
	}
	if(neg) {
		str = "-" + str;
	}
	return str;
};
haxe_Int64.parseString = function(sParam) {
	return haxe_Int64Helper.parseString(sParam);
};
haxe_Int64.fromFloat = function(f) {
	return haxe_Int64Helper.fromFloat(f);
};
haxe_Int64.divMod = function(dividend,divisor) {
	if(divisor.high == 0) {
		switch(divisor.low) {
		case 0:
			throw haxe_Exception.thrown("divide by zero");
		case 1:
			var this1 = new haxe__$Int64__$_$_$Int64(dividend.high,dividend.low);
			var this2 = new haxe__$Int64__$_$_$Int64(0,0);
			return { quotient : this1, modulus : this2};
		}
	}
	var divSign = dividend.high < 0 != divisor.high < 0;
	var modulus;
	if(dividend.high < 0) {
		var high = ~dividend.high;
		var low = ~dividend.low + 1 | 0;
		if(low == 0) {
			var ret = high++;
			high = high | 0;
		}
		var this1 = new haxe__$Int64__$_$_$Int64(high,low);
		modulus = this1;
	} else {
		var this1 = new haxe__$Int64__$_$_$Int64(dividend.high,dividend.low);
		modulus = this1;
	}
	if(divisor.high < 0) {
		var high = ~divisor.high;
		var low = ~divisor.low + 1 | 0;
		if(low == 0) {
			var ret = high++;
			high = high | 0;
		}
		var this1 = new haxe__$Int64__$_$_$Int64(high,low);
		divisor = this1;
	}
	var this1 = new haxe__$Int64__$_$_$Int64(0,0);
	var quotient = this1;
	var this1 = new haxe__$Int64__$_$_$Int64(0,1);
	var mask = this1;
	while(!(divisor.high < 0)) {
		var v = haxe_Int32.ucompare(divisor.high,modulus.high);
		var cmp = v != 0 ? v : haxe_Int32.ucompare(divisor.low,modulus.low);
		var b = 1;
		b &= 63;
		if(b == 0) {
			var this1 = new haxe__$Int64__$_$_$Int64(divisor.high,divisor.low);
			divisor = this1;
		} else if(b < 32) {
			var this2 = new haxe__$Int64__$_$_$Int64(divisor.high << b | divisor.low >>> 32 - b,divisor.low << b);
			divisor = this2;
		} else {
			var this3 = new haxe__$Int64__$_$_$Int64(divisor.low << b - 32,0);
			divisor = this3;
		}
		var b1 = 1;
		b1 &= 63;
		if(b1 == 0) {
			var this4 = new haxe__$Int64__$_$_$Int64(mask.high,mask.low);
			mask = this4;
		} else if(b1 < 32) {
			var this5 = new haxe__$Int64__$_$_$Int64(mask.high << b1 | mask.low >>> 32 - b1,mask.low << b1);
			mask = this5;
		} else {
			var this6 = new haxe__$Int64__$_$_$Int64(mask.low << b1 - 32,0);
			mask = this6;
		}
		if(cmp >= 0) {
			break;
		}
	}
	while(true) {
		var b_high = 0;
		var b_low = 0;
		if(!(mask.high != b_high || mask.low != b_low)) {
			break;
		}
		var v = haxe_Int32.ucompare(modulus.high,divisor.high);
		if((v != 0 ? v : haxe_Int32.ucompare(modulus.low,divisor.low)) >= 0) {
			var this1 = new haxe__$Int64__$_$_$Int64(quotient.high | mask.high,quotient.low | mask.low);
			quotient = this1;
			var high = modulus.high - divisor.high | 0;
			var low = modulus.low - divisor.low | 0;
			if(haxe_Int32.ucompare(modulus.low,divisor.low) < 0) {
				var ret = high--;
				high = high | 0;
			}
			var this2 = new haxe__$Int64__$_$_$Int64(high,low);
			modulus = this2;
		}
		var b = 1;
		b &= 63;
		if(b == 0) {
			var this3 = new haxe__$Int64__$_$_$Int64(mask.high,mask.low);
			mask = this3;
		} else if(b < 32) {
			var this4 = new haxe__$Int64__$_$_$Int64(mask.high >>> b,mask.high << 32 - b | mask.low >>> b);
			mask = this4;
		} else {
			var this5 = new haxe__$Int64__$_$_$Int64(0,mask.high >>> b - 32);
			mask = this5;
		}
		var b1 = 1;
		b1 &= 63;
		if(b1 == 0) {
			var this6 = new haxe__$Int64__$_$_$Int64(divisor.high,divisor.low);
			divisor = this6;
		} else if(b1 < 32) {
			var this7 = new haxe__$Int64__$_$_$Int64(divisor.high >>> b1,divisor.high << 32 - b1 | divisor.low >>> b1);
			divisor = this7;
		} else {
			var this8 = new haxe__$Int64__$_$_$Int64(0,divisor.high >>> b1 - 32);
			divisor = this8;
		}
	}
	if(divSign) {
		var high = ~quotient.high;
		var low = ~quotient.low + 1 | 0;
		if(low == 0) {
			var ret = high++;
			high = high | 0;
		}
		var this1 = new haxe__$Int64__$_$_$Int64(high,low);
		quotient = this1;
	}
	if(dividend.high < 0) {
		var high = ~modulus.high;
		var low = ~modulus.low + 1 | 0;
		if(low == 0) {
			var ret = high++;
			high = high | 0;
		}
		var this1 = new haxe__$Int64__$_$_$Int64(high,low);
		modulus = this1;
	}
	return { quotient : quotient, modulus : modulus};
};
haxe_Int64.neg = function(x) {
	var high = ~x.high;
	var low = ~x.low + 1 | 0;
	if(low == 0) {
		var ret = high++;
		high = high | 0;
	}
	var this1 = new haxe__$Int64__$_$_$Int64(high,low);
	return this1;
};
haxe_Int64.preIncrement = function(this1) {
	var this2 = new haxe__$Int64__$_$_$Int64(this1.high,this1.low);
	this1 = this2;
	var ret = this1.low++;
	this1.low = this1.low | 0;
	if(this1.low == 0) {
		var ret = this1.high++;
		this1.high = this1.high | 0;
	}
	return this1;
};
haxe_Int64.postIncrement = function(this1) {
	var ret = this1;
	var this2 = new haxe__$Int64__$_$_$Int64(this1.high,this1.low);
	this1 = this2;
	var ret1 = this1.low++;
	this1.low = this1.low | 0;
	if(this1.low == 0) {
		var ret1 = this1.high++;
		this1.high = this1.high | 0;
	}
	return ret;
};
haxe_Int64.preDecrement = function(this1) {
	var this2 = new haxe__$Int64__$_$_$Int64(this1.high,this1.low);
	this1 = this2;
	if(this1.low == 0) {
		var ret = this1.high--;
		this1.high = this1.high | 0;
	}
	var ret = this1.low--;
	this1.low = this1.low | 0;
	return this1;
};
haxe_Int64.postDecrement = function(this1) {
	var ret = this1;
	var this2 = new haxe__$Int64__$_$_$Int64(this1.high,this1.low);
	this1 = this2;
	if(this1.low == 0) {
		var ret1 = this1.high--;
		this1.high = this1.high | 0;
	}
	var ret1 = this1.low--;
	this1.low = this1.low | 0;
	return ret;
};
haxe_Int64.add = function(a,b) {
	var high = a.high + b.high | 0;
	var low = a.low + b.low | 0;
	if(haxe_Int32.ucompare(low,a.low) < 0) {
		var ret = high++;
		high = high | 0;
	}
	var this1 = new haxe__$Int64__$_$_$Int64(high,low);
	return this1;
};
haxe_Int64.addInt = function(a,b) {
	var b_high = b >> 31;
	var b_low = b;
	var high = a.high + b_high | 0;
	var low = a.low + b_low | 0;
	if(haxe_Int32.ucompare(low,a.low) < 0) {
		var ret = high++;
		high = high | 0;
	}
	var this1 = new haxe__$Int64__$_$_$Int64(high,low);
	return this1;
};
haxe_Int64.sub = function(a,b) {
	var high = a.high - b.high | 0;
	var low = a.low - b.low | 0;
	if(haxe_Int32.ucompare(a.low,b.low) < 0) {
		var ret = high--;
		high = high | 0;
	}
	var this1 = new haxe__$Int64__$_$_$Int64(high,low);
	return this1;
};
haxe_Int64.subInt = function(a,b) {
	var b_high = b >> 31;
	var b_low = b;
	var high = a.high - b_high | 0;
	var low = a.low - b_low | 0;
	if(haxe_Int32.ucompare(a.low,b_low) < 0) {
		var ret = high--;
		high = high | 0;
	}
	var this1 = new haxe__$Int64__$_$_$Int64(high,low);
	return this1;
};
haxe_Int64.intSub = function(a,b) {
	var a_high = a >> 31;
	var a_low = a;
	var high = a_high - b.high | 0;
	var low = a_low - b.low | 0;
	if(haxe_Int32.ucompare(a_low,b.low) < 0) {
		var ret = high--;
		high = high | 0;
	}
	var this1 = new haxe__$Int64__$_$_$Int64(high,low);
	return this1;
};
haxe_Int64.mul = function(a,b) {
	var mask = 65535;
	var al = a.low & mask;
	var ah = a.low >>> 16;
	var bl = b.low & mask;
	var bh = b.low >>> 16;
	var p00 = haxe_Int32._mul(al,bl);
	var p10 = haxe_Int32._mul(ah,bl);
	var p01 = haxe_Int32._mul(al,bh);
	var p11 = haxe_Int32._mul(ah,bh);
	var low = p00;
	var high = (p11 + (p01 >>> 16) | 0) + (p10 >>> 16) | 0;
	p01 <<= 16;
	low = low + p01 | 0;
	if(haxe_Int32.ucompare(low,p01) < 0) {
		var ret = high++;
		high = high | 0;
	}
	p10 <<= 16;
	low = low + p10 | 0;
	if(haxe_Int32.ucompare(low,p10) < 0) {
		var ret = high++;
		high = high | 0;
	}
	high = high + (haxe_Int32._mul(a.low,b.high) + haxe_Int32._mul(a.high,b.low) | 0) | 0;
	var this1 = new haxe__$Int64__$_$_$Int64(high,low);
	return this1;
};
haxe_Int64.mulInt = function(a,b) {
	var b_high = b >> 31;
	var b_low = b;
	var mask = 65535;
	var al = a.low & mask;
	var ah = a.low >>> 16;
	var bl = b_low & mask;
	var bh = b_low >>> 16;
	var p00 = haxe_Int32._mul(al,bl);
	var p10 = haxe_Int32._mul(ah,bl);
	var p01 = haxe_Int32._mul(al,bh);
	var p11 = haxe_Int32._mul(ah,bh);
	var low = p00;
	var high = (p11 + (p01 >>> 16) | 0) + (p10 >>> 16) | 0;
	p01 <<= 16;
	low = low + p01 | 0;
	if(haxe_Int32.ucompare(low,p01) < 0) {
		var ret = high++;
		high = high | 0;
	}
	p10 <<= 16;
	low = low + p10 | 0;
	if(haxe_Int32.ucompare(low,p10) < 0) {
		var ret = high++;
		high = high | 0;
	}
	high = high + (haxe_Int32._mul(a.low,b_high) + haxe_Int32._mul(a.high,b_low) | 0) | 0;
	var this1 = new haxe__$Int64__$_$_$Int64(high,low);
	return this1;
};
haxe_Int64.div = function(a,b) {
	return haxe_Int64.divMod(a,b).quotient;
};
haxe_Int64.divInt = function(a,b) {
	var this1 = new haxe__$Int64__$_$_$Int64(b >> 31,b);
	return haxe_Int64.divMod(a,this1).quotient;
};
haxe_Int64.intDiv = function(a,b) {
	var this1 = new haxe__$Int64__$_$_$Int64(a >> 31,a);
	var x = haxe_Int64.divMod(this1,b).quotient;
	if(x.high != x.low >> 31) {
		throw haxe_Exception.thrown("Overflow");
	}
	var x1 = x.low;
	var this1 = new haxe__$Int64__$_$_$Int64(x1 >> 31,x1);
	return this1;
};
haxe_Int64.mod = function(a,b) {
	return haxe_Int64.divMod(a,b).modulus;
};
haxe_Int64.modInt = function(a,b) {
	var this1 = new haxe__$Int64__$_$_$Int64(b >> 31,b);
	var x = haxe_Int64.divMod(a,this1).modulus;
	if(x.high != x.low >> 31) {
		throw haxe_Exception.thrown("Overflow");
	}
	var x1 = x.low;
	var this1 = new haxe__$Int64__$_$_$Int64(x1 >> 31,x1);
	return this1;
};
haxe_Int64.intMod = function(a,b) {
	var this1 = new haxe__$Int64__$_$_$Int64(a >> 31,a);
	var x = haxe_Int64.divMod(this1,b).modulus;
	if(x.high != x.low >> 31) {
		throw haxe_Exception.thrown("Overflow");
	}
	var x1 = x.low;
	var this1 = new haxe__$Int64__$_$_$Int64(x1 >> 31,x1);
	return this1;
};
haxe_Int64.eq = function(a,b) {
	if(a.high == b.high) {
		return a.low == b.low;
	} else {
		return false;
	}
};
haxe_Int64.eqInt = function(a,b) {
	var b_high = b >> 31;
	var b_low = b;
	if(a.high == b_high) {
		return a.low == b_low;
	} else {
		return false;
	}
};
haxe_Int64.neq = function(a,b) {
	if(a.high == b.high) {
		return a.low != b.low;
	} else {
		return true;
	}
};
haxe_Int64.neqInt = function(a,b) {
	var b_high = b >> 31;
	var b_low = b;
	if(a.high == b_high) {
		return a.low != b_low;
	} else {
		return true;
	}
};
haxe_Int64.lt = function(a,b) {
	var v = a.high - b.high | 0;
	if(v == 0) {
		v = haxe_Int32.ucompare(a.low,b.low);
	}
	return (a.high < 0 ? b.high < 0 ? v : -1 : b.high >= 0 ? v : 1) < 0;
};
haxe_Int64.ltInt = function(a,b) {
	var b_high = b >> 31;
	var b_low = b;
	var v = a.high - b_high | 0;
	if(v == 0) {
		v = haxe_Int32.ucompare(a.low,b_low);
	}
	return (a.high < 0 ? b_high < 0 ? v : -1 : b_high >= 0 ? v : 1) < 0;
};
haxe_Int64.intLt = function(a,b) {
	var a_high = a >> 31;
	var a_low = a;
	var v = a_high - b.high | 0;
	if(v == 0) {
		v = haxe_Int32.ucompare(a_low,b.low);
	}
	return (a_high < 0 ? b.high < 0 ? v : -1 : b.high >= 0 ? v : 1) < 0;
};
haxe_Int64.lte = function(a,b) {
	var v = a.high - b.high | 0;
	if(v == 0) {
		v = haxe_Int32.ucompare(a.low,b.low);
	}
	return (a.high < 0 ? b.high < 0 ? v : -1 : b.high >= 0 ? v : 1) <= 0;
};
haxe_Int64.lteInt = function(a,b) {
	var b_high = b >> 31;
	var b_low = b;
	var v = a.high - b_high | 0;
	if(v == 0) {
		v = haxe_Int32.ucompare(a.low,b_low);
	}
	return (a.high < 0 ? b_high < 0 ? v : -1 : b_high >= 0 ? v : 1) <= 0;
};
haxe_Int64.intLte = function(a,b) {
	var a_high = a >> 31;
	var a_low = a;
	var v = a_high - b.high | 0;
	if(v == 0) {
		v = haxe_Int32.ucompare(a_low,b.low);
	}
	return (a_high < 0 ? b.high < 0 ? v : -1 : b.high >= 0 ? v : 1) <= 0;
};
haxe_Int64.gt = function(a,b) {
	var v = a.high - b.high | 0;
	if(v == 0) {
		v = haxe_Int32.ucompare(a.low,b.low);
	}
	return (a.high < 0 ? b.high < 0 ? v : -1 : b.high >= 0 ? v : 1) > 0;
};
haxe_Int64.gtInt = function(a,b) {
	var b_high = b >> 31;
	var b_low = b;
	var v = a.high - b_high | 0;
	if(v == 0) {
		v = haxe_Int32.ucompare(a.low,b_low);
	}
	return (a.high < 0 ? b_high < 0 ? v : -1 : b_high >= 0 ? v : 1) > 0;
};
haxe_Int64.intGt = function(a,b) {
	var a_high = a >> 31;
	var a_low = a;
	var v = a_high - b.high | 0;
	if(v == 0) {
		v = haxe_Int32.ucompare(a_low,b.low);
	}
	return (a_high < 0 ? b.high < 0 ? v : -1 : b.high >= 0 ? v : 1) > 0;
};
haxe_Int64.gte = function(a,b) {
	var v = a.high - b.high | 0;
	if(v == 0) {
		v = haxe_Int32.ucompare(a.low,b.low);
	}
	return (a.high < 0 ? b.high < 0 ? v : -1 : b.high >= 0 ? v : 1) >= 0;
};
haxe_Int64.gteInt = function(a,b) {
	var b_high = b >> 31;
	var b_low = b;
	var v = a.high - b_high | 0;
	if(v == 0) {
		v = haxe_Int32.ucompare(a.low,b_low);
	}
	return (a.high < 0 ? b_high < 0 ? v : -1 : b_high >= 0 ? v : 1) >= 0;
};
haxe_Int64.intGte = function(a,b) {
	var a_high = a >> 31;
	var a_low = a;
	var v = a_high - b.high | 0;
	if(v == 0) {
		v = haxe_Int32.ucompare(a_low,b.low);
	}
	return (a_high < 0 ? b.high < 0 ? v : -1 : b.high >= 0 ? v : 1) >= 0;
};
haxe_Int64.complement = function(a) {
	var this1 = new haxe__$Int64__$_$_$Int64(~a.high,~a.low);
	return this1;
};
haxe_Int64.and = function(a,b) {
	var this1 = new haxe__$Int64__$_$_$Int64(a.high & b.high,a.low & b.low);
	return this1;
};
haxe_Int64.or = function(a,b) {
	var this1 = new haxe__$Int64__$_$_$Int64(a.high | b.high,a.low | b.low);
	return this1;
};
haxe_Int64.xor = function(a,b) {
	var this1 = new haxe__$Int64__$_$_$Int64(a.high ^ b.high,a.low ^ b.low);
	return this1;
};
haxe_Int64.shl = function(a,b) {
	b &= 63;
	if(b == 0) {
		var this1 = new haxe__$Int64__$_$_$Int64(a.high,a.low);
		return this1;
	} else if(b < 32) {
		var this1 = new haxe__$Int64__$_$_$Int64(a.high << b | a.low >>> 32 - b,a.low << b);
		return this1;
	} else {
		var this1 = new haxe__$Int64__$_$_$Int64(a.low << b - 32,0);
		return this1;
	}
};
haxe_Int64.shr = function(a,b) {
	b &= 63;
	if(b == 0) {
		var this1 = new haxe__$Int64__$_$_$Int64(a.high,a.low);
		return this1;
	} else if(b < 32) {
		var this1 = new haxe__$Int64__$_$_$Int64(a.high >> b,a.high << 32 - b | a.low >>> b);
		return this1;
	} else {
		var this1 = new haxe__$Int64__$_$_$Int64(a.high >> 31,a.high >> b - 32);
		return this1;
	}
};
haxe_Int64.ushr = function(a,b) {
	b &= 63;
	if(b == 0) {
		var this1 = new haxe__$Int64__$_$_$Int64(a.high,a.low);
		return this1;
	} else if(b < 32) {
		var this1 = new haxe__$Int64__$_$_$Int64(a.high >>> b,a.high << 32 - b | a.low >>> b);
		return this1;
	} else {
		var this1 = new haxe__$Int64__$_$_$Int64(0,a.high >>> b - 32);
		return this1;
	}
};
haxe_Int64.get_high = function(this1) {
	return this1.high;
};
haxe_Int64.set_high = function(this1,x) {
	return this1.high = x;
};
haxe_Int64.get_low = function(this1) {
	return this1.low;
};
haxe_Int64.set_low = function(this1,x) {
	return this1.low = x;
};
var haxe__$Int64__$_$_$Int64 = function(high,low) {
	this.high = high;
	this.low = low;
};
$hxClasses["haxe._Int64.___Int64"] = haxe__$Int64__$_$_$Int64;
haxe__$Int64__$_$_$Int64.__name__ = "haxe._Int64.___Int64";
haxe__$Int64__$_$_$Int64.prototype = {
	high: null
	,low: null
	,toString: function() {
		return haxe_Int64.toString(this);
	}
	,__class__: haxe__$Int64__$_$_$Int64
};
var haxe_Int64Helper = function() { };
$hxClasses["haxe.Int64Helper"] = haxe_Int64Helper;
haxe_Int64Helper.__name__ = "haxe.Int64Helper";
haxe_Int64Helper.parseString = function(sParam) {
	var base_high = 0;
	var base_low = 10;
	var this1 = new haxe__$Int64__$_$_$Int64(0,0);
	var current = this1;
	var this1 = new haxe__$Int64__$_$_$Int64(0,1);
	var multiplier = this1;
	var sIsNegative = false;
	var s = StringTools.trim(sParam);
	if(s.charAt(0) == "-") {
		sIsNegative = true;
		s = s.substring(1,s.length);
	}
	var len = s.length;
	var _g = 0;
	var _g1 = len;
	while(_g < _g1) {
		var i = _g++;
		var digitInt = HxOverrides.cca(s,len - 1 - i) - 48;
		if(digitInt < 0 || digitInt > 9) {
			throw haxe_Exception.thrown("NumberFormatError");
		}
		if(digitInt != 0) {
			var digit_high = digitInt >> 31;
			var digit_low = digitInt;
			if(sIsNegative) {
				var mask = 65535;
				var al = multiplier.low & mask;
				var ah = multiplier.low >>> 16;
				var bl = digit_low & mask;
				var bh = digit_low >>> 16;
				var p00 = haxe_Int32._mul(al,bl);
				var p10 = haxe_Int32._mul(ah,bl);
				var p01 = haxe_Int32._mul(al,bh);
				var p11 = haxe_Int32._mul(ah,bh);
				var low = p00;
				var high = (p11 + (p01 >>> 16) | 0) + (p10 >>> 16) | 0;
				p01 <<= 16;
				low = low + p01 | 0;
				if(haxe_Int32.ucompare(low,p01) < 0) {
					var ret = high++;
					high = high | 0;
				}
				p10 <<= 16;
				low = low + p10 | 0;
				if(haxe_Int32.ucompare(low,p10) < 0) {
					var ret1 = high++;
					high = high | 0;
				}
				high = high + (haxe_Int32._mul(multiplier.low,digit_high) + haxe_Int32._mul(multiplier.high,digit_low) | 0) | 0;
				var b_high = high;
				var b_low = low;
				var high1 = current.high - b_high | 0;
				var low1 = current.low - b_low | 0;
				if(haxe_Int32.ucompare(current.low,b_low) < 0) {
					var ret2 = high1--;
					high1 = high1 | 0;
				}
				var this1 = new haxe__$Int64__$_$_$Int64(high1,low1);
				current = this1;
				if(!(current.high < 0)) {
					throw haxe_Exception.thrown("NumberFormatError: Underflow");
				}
			} else {
				var mask1 = 65535;
				var al1 = multiplier.low & mask1;
				var ah1 = multiplier.low >>> 16;
				var bl1 = digit_low & mask1;
				var bh1 = digit_low >>> 16;
				var p001 = haxe_Int32._mul(al1,bl1);
				var p101 = haxe_Int32._mul(ah1,bl1);
				var p011 = haxe_Int32._mul(al1,bh1);
				var p111 = haxe_Int32._mul(ah1,bh1);
				var low2 = p001;
				var high2 = (p111 + (p011 >>> 16) | 0) + (p101 >>> 16) | 0;
				p011 <<= 16;
				low2 = low2 + p011 | 0;
				if(haxe_Int32.ucompare(low2,p011) < 0) {
					var ret3 = high2++;
					high2 = high2 | 0;
				}
				p101 <<= 16;
				low2 = low2 + p101 | 0;
				if(haxe_Int32.ucompare(low2,p101) < 0) {
					var ret4 = high2++;
					high2 = high2 | 0;
				}
				high2 = high2 + (haxe_Int32._mul(multiplier.low,digit_high) + haxe_Int32._mul(multiplier.high,digit_low) | 0) | 0;
				var b_high1 = high2;
				var b_low1 = low2;
				var high3 = current.high + b_high1 | 0;
				var low3 = current.low + b_low1 | 0;
				if(haxe_Int32.ucompare(low3,current.low) < 0) {
					var ret5 = high3++;
					high3 = high3 | 0;
				}
				var this2 = new haxe__$Int64__$_$_$Int64(high3,low3);
				current = this2;
				if(current.high < 0) {
					throw haxe_Exception.thrown("NumberFormatError: Overflow");
				}
			}
		}
		var mask2 = 65535;
		var al2 = multiplier.low & mask2;
		var ah2 = multiplier.low >>> 16;
		var bl2 = base_low & mask2;
		var bh2 = base_low >>> 16;
		var p002 = haxe_Int32._mul(al2,bl2);
		var p102 = haxe_Int32._mul(ah2,bl2);
		var p012 = haxe_Int32._mul(al2,bh2);
		var p112 = haxe_Int32._mul(ah2,bh2);
		var low4 = p002;
		var high4 = (p112 + (p012 >>> 16) | 0) + (p102 >>> 16) | 0;
		p012 <<= 16;
		low4 = low4 + p012 | 0;
		if(haxe_Int32.ucompare(low4,p012) < 0) {
			var ret6 = high4++;
			high4 = high4 | 0;
		}
		p102 <<= 16;
		low4 = low4 + p102 | 0;
		if(haxe_Int32.ucompare(low4,p102) < 0) {
			var ret7 = high4++;
			high4 = high4 | 0;
		}
		high4 = high4 + (haxe_Int32._mul(multiplier.low,base_high) + haxe_Int32._mul(multiplier.high,base_low) | 0) | 0;
		var this3 = new haxe__$Int64__$_$_$Int64(high4,low4);
		multiplier = this3;
	}
	return current;
};
haxe_Int64Helper.fromFloat = function(f) {
	if(isNaN(f) || !isFinite(f)) {
		throw haxe_Exception.thrown("Number is NaN or Infinite");
	}
	var noFractions = f - f % 1;
	if(noFractions > 9007199254740991) {
		throw haxe_Exception.thrown("Conversion overflow");
	}
	if(noFractions < -9007199254740991) {
		throw haxe_Exception.thrown("Conversion underflow");
	}
	var this1 = new haxe__$Int64__$_$_$Int64(0,0);
	var result = this1;
	var neg = noFractions < 0;
	var rest = neg ? -noFractions : noFractions;
	var i = 0;
	while(rest >= 1) {
		var curr = rest % 2;
		rest /= 2;
		if(curr >= 1) {
			var a_high = 0;
			var a_low = 1;
			var b = i;
			b &= 63;
			var b1;
			if(b == 0) {
				var this1 = new haxe__$Int64__$_$_$Int64(a_high,a_low);
				b1 = this1;
			} else if(b < 32) {
				var this2 = new haxe__$Int64__$_$_$Int64(a_high << b | a_low >>> 32 - b,a_low << b);
				b1 = this2;
			} else {
				var this3 = new haxe__$Int64__$_$_$Int64(a_low << b - 32,0);
				b1 = this3;
			}
			var high = result.high + b1.high | 0;
			var low = result.low + b1.low | 0;
			if(haxe_Int32.ucompare(low,result.low) < 0) {
				var ret = high++;
				high = high | 0;
			}
			var this4 = new haxe__$Int64__$_$_$Int64(high,low);
			result = this4;
		}
		++i;
	}
	if(neg) {
		var high = ~result.high;
		var low = ~result.low + 1 | 0;
		if(low == 0) {
			var ret = high++;
			high = high | 0;
		}
		var this1 = new haxe__$Int64__$_$_$Int64(high,low);
		result = this1;
	}
	return result;
};
var haxe_Log = function() { };
$hxClasses["haxe.Log"] = haxe_Log;
haxe_Log.__name__ = "haxe.Log";
haxe_Log.formatOutput = function(v,infos) {
	var str = Std.string(v);
	if(infos == null) {
		return str;
	}
	var pstr = infos.fileName + ":" + infos.lineNumber;
	if(infos.customParams != null) {
		var _g = 0;
		var _g1 = infos.customParams;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			str += ", " + Std.string(v);
		}
	}
	return pstr + ": " + str;
};
haxe_Log.trace = function(v,infos) {
	var str = haxe_Log.formatOutput(v,infos);
	if(typeof(console) != "undefined" && console.log != null) {
		console.log(str);
	}
};
var haxe_NativeStackTrace = function() { };
$hxClasses["haxe.NativeStackTrace"] = haxe_NativeStackTrace;
haxe_NativeStackTrace.__name__ = "haxe.NativeStackTrace";
haxe_NativeStackTrace.lastError = null;
haxe_NativeStackTrace.wrapCallSite = null;
haxe_NativeStackTrace.saveStack = function(e) {
	haxe_NativeStackTrace.lastError = e;
};
haxe_NativeStackTrace.callStack = function() {
	var e = new Error("");
	var stack = haxe_NativeStackTrace.tryHaxeStack(e);
	if(typeof(stack) == "undefined") {
		try {
			throw e;
		} catch( _g ) {
		}
		stack = e.stack;
	}
	return haxe_NativeStackTrace.normalize(stack,2);
};
haxe_NativeStackTrace.exceptionStack = function() {
	return haxe_NativeStackTrace.normalize(haxe_NativeStackTrace.tryHaxeStack(haxe_NativeStackTrace.lastError));
};
haxe_NativeStackTrace.toHaxe = function(s,skip) {
	if(skip == null) {
		skip = 0;
	}
	if(s == null) {
		return [];
	} else if(typeof(s) == "string") {
		var stack = s.split("\n");
		if(stack[0] == "Error") {
			stack.shift();
		}
		var m = [];
		var _g = 0;
		var _g1 = stack.length;
		while(_g < _g1) {
			var i = _g++;
			if(skip > i) {
				continue;
			}
			var line = stack[i];
			var matched = line.match(/^    at ([A-Za-z0-9_. ]+) \(([^)]+):([0-9]+):([0-9]+)\)$/);
			if(matched != null) {
				var path = matched[1].split(".");
				if(path[0] == "$hxClasses") {
					path.shift();
				}
				var meth = path.pop();
				var file = matched[2];
				var line1 = Std.parseInt(matched[3]);
				var column = Std.parseInt(matched[4]);
				m.push(haxe_StackItem.FilePos(meth == "Anonymous function" ? haxe_StackItem.LocalFunction() : meth == "Global code" ? null : haxe_StackItem.Method(path.join("."),meth),file,line1,column));
			} else {
				m.push(haxe_StackItem.Module(StringTools.trim(line)));
			}
		}
		return m;
	} else if(skip > 0 && Array.isArray(s)) {
		return s.slice(skip);
	} else {
		return s;
	}
};
haxe_NativeStackTrace.tryHaxeStack = function(e) {
	if(e == null) {
		return [];
	}
	var oldValue = Error.prepareStackTrace;
	Error.prepareStackTrace = haxe_NativeStackTrace.prepareHxStackTrace;
	var stack = e.stack;
	Error.prepareStackTrace = oldValue;
	return stack;
};
haxe_NativeStackTrace.prepareHxStackTrace = function(e,callsites) {
	var stack = [];
	var _g = 0;
	while(_g < callsites.length) {
		var site = callsites[_g];
		++_g;
		if(haxe_NativeStackTrace.wrapCallSite != null) {
			site = haxe_NativeStackTrace.wrapCallSite(site);
		}
		var method = null;
		var fullName = site.getFunctionName();
		if(fullName != null) {
			var idx = fullName.lastIndexOf(".");
			if(idx >= 0) {
				var className = fullName.substring(0,idx);
				var methodName = fullName.substring(idx + 1);
				method = haxe_StackItem.Method(className,methodName);
			} else {
				method = haxe_StackItem.Method(null,fullName);
			}
		}
		var fileName = site.getFileName();
		var fileAddr = fileName == null ? -1 : fileName.indexOf("file:");
		if(haxe_NativeStackTrace.wrapCallSite != null && fileAddr > 0) {
			fileName = fileName.substring(fileAddr + 6);
		}
		stack.push(haxe_StackItem.FilePos(method,fileName,site.getLineNumber(),site.getColumnNumber()));
	}
	return stack;
};
haxe_NativeStackTrace.normalize = function(stack,skipItems) {
	if(skipItems == null) {
		skipItems = 0;
	}
	if(Array.isArray(stack) && skipItems > 0) {
		return stack.slice(skipItems);
	} else if(typeof(stack) == "string") {
		switch(stack.substring(0,6)) {
		case "Error\n":case "Error:":
			++skipItems;
			break;
		default:
		}
		return haxe_NativeStackTrace.skipLines(stack,skipItems);
	} else {
		return stack;
	}
};
haxe_NativeStackTrace.skipLines = function(stack,skip,pos) {
	if(pos == null) {
		pos = 0;
	}
	if(skip > 0) {
		pos = stack.indexOf("\n",pos);
		if(pos < 0) {
			return "";
		} else {
			return haxe_NativeStackTrace.skipLines(stack,--skip,pos + 1);
		}
	} else {
		return stack.substring(pos);
	}
};
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
	this.__skipStack++;
};
$hxClasses["haxe.ValueException"] = haxe_ValueException;
haxe_ValueException.__name__ = "haxe.ValueException";
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
	value: null
	,unwrap: function() {
		return this.value;
	}
	,__class__: haxe_ValueException
});
var haxe_ds_ArraySort = function() { };
$hxClasses["haxe.ds.ArraySort"] = haxe_ds_ArraySort;
haxe_ds_ArraySort.__name__ = "haxe.ds.ArraySort";
haxe_ds_ArraySort.sort = function(a,cmp) {
	haxe_ds_ArraySort.rec(a,cmp,0,a.length);
};
haxe_ds_ArraySort.rec = function(a,cmp,from,to) {
	var middle = from + to >> 1;
	if(to - from < 12) {
		if(to <= from) {
			return;
		}
		var _g = from + 1;
		var _g1 = to;
		while(_g < _g1) {
			var i = _g++;
			var j = i;
			while(j > from) {
				if(cmp(a[j],a[j - 1]) < 0) {
					haxe_ds_ArraySort.swap(a,j - 1,j);
				} else {
					break;
				}
				--j;
			}
		}
		return;
	}
	haxe_ds_ArraySort.rec(a,cmp,from,middle);
	haxe_ds_ArraySort.rec(a,cmp,middle,to);
	haxe_ds_ArraySort.doMerge(a,cmp,from,middle,to,middle - from,to - middle);
};
haxe_ds_ArraySort.doMerge = function(a,cmp,from,pivot,to,len1,len2) {
	var first_cut;
	var second_cut;
	var len11;
	var len22;
	if(len1 == 0 || len2 == 0) {
		return;
	}
	if(len1 + len2 == 2) {
		if(cmp(a[pivot],a[from]) < 0) {
			haxe_ds_ArraySort.swap(a,pivot,from);
		}
		return;
	}
	if(len1 > len2) {
		len11 = len1 >> 1;
		first_cut = from + len11;
		second_cut = haxe_ds_ArraySort.lower(a,cmp,pivot,to,first_cut);
		len22 = second_cut - pivot;
	} else {
		len22 = len2 >> 1;
		second_cut = pivot + len22;
		first_cut = haxe_ds_ArraySort.upper(a,cmp,from,pivot,second_cut);
		len11 = first_cut - from;
	}
	haxe_ds_ArraySort.rotate(a,cmp,first_cut,pivot,second_cut);
	var new_mid = first_cut + len22;
	haxe_ds_ArraySort.doMerge(a,cmp,from,first_cut,new_mid,len11,len22);
	haxe_ds_ArraySort.doMerge(a,cmp,new_mid,second_cut,to,len1 - len11,len2 - len22);
};
haxe_ds_ArraySort.rotate = function(a,cmp,from,mid,to) {
	if(from == mid || mid == to) {
		return;
	}
	var n = haxe_ds_ArraySort.gcd(to - from,mid - from);
	while(n-- != 0) {
		var val = a[from + n];
		var shift = mid - from;
		var p1 = from + n;
		var p2 = from + n + shift;
		while(p2 != from + n) {
			a[p1] = a[p2];
			p1 = p2;
			if(to - p2 > shift) {
				p2 += shift;
			} else {
				p2 = from + (shift - (to - p2));
			}
		}
		a[p1] = val;
	}
};
haxe_ds_ArraySort.gcd = function(m,n) {
	while(n != 0) {
		var t = m % n;
		m = n;
		n = t;
	}
	return m;
};
haxe_ds_ArraySort.upper = function(a,cmp,from,to,val) {
	var len = to - from;
	var half;
	var mid;
	while(len > 0) {
		half = len >> 1;
		mid = from + half;
		if(cmp(a[val],a[mid]) < 0) {
			len = half;
		} else {
			from = mid + 1;
			len = len - half - 1;
		}
	}
	return from;
};
haxe_ds_ArraySort.lower = function(a,cmp,from,to,val) {
	var len = to - from;
	var half;
	var mid;
	while(len > 0) {
		half = len >> 1;
		mid = from + half;
		if(cmp(a[mid],a[val]) < 0) {
			from = mid + 1;
			len = len - half - 1;
		} else {
			len = half;
		}
	}
	return from;
};
haxe_ds_ArraySort.swap = function(a,i,j) {
	var tmp = a[i];
	a[i] = a[j];
	a[j] = tmp;
};
haxe_ds_ArraySort.compare = function(a,cmp,i,j) {
	return cmp(a[i],a[j]);
};
var haxe_ds_BalancedTree = function() {
};
$hxClasses["haxe.ds.BalancedTree"] = haxe_ds_BalancedTree;
haxe_ds_BalancedTree.__name__ = "haxe.ds.BalancedTree";
haxe_ds_BalancedTree.__interfaces__ = [haxe_IMap];
haxe_ds_BalancedTree.prototype = {
	root: null
	,set: function(key,value) {
		this.root = this.setLoop(key,value,this.root);
	}
	,get: function(key) {
		var node = this.root;
		while(node != null) {
			var c = this.compare(key,node.key);
			if(c == 0) {
				return node.value;
			}
			if(c < 0) {
				node = node.left;
			} else {
				node = node.right;
			}
		}
		return null;
	}
	,remove: function(key) {
		try {
			this.root = this.removeLoop(key,this.root);
			return true;
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			if(typeof(haxe_Exception.caught(_g).unwrap()) == "string") {
				return false;
			} else {
				throw _g;
			}
		}
	}
	,exists: function(key) {
		var node = this.root;
		while(node != null) {
			var c = this.compare(key,node.key);
			if(c == 0) {
				return true;
			} else if(c < 0) {
				node = node.left;
			} else {
				node = node.right;
			}
		}
		return false;
	}
	,iterator: function() {
		var ret = [];
		this.iteratorLoop(this.root,ret);
		return new haxe_iterators_ArrayIterator(ret);
	}
	,keyValueIterator: function() {
		return new haxe_iterators_MapKeyValueIterator(this);
	}
	,keys: function() {
		var ret = [];
		this.keysLoop(this.root,ret);
		return new haxe_iterators_ArrayIterator(ret);
	}
	,copy: function() {
		var copied = new haxe_ds_BalancedTree();
		copied.root = this.root;
		return copied;
	}
	,setLoop: function(k,v,node) {
		if(node == null) {
			return new haxe_ds_TreeNode(null,k,v,null);
		}
		var c = this.compare(k,node.key);
		if(c == 0) {
			return new haxe_ds_TreeNode(node.left,k,v,node.right,node == null ? 0 : node._height);
		} else if(c < 0) {
			var nl = this.setLoop(k,v,node.left);
			return this.balance(nl,node.key,node.value,node.right);
		} else {
			var nr = this.setLoop(k,v,node.right);
			return this.balance(node.left,node.key,node.value,nr);
		}
	}
	,removeLoop: function(k,node) {
		if(node == null) {
			throw haxe_Exception.thrown("Not_found");
		}
		var c = this.compare(k,node.key);
		if(c == 0) {
			return this.merge(node.left,node.right);
		} else if(c < 0) {
			return this.balance(this.removeLoop(k,node.left),node.key,node.value,node.right);
		} else {
			return this.balance(node.left,node.key,node.value,this.removeLoop(k,node.right));
		}
	}
	,iteratorLoop: function(node,acc) {
		if(node != null) {
			this.iteratorLoop(node.left,acc);
			acc.push(node.value);
			this.iteratorLoop(node.right,acc);
		}
	}
	,keysLoop: function(node,acc) {
		if(node != null) {
			this.keysLoop(node.left,acc);
			acc.push(node.key);
			this.keysLoop(node.right,acc);
		}
	}
	,merge: function(t1,t2) {
		if(t1 == null) {
			return t2;
		}
		if(t2 == null) {
			return t1;
		}
		var t = this.minBinding(t2);
		return this.balance(t1,t.key,t.value,this.removeMinBinding(t2));
	}
	,minBinding: function(t) {
		if(t == null) {
			throw haxe_Exception.thrown("Not_found");
		} else if(t.left == null) {
			return t;
		} else {
			return this.minBinding(t.left);
		}
	}
	,removeMinBinding: function(t) {
		if(t.left == null) {
			return t.right;
		} else {
			return this.balance(this.removeMinBinding(t.left),t.key,t.value,t.right);
		}
	}
	,balance: function(l,k,v,r) {
		var hl = l == null ? 0 : l._height;
		var hr = r == null ? 0 : r._height;
		if(hl > hr + 2) {
			var _this = l.left;
			var _this1 = l.right;
			if((_this == null ? 0 : _this._height) >= (_this1 == null ? 0 : _this1._height)) {
				return new haxe_ds_TreeNode(l.left,l.key,l.value,new haxe_ds_TreeNode(l.right,k,v,r));
			} else {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l.left,l.key,l.value,l.right.left),l.right.key,l.right.value,new haxe_ds_TreeNode(l.right.right,k,v,r));
			}
		} else if(hr > hl + 2) {
			var _this = r.right;
			var _this1 = r.left;
			if((_this == null ? 0 : _this._height) > (_this1 == null ? 0 : _this1._height)) {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l,k,v,r.left),r.key,r.value,r.right);
			} else {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l,k,v,r.left.left),r.left.key,r.left.value,new haxe_ds_TreeNode(r.left.right,r.key,r.value,r.right));
			}
		} else {
			return new haxe_ds_TreeNode(l,k,v,r,(hl > hr ? hl : hr) + 1);
		}
	}
	,compare: function(k1,k2) {
		return Reflect.compare(k1,k2);
	}
	,toString: function() {
		if(this.root == null) {
			return "{}";
		} else {
			return "{" + this.root.toString() + "}";
		}
	}
	,clear: function() {
		this.root = null;
	}
	,__class__: haxe_ds_BalancedTree
};
var haxe_ds_TreeNode = function(l,k,v,r,h) {
	if(h == null) {
		h = -1;
	}
	this.left = l;
	this.key = k;
	this.value = v;
	this.right = r;
	if(h == -1) {
		var tmp;
		var _this = this.left;
		var _this1 = this.right;
		if((_this == null ? 0 : _this._height) > (_this1 == null ? 0 : _this1._height)) {
			var _this = this.left;
			tmp = _this == null ? 0 : _this._height;
		} else {
			var _this = this.right;
			tmp = _this == null ? 0 : _this._height;
		}
		this._height = tmp + 1;
	} else {
		this._height = h;
	}
};
$hxClasses["haxe.ds.TreeNode"] = haxe_ds_TreeNode;
haxe_ds_TreeNode.__name__ = "haxe.ds.TreeNode";
haxe_ds_TreeNode.prototype = {
	left: null
	,right: null
	,key: null
	,value: null
	,_height: null
	,toString: function() {
		return (this.left == null ? "" : this.left.toString() + ", ") + ("" + Std.string(this.key) + "=" + Std.string(this.value)) + (this.right == null ? "" : ", " + this.right.toString());
	}
	,__class__: haxe_ds_TreeNode
};
var haxe_ds_EnumValueMap = function() {
	haxe_ds_BalancedTree.call(this);
};
$hxClasses["haxe.ds.EnumValueMap"] = haxe_ds_EnumValueMap;
haxe_ds_EnumValueMap.__name__ = "haxe.ds.EnumValueMap";
haxe_ds_EnumValueMap.__interfaces__ = [haxe_IMap];
haxe_ds_EnumValueMap.__super__ = haxe_ds_BalancedTree;
haxe_ds_EnumValueMap.prototype = $extend(haxe_ds_BalancedTree.prototype,{
	compare: function(k1,k2) {
		var d = k1._hx_index - k2._hx_index;
		if(d != 0) {
			return d;
		}
		var p1 = Type.enumParameters(k1);
		var p2 = Type.enumParameters(k2);
		if(p1.length == 0 && p2.length == 0) {
			return 0;
		}
		return this.compareArgs(p1,p2);
	}
	,compareArgs: function(a1,a2) {
		var ld = a1.length - a2.length;
		if(ld != 0) {
			return ld;
		}
		var _g = 0;
		var _g1 = a1.length;
		while(_g < _g1) {
			var i = _g++;
			var d = this.compareArg(a1[i],a2[i]);
			if(d != 0) {
				return d;
			}
		}
		return 0;
	}
	,compareArg: function(v1,v2) {
		if(Reflect.isEnumValue(v1) && Reflect.isEnumValue(v2)) {
			return this.compare(v1,v2);
		} else if(((v1) instanceof Array) && ((v2) instanceof Array)) {
			return this.compareArgs(v1,v2);
		} else {
			return Reflect.compare(v1,v2);
		}
	}
	,copy: function() {
		var copied = new haxe_ds_EnumValueMap();
		copied.root = this.root;
		return copied;
	}
	,__class__: haxe_ds_EnumValueMap
});
var haxe_ds_HashMap = {};
haxe_ds_HashMap._new = function() {
	var this1 = new haxe_ds__$HashMap_HashMapData();
	return this1;
};
haxe_ds_HashMap.set = function(this1,k,v) {
	var _this = this1.keys;
	var key = k.hashCode();
	_this.h[key] = k;
	var _this = this1.values;
	var key = k.hashCode();
	_this.h[key] = v;
};
haxe_ds_HashMap.get = function(this1,k) {
	var _this = this1.values;
	var key = k.hashCode();
	return _this.h[key];
};
haxe_ds_HashMap.exists = function(this1,k) {
	var _this = this1.values;
	var key = k.hashCode();
	return _this.h.hasOwnProperty(key);
};
haxe_ds_HashMap.remove = function(this1,k) {
	this1.values.remove(k.hashCode());
	return this1.keys.remove(k.hashCode());
};
haxe_ds_HashMap.keys = function(this1) {
	return this1.keys.iterator();
};
haxe_ds_HashMap.copy = function(this1) {
	var copied = new haxe_ds__$HashMap_HashMapData();
	copied.keys = this1.keys.copy();
	copied.values = this1.values.copy();
	return copied;
};
haxe_ds_HashMap.iterator = function(this1) {
	return this1.values.iterator();
};
haxe_ds_HashMap.keyValueIterator = function(this1) {
	return new haxe_iterators_HashMapKeyValueIterator(this1);
};
haxe_ds_HashMap.clear = function(this1) {
	this1.keys.h = { };
	this1.values.h = { };
};
var haxe_ds__$HashMap_HashMapData = function() {
	this.keys = new haxe_ds_IntMap();
	this.values = new haxe_ds_IntMap();
};
$hxClasses["haxe.ds._HashMap.HashMapData"] = haxe_ds__$HashMap_HashMapData;
haxe_ds__$HashMap_HashMapData.__name__ = "haxe.ds._HashMap.HashMapData";
haxe_ds__$HashMap_HashMapData.prototype = {
	keys: null
	,values: null
	,__class__: haxe_ds__$HashMap_HashMapData
};
var haxe_ds_IntMap = function() {
	this.h = { };
};
$hxClasses["haxe.ds.IntMap"] = haxe_ds_IntMap;
haxe_ds_IntMap.__name__ = "haxe.ds.IntMap";
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
haxe_ds_IntMap.prototype = {
	h: null
	,set: function(key,value) {
		this.h[key] = value;
	}
	,get: function(key) {
		return this.h[key];
	}
	,exists: function(key) {
		return this.h.hasOwnProperty(key);
	}
	,remove: function(key) {
		if(!this.h.hasOwnProperty(key)) {
			return false;
		}
		delete(this.h[key]);
		return true;
	}
	,keys: function() {
		var a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) a.push(key | 0);
		return new haxe_iterators_ArrayIterator(a);
	}
	,iterator: function() {
		return { ref : this.h, it : this.keys(), hasNext : function() {
			return this.it.hasNext();
		}, next : function() {
			var i = this.it.next();
			return this.ref[i];
		}};
	}
	,keyValueIterator: function() {
		return new haxe_iterators_MapKeyValueIterator(this);
	}
	,copy: function() {
		var copied = new haxe_ds_IntMap();
		var key = this.keys();
		while(key.hasNext()) {
			var key1 = key.next();
			copied.h[key1] = this.h[key1];
		}
		return copied;
	}
	,toString: function() {
		var s_b = "";
		s_b += "{";
		var it = this.keys();
		var i = it;
		while(i.hasNext()) {
			var i1 = i.next();
			s_b += i1 == null ? "null" : "" + i1;
			s_b += " => ";
			s_b += Std.string(Std.string(this.h[i1]));
			if(it.hasNext()) {
				s_b += ", ";
			}
		}
		s_b += "}";
		return s_b;
	}
	,clear: function() {
		this.h = { };
	}
	,__class__: haxe_ds_IntMap
};
var haxe_ds_Map = {};
haxe_ds_Map.set = function(this1,key,value) {
	this1.set(key,value);
};
haxe_ds_Map.get = function(this1,key) {
	return this1.get(key);
};
haxe_ds_Map.exists = function(this1,key) {
	return this1.exists(key);
};
haxe_ds_Map.remove = function(this1,key) {
	return this1.remove(key);
};
haxe_ds_Map.keys = function(this1) {
	return this1.keys();
};
haxe_ds_Map.iterator = function(this1) {
	return this1.iterator();
};
haxe_ds_Map.keyValueIterator = function(this1) {
	return this1.keyValueIterator();
};
haxe_ds_Map.copy = function(this1) {
	return this1.copy();
};
haxe_ds_Map.toString = function(this1) {
	return this1.toString();
};
haxe_ds_Map.clear = function(this1) {
	this1.clear();
};
haxe_ds_Map.arrayWrite = function(this1,k,v) {
	this1.set(k,v);
	return v;
};
haxe_ds_Map.toStringMap = function(t) {
	return new haxe_ds_StringMap();
};
haxe_ds_Map.toIntMap = function(t) {
	return new haxe_ds_IntMap();
};
haxe_ds_Map.toEnumValueMapMap = function(t) {
	return new haxe_ds_EnumValueMap();
};
haxe_ds_Map.toObjectMap = function(t) {
	return new haxe_ds_ObjectMap();
};
haxe_ds_Map.fromStringMap = function(map) {
	return map;
};
haxe_ds_Map.fromIntMap = function(map) {
	return map;
};
haxe_ds_Map.fromObjectMap = function(map) {
	return map;
};
var haxe_ds_ObjectMap = function() {
	this.h = { __keys__ : { }};
};
$hxClasses["haxe.ds.ObjectMap"] = haxe_ds_ObjectMap;
haxe_ds_ObjectMap.__name__ = "haxe.ds.ObjectMap";
haxe_ds_ObjectMap.__interfaces__ = [haxe_IMap];
haxe_ds_ObjectMap.count = null;
haxe_ds_ObjectMap.assignId = function(obj) {
	return (obj.__id__ = $global.$haxeUID++);
};
haxe_ds_ObjectMap.getId = function(obj) {
	return obj.__id__;
};
haxe_ds_ObjectMap.prototype = {
	h: null
	,set: function(key,value) {
		var id = key.__id__;
		if(id == null) {
			id = (key.__id__ = $global.$haxeUID++);
		}
		this.h[id] = value;
		this.h.__keys__[id] = key;
	}
	,get: function(key) {
		return this.h[key.__id__];
	}
	,exists: function(key) {
		return this.h.__keys__[key.__id__] != null;
	}
	,remove: function(key) {
		var id = key.__id__;
		if(this.h.__keys__[id] == null) {
			return false;
		}
		delete(this.h[id]);
		delete(this.h.__keys__[id]);
		return true;
	}
	,keys: function() {
		var a = [];
		for( var key in this.h.__keys__ ) {
		if(this.h.hasOwnProperty(key)) {
			a.push(this.h.__keys__[key]);
		}
		}
		return new haxe_iterators_ArrayIterator(a);
	}
	,iterator: function() {
		return { ref : this.h, it : this.keys(), hasNext : function() {
			return this.it.hasNext();
		}, next : function() {
			var i = this.it.next();
			return this.ref[i.__id__];
		}};
	}
	,keyValueIterator: function() {
		return new haxe_iterators_MapKeyValueIterator(this);
	}
	,copy: function() {
		var copied = new haxe_ds_ObjectMap();
		var key = this.keys();
		while(key.hasNext()) {
			var key1 = key.next();
			copied.set(key1,this.h[key1.__id__]);
		}
		return copied;
	}
	,toString: function() {
		var s_b = "";
		s_b += "{";
		var it = this.keys();
		var i = it;
		while(i.hasNext()) {
			var i1 = i.next();
			s_b += Std.string(Std.string(i1));
			s_b += " => ";
			s_b += Std.string(Std.string(this.h[i1.__id__]));
			if(it.hasNext()) {
				s_b += ", ";
			}
		}
		s_b += "}";
		return s_b;
	}
	,clear: function() {
		this.h = { __keys__ : { }};
	}
	,__class__: haxe_ds_ObjectMap
};
var haxe_ds_ReadOnlyArray = {};
haxe_ds_ReadOnlyArray.__properties__ = {get_length:"get_length"};
haxe_ds_ReadOnlyArray.get_length = function(this1) {
	return this1.length;
};
haxe_ds_ReadOnlyArray.get = function(this1,i) {
	return this1[i];
};
var haxe_ds_StringMap = function() {
	this.h = Object.create(null);
};
$hxClasses["haxe.ds.StringMap"] = haxe_ds_StringMap;
haxe_ds_StringMap.__name__ = "haxe.ds.StringMap";
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.keysIterator = function(h) {
	var keys = Object.keys(h);
	var len = keys.length;
	var idx = 0;
	return { hasNext : function() {
		return idx < len;
	}, next : function() {
		idx += 1;
		return keys[idx - 1];
	}};
};
haxe_ds_StringMap.valueIterator = function(h) {
	var keys = Object.keys(h);
	var len = keys.length;
	var idx = 0;
	return { hasNext : function() {
		return idx < len;
	}, next : function() {
		idx += 1;
		return h[keys[idx - 1]];
	}};
};
haxe_ds_StringMap.kvIterator = function(h) {
	var keys = Object.keys(h);
	var len = keys.length;
	var idx = 0;
	return { hasNext : function() {
		return idx < len;
	}, next : function() {
		idx += 1;
		var k = keys[idx - 1];
		return { key : k, value : h[k]};
	}};
};
haxe_ds_StringMap.createCopy = function(h) {
	var copy = new haxe_ds_StringMap();
	for (var key in h) copy.h[key] = h[key];
	return copy;
};
haxe_ds_StringMap.stringify = function(h) {
	var s = "{";
	var first = true;
	for (var key in h) {
		if (first) first = false; else s += ',';
		s += key + ' => ' + Std.string(h[key]);
	}
	return s + "}";
};
haxe_ds_StringMap.prototype = {
	h: null
	,exists: function(key) {
		return Object.prototype.hasOwnProperty.call(this.h,key);
	}
	,get: function(key) {
		return this.h[key];
	}
	,set: function(key,value) {
		this.h[key] = value;
	}
	,remove: function(key) {
		if(Object.prototype.hasOwnProperty.call(this.h,key)) {
			delete(this.h[key]);
			return true;
		} else {
			return false;
		}
	}
	,keys: function() {
		return haxe_ds_StringMap.keysIterator(this.h);
	}
	,iterator: function() {
		return haxe_ds_StringMap.valueIterator(this.h);
	}
	,keyValueIterator: function() {
		return haxe_ds_StringMap.kvIterator(this.h);
	}
	,copy: function() {
		return haxe_ds_StringMap.createCopy(this.h);
	}
	,clear: function() {
		this.h = Object.create(null);
	}
	,toString: function() {
		return haxe_ds_StringMap.stringify(this.h);
	}
	,__class__: haxe_ds_StringMap
};
var haxe_ds_Vector = {};
haxe_ds_Vector.__properties__ = {get_length:"get_length"};
haxe_ds_Vector._new = function(length) {
	var this1 = new Array(length);
	return this1;
};
haxe_ds_Vector.get = function(this1,index) {
	return this1[index];
};
haxe_ds_Vector.set = function(this1,index,val) {
	return this1[index] = val;
};
haxe_ds_Vector.get_length = function(this1) {
	return this1.length;
};
haxe_ds_Vector.blit = function(src,srcPos,dest,destPos,len) {
	if(src == dest) {
		if(srcPos < destPos) {
			var i = srcPos + len;
			var j = destPos + len;
			var _g = 0;
			var _g1 = len;
			while(_g < _g1) {
				var k = _g++;
				--i;
				--j;
				src[j] = src[i];
			}
		} else if(srcPos > destPos) {
			var i = srcPos;
			var j = destPos;
			var _g = 0;
			var _g1 = len;
			while(_g < _g1) {
				var k = _g++;
				src[j] = src[i];
				++i;
				++j;
			}
		}
	} else {
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			dest[destPos + i] = src[srcPos + i];
		}
	}
};
haxe_ds_Vector.toArray = function(this1) {
	return this1.slice(0);
};
haxe_ds_Vector.toData = function(this1) {
	return this1;
};
haxe_ds_Vector.fromData = function(data) {
	return data;
};
haxe_ds_Vector.fromArrayCopy = function(array) {
	return array.slice(0);
};
haxe_ds_Vector.copy = function(this1) {
	var this2 = new Array(this1.length);
	var r = this2;
	haxe_ds_Vector.blit(this1,0,r,0,this1.length);
	return r;
};
haxe_ds_Vector.join = function(this1,sep) {
	var b_b = "";
	var len = this1.length;
	var _g = 0;
	var _g1 = len;
	while(_g < _g1) {
		var i = _g++;
		b_b += Std.string(Std.string(this1[i]));
		if(i < len - 1) {
			b_b += sep == null ? "null" : "" + sep;
		}
	}
	return b_b;
};
haxe_ds_Vector.map = function(this1,f) {
	var length = this1.length;
	var this2 = new Array(length);
	var r = this2;
	var len = length;
	var _g = 0;
	var _g1 = len;
	while(_g < _g1) {
		var i = _g++;
		var v = f(this1[i]);
		r[i] = v;
	}
	return r;
};
haxe_ds_Vector.sort = function(this1,f) {
	this1.sort(f);
};
var haxe_ds_WeakMap = function() {
	throw haxe_Exception.thrown("Not implemented for this platform");
};
$hxClasses["haxe.ds.WeakMap"] = haxe_ds_WeakMap;
haxe_ds_WeakMap.__name__ = "haxe.ds.WeakMap";
haxe_ds_WeakMap.__interfaces__ = [haxe_IMap];
haxe_ds_WeakMap.prototype = {
	set: function(key,value) {
	}
	,get: function(key) {
		return null;
	}
	,exists: function(key) {
		return false;
	}
	,remove: function(key) {
		return false;
	}
	,keys: function() {
		return null;
	}
	,iterator: function() {
		return null;
	}
	,keyValueIterator: function() {
		return null;
	}
	,copy: function() {
		return null;
	}
	,toString: function() {
		return null;
	}
	,clear: function() {
	}
	,__class__: haxe_ds_WeakMap
};
var haxe_io_ArrayBufferView = {};
haxe_io_ArrayBufferView.__properties__ = {get_byteLength:"get_byteLength",get_byteOffset:"get_byteOffset",get_buffer:"get_buffer"};
haxe_io_ArrayBufferView._new = function(size) {
	var this1 = new Uint8Array(size);
	return this1;
};
haxe_io_ArrayBufferView.get_byteOffset = function(this1) {
	return this1.byteOffset;
};
haxe_io_ArrayBufferView.get_byteLength = function(this1) {
	return this1.byteLength;
};
haxe_io_ArrayBufferView.get_buffer = function(this1) {
	return haxe_io_Bytes.ofData(this1.buffer);
};
haxe_io_ArrayBufferView.sub = function(this1,begin,length) {
	return new Uint8Array(this1.buffer.slice(begin,length == null ? null : begin + length));
};
haxe_io_ArrayBufferView.getData = function(this1) {
	return this1;
};
haxe_io_ArrayBufferView.fromData = function(a) {
	return a;
};
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
$hxClasses["haxe.io.Bytes"] = haxe_io_Bytes;
haxe_io_Bytes.__name__ = "haxe.io.Bytes";
haxe_io_Bytes.alloc = function(length) {
	return new haxe_io_Bytes(new ArrayBuffer(length));
};
haxe_io_Bytes.ofString = function(s,encoding) {
	if(encoding == haxe_io_Encoding.RawNative) {
		var buf = new Uint8Array(s.length << 1);
		var _g = 0;
		var _g1 = s.length;
		while(_g < _g1) {
			var i = _g++;
			var c = s.charCodeAt(i);
			buf[i << 1] = c & 255;
			buf[i << 1 | 1] = c >> 8;
		}
		return new haxe_io_Bytes(buf.buffer);
	}
	var a = [];
	var i = 0;
	while(i < s.length) {
		var c = s.charCodeAt(i++);
		if(55296 <= c && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
		}
		if(c <= 127) {
			a.push(c);
		} else if(c <= 2047) {
			a.push(192 | c >> 6);
			a.push(128 | c & 63);
		} else if(c <= 65535) {
			a.push(224 | c >> 12);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		} else {
			a.push(240 | c >> 18);
			a.push(128 | c >> 12 & 63);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.ofData = function(b) {
	var hb = b.hxBytes;
	if(hb != null) {
		return hb;
	}
	return new haxe_io_Bytes(b);
};
haxe_io_Bytes.ofHex = function(s) {
	if((s.length & 1) != 0) {
		throw haxe_Exception.thrown("Not a hex string (odd number of digits)");
	}
	var a = [];
	var i = 0;
	var len = s.length >> 1;
	while(i < len) {
		var high = s.charCodeAt(i * 2);
		var low = s.charCodeAt(i * 2 + 1);
		high = (high & 15) + ((high & 64) >> 6) * 9;
		low = (low & 15) + ((low & 64) >> 6) * 9;
		a.push((high << 4 | low) & 255);
		++i;
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.fastGet = function(b,pos) {
	return b.bytes[pos];
};
haxe_io_Bytes.prototype = {
	length: null
	,b: null
	,data: null
	,get: function(pos) {
		return this.b[pos];
	}
	,set: function(pos,v) {
		this.b[pos] = v;
	}
	,blit: function(pos,src,srcpos,len) {
		if(pos < 0 || srcpos < 0 || len < 0 || pos + len > this.length || srcpos + len > src.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(srcpos == 0 && len == src.b.byteLength) {
			this.b.set(src.b,pos);
		} else {
			this.b.set(src.b.subarray(srcpos,srcpos + len),pos);
		}
	}
	,fill: function(pos,len,value) {
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			this.b[pos++] = value;
		}
	}
	,sub: function(pos,len) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		return new haxe_io_Bytes(this.b.buffer.slice(pos + this.b.byteOffset,pos + this.b.byteOffset + len));
	}
	,compare: function(other) {
		var b1 = this.b;
		var b2 = other.b;
		var len = this.length < other.length ? this.length : other.length;
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			if(b1[i] != b2[i]) {
				return b1[i] - b2[i];
			}
		}
		return this.length - other.length;
	}
	,initData: function() {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
	}
	,getDouble: function(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getFloat64(pos,true);
	}
	,getFloat: function(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getFloat32(pos,true);
	}
	,setDouble: function(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setFloat64(pos,v,true);
	}
	,setFloat: function(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setFloat32(pos,v,true);
	}
	,getUInt16: function(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getUint16(pos,true);
	}
	,setUInt16: function(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setUint16(pos,v,true);
	}
	,getInt32: function(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getInt32(pos,true);
	}
	,setInt32: function(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setInt32(pos,v,true);
	}
	,getInt64: function(pos) {
		var this1 = new haxe__$Int64__$_$_$Int64(this.getInt32(pos + 4),this.getInt32(pos));
		return this1;
	}
	,setInt64: function(pos,v) {
		this.setInt32(pos,v.low);
		this.setInt32(pos + 4,v.high);
	}
	,getString: function(pos,len,encoding) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(encoding == null) {
			encoding = haxe_io_Encoding.UTF8;
		}
		var s = "";
		var b = this.b;
		var i = pos;
		var max = pos + len;
		switch(encoding._hx_index) {
		case 0:
			var debug = pos > 0;
			while(i < max) {
				var c = b[i++];
				if(c < 128) {
					if(c == 0) {
						break;
					}
					s += String.fromCodePoint(c);
				} else if(c < 224) {
					var code = (c & 63) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else if(c < 240) {
					var c2 = b[i++];
					var code1 = (c & 31) << 12 | (c2 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code1);
				} else {
					var c21 = b[i++];
					var c3 = b[i++];
					var u = (c & 15) << 18 | (c21 & 127) << 12 | (c3 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(u);
				}
			}
			break;
		case 1:
			while(i < max) {
				var c = b[i++] | b[i++] << 8;
				s += String.fromCodePoint(c);
			}
			break;
		}
		return s;
	}
	,readString: function(pos,len) {
		return this.getString(pos,len);
	}
	,toString: function() {
		return this.getString(0,this.length);
	}
	,toHex: function() {
		var s_b = "";
		var chars = [];
		var str = "0123456789abcdef";
		var _g = 0;
		var _g1 = str.length;
		while(_g < _g1) {
			var i = _g++;
			chars.push(HxOverrides.cca(str,i));
		}
		var _g = 0;
		var _g1 = this.length;
		while(_g < _g1) {
			var i = _g++;
			var c = this.b[i];
			s_b += String.fromCodePoint(chars[c >> 4]);
			s_b += String.fromCodePoint(chars[c & 15]);
		}
		return s_b;
	}
	,getData: function() {
		return this.b.bufferValue;
	}
	,__class__: haxe_io_Bytes
};
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__ : "haxe.io.Encoding", __constructs__ : ["UTF8","RawNative"]
	,UTF8: {_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
haxe_io_Encoding.__empty_constructs__ = [haxe_io_Encoding.UTF8,haxe_io_Encoding.RawNative];
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__ : "haxe.io.Error", __constructs__ : ["Blocked","Overflow","OutsideBounds","Custom"]
	,Blocked: {_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_.__params__ = ["e"],$_)
};
haxe_io_Error.__empty_constructs__ = [haxe_io_Error.Blocked,haxe_io_Error.Overflow,haxe_io_Error.OutsideBounds];
var haxe_io_UInt32Array = {};
haxe_io_UInt32Array.__properties__ = {get_view:"get_view",get_length:"get_length"};
haxe_io_UInt32Array._new = function(elements) {
	var this1 = new Uint32Array(elements);
	return this1;
};
haxe_io_UInt32Array.get_length = function(this1) {
	return this1.length;
};
haxe_io_UInt32Array.get_view = function(this1) {
	return this1;
};
haxe_io_UInt32Array.get = function(this1,index) {
	return this1[index];
};
haxe_io_UInt32Array.set = function(this1,index,value) {
	return this1[index] = value;
};
haxe_io_UInt32Array.sub = function(this1,begin,length) {
	return this1.subarray(begin,length == null ? this1.length : begin + length);
};
haxe_io_UInt32Array.subarray = function(this1,begin,end) {
	return this1.subarray(begin,end);
};
haxe_io_UInt32Array.getData = function(this1) {
	return this1;
};
haxe_io_UInt32Array.fromData = function(d) {
	return d;
};
haxe_io_UInt32Array.fromArray = function(a,pos,length) {
	if(pos == null) {
		pos = 0;
	}
	if(length == null) {
		length = a.length - pos;
	}
	if(pos < 0 || length < 0 || pos + length > a.length) {
		throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
	}
	if(pos == 0 && length == a.length) {
		return new Uint32Array(a);
	}
	var this1 = new Uint32Array(a.length);
	var i = this1;
	var _g = 0;
	var _g1 = length;
	while(_g < _g1) {
		var idx = _g++;
		i[idx] = a[idx + pos];
	}
	return i;
};
haxe_io_UInt32Array.fromBytes = function(bytes,bytePos,length) {
	if(bytePos == null) {
		bytePos = 0;
	}
	if(length == null) {
		length = bytes.length - bytePos >> 2;
	}
	return new Uint32Array(bytes.b.bufferValue,bytePos,length);
};
var haxe_io_UInt8Array = {};
haxe_io_UInt8Array.__properties__ = {get_view:"get_view",get_length:"get_length"};
haxe_io_UInt8Array._new = function(elements) {
	var this1 = new Uint8Array(elements);
	return this1;
};
haxe_io_UInt8Array.get_length = function(this1) {
	return this1.length;
};
haxe_io_UInt8Array.get_view = function(this1) {
	return this1;
};
haxe_io_UInt8Array.get = function(this1,index) {
	return this1[index];
};
haxe_io_UInt8Array.set = function(this1,index,value) {
	return this1[index] = value;
};
haxe_io_UInt8Array.sub = function(this1,begin,length) {
	return this1.subarray(begin,length == null ? this1.length : begin + length);
};
haxe_io_UInt8Array.subarray = function(this1,begin,end) {
	return this1.subarray(begin,end);
};
haxe_io_UInt8Array.getData = function(this1) {
	return this1;
};
haxe_io_UInt8Array.fromData = function(d) {
	return d;
};
haxe_io_UInt8Array.fromArray = function(a,pos,length) {
	if(pos == null) {
		pos = 0;
	}
	if(length == null) {
		length = a.length - pos;
	}
	if(pos < 0 || length < 0 || pos + length > a.length) {
		throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
	}
	if(pos == 0 && length == a.length) {
		return new Uint8Array(a);
	}
	var this1 = new Uint8Array(a.length);
	var i = this1;
	var _g = 0;
	var _g1 = length;
	while(_g < _g1) {
		var idx = _g++;
		i[idx] = a[idx + pos];
	}
	return i;
};
haxe_io_UInt8Array.fromBytes = function(bytes,bytePos,length) {
	if(bytePos == null) {
		bytePos = 0;
	}
	if(length == null) {
		length = bytes.length - bytePos;
	}
	return new Uint8Array(bytes.b.bufferValue,bytePos,length);
};
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
$hxClasses["haxe.iterators.ArrayIterator"] = haxe_iterators_ArrayIterator;
haxe_iterators_ArrayIterator.__name__ = "haxe.iterators.ArrayIterator";
haxe_iterators_ArrayIterator.prototype = {
	array: null
	,current: null
	,hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
	,__class__: haxe_iterators_ArrayIterator
};
var haxe_iterators_ArrayKeyValueIterator = function(array) {
	this.current = 0;
	this.array = array;
};
$hxClasses["haxe.iterators.ArrayKeyValueIterator"] = haxe_iterators_ArrayKeyValueIterator;
haxe_iterators_ArrayKeyValueIterator.__name__ = "haxe.iterators.ArrayKeyValueIterator";
haxe_iterators_ArrayKeyValueIterator.prototype = {
	current: null
	,array: null
	,hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return { value : this.array[this.current], key : this.current++};
	}
	,__class__: haxe_iterators_ArrayKeyValueIterator
};
var haxe_iterators_DynamicAccessIterator = function(access) {
	this.access = access;
	this.keys = Reflect.fields(access);
	this.index = 0;
};
$hxClasses["haxe.iterators.DynamicAccessIterator"] = haxe_iterators_DynamicAccessIterator;
haxe_iterators_DynamicAccessIterator.__name__ = "haxe.iterators.DynamicAccessIterator";
haxe_iterators_DynamicAccessIterator.prototype = {
	access: null
	,keys: null
	,index: null
	,hasNext: function() {
		return this.index < this.keys.length;
	}
	,next: function() {
		return this.access[this.keys[this.index++]];
	}
	,__class__: haxe_iterators_DynamicAccessIterator
};
var haxe_iterators_DynamicAccessKeyValueIterator = function(access) {
	this.access = access;
	this.keys = Reflect.fields(access);
	this.index = 0;
};
$hxClasses["haxe.iterators.DynamicAccessKeyValueIterator"] = haxe_iterators_DynamicAccessKeyValueIterator;
haxe_iterators_DynamicAccessKeyValueIterator.__name__ = "haxe.iterators.DynamicAccessKeyValueIterator";
haxe_iterators_DynamicAccessKeyValueIterator.prototype = {
	access: null
	,keys: null
	,index: null
	,hasNext: function() {
		return this.index < this.keys.length;
	}
	,next: function() {
		var key = this.keys[this.index++];
		return { value : this.access[key], key : key};
	}
	,__class__: haxe_iterators_DynamicAccessKeyValueIterator
};
var haxe_iterators_HashMapKeyValueIterator = function(map) {
	this.map = map;
	this.keys = map.keys.iterator();
};
$hxClasses["haxe.iterators.HashMapKeyValueIterator"] = haxe_iterators_HashMapKeyValueIterator;
haxe_iterators_HashMapKeyValueIterator.__name__ = "haxe.iterators.HashMapKeyValueIterator";
haxe_iterators_HashMapKeyValueIterator.prototype = {
	map: null
	,keys: null
	,hasNext: function() {
		return this.keys.hasNext();
	}
	,next: function() {
		var key = this.keys.next();
		var _this = this.map.values;
		var key1 = key.hashCode();
		return { value : _this.h[key1], key : key};
	}
	,__class__: haxe_iterators_HashMapKeyValueIterator
};
var haxe_iterators_MapKeyValueIterator = function(map) {
	this.map = map;
	this.keys = map.keys();
};
$hxClasses["haxe.iterators.MapKeyValueIterator"] = haxe_iterators_MapKeyValueIterator;
haxe_iterators_MapKeyValueIterator.__name__ = "haxe.iterators.MapKeyValueIterator";
haxe_iterators_MapKeyValueIterator.prototype = {
	map: null
	,keys: null
	,hasNext: function() {
		return this.keys.hasNext();
	}
	,next: function() {
		var key = this.keys.next();
		return { value : this.map.get(key), key : key};
	}
	,__class__: haxe_iterators_MapKeyValueIterator
};
var haxe_iterators_StringIterator = function(s) {
	this.offset = 0;
	this.s = s;
};
$hxClasses["haxe.iterators.StringIterator"] = haxe_iterators_StringIterator;
haxe_iterators_StringIterator.__name__ = "haxe.iterators.StringIterator";
haxe_iterators_StringIterator.prototype = {
	offset: null
	,s: null
	,hasNext: function() {
		return this.offset < this.s.length;
	}
	,next: function() {
		return this.s.charCodeAt(this.offset++);
	}
	,__class__: haxe_iterators_StringIterator
};
var haxe_iterators_StringIteratorUnicode = function(s) {
	this.offset = 0;
	this.s = s;
};
$hxClasses["haxe.iterators.StringIteratorUnicode"] = haxe_iterators_StringIteratorUnicode;
haxe_iterators_StringIteratorUnicode.__name__ = "haxe.iterators.StringIteratorUnicode";
haxe_iterators_StringIteratorUnicode.unicodeIterator = function(s) {
	return new haxe_iterators_StringIteratorUnicode(s);
};
haxe_iterators_StringIteratorUnicode.prototype = {
	offset: null
	,s: null
	,hasNext: function() {
		return this.offset < this.s.length;
	}
	,next: function() {
		var s = this.s;
		var index = this.offset++;
		var c = s.charCodeAt(index);
		if(c >= 55296 && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
		}
		var c1 = c;
		if(c1 >= 65536) {
			this.offset++;
		}
		return c1;
	}
	,__class__: haxe_iterators_StringIteratorUnicode
};
var haxe_iterators_StringKeyValueIterator = function(s) {
	this.offset = 0;
	this.s = s;
};
$hxClasses["haxe.iterators.StringKeyValueIterator"] = haxe_iterators_StringKeyValueIterator;
haxe_iterators_StringKeyValueIterator.__name__ = "haxe.iterators.StringKeyValueIterator";
haxe_iterators_StringKeyValueIterator.prototype = {
	offset: null
	,s: null
	,hasNext: function() {
		return this.offset < this.s.length;
	}
	,next: function() {
		return { key : this.offset, value : this.s.charCodeAt(this.offset++)};
	}
	,__class__: haxe_iterators_StringKeyValueIterator
};
var hxGeomAlgo_Bayazit = $hx_exports["hxGeomAlgo"]["Bayazit"] = function() { };
$hxClasses["hxGeomAlgo.Bayazit"] = hxGeomAlgo_Bayazit;
hxGeomAlgo_Bayazit.__name__ = "hxGeomAlgo.Bayazit";
hxGeomAlgo_Bayazit.poly = null;
hxGeomAlgo_Bayazit.visibility = null;
hxGeomAlgo_Bayazit.reflexVertices = null;
hxGeomAlgo_Bayazit.steinerPoints = null;
hxGeomAlgo_Bayazit.reversed = null;
hxGeomAlgo_Bayazit.decomposePoly = function(simplePoly) {
	var res = [];
	hxGeomAlgo_Bayazit.reflexVertices = [];
	hxGeomAlgo_Bayazit.steinerPoints = [];
	hxGeomAlgo_Bayazit.visibility = new haxe_ds_IntMap();
	if(simplePoly.length < 3) {
		return res;
	}
	hxGeomAlgo_Bayazit.poly = [];
	var _g = 0;
	while(_g < simplePoly.length) {
		var p = simplePoly[_g];
		++_g;
		hxGeomAlgo_Bayazit.poly.push(hxGeomAlgo_HxPoint._new(p.x,p.y));
	}
	hxGeomAlgo_Bayazit.reversed = hxGeomAlgo_PolyTools.makeCW(hxGeomAlgo_Bayazit.poly);
	hxGeomAlgo_Bayazit._decomposePoly(hxGeomAlgo_Bayazit.poly,res);
	return res;
};
hxGeomAlgo_Bayazit._decomposePoly = function(poly,polys) {
	var upperInt = hxGeomAlgo_HxPoint._new();
	var lowerInt = hxGeomAlgo_HxPoint._new();
	var p = hxGeomAlgo_HxPoint._new();
	var closestVert = hxGeomAlgo_HxPoint._new();
	var upperDist = 0;
	var lowerDist = 0;
	var d = 0;
	var closestDist = 0;
	var upperIdx = 0;
	var lowerIdx = 0;
	var closestIdx = 0;
	var upperPoly = [];
	var lowerPoly = [];
	var _g = 0;
	var _g1 = poly.length;
	while(_g < _g1) {
		var i = _g++;
		if(hxGeomAlgo_PolyTools.isReflex(poly,i)) {
			var this1 = hxGeomAlgo_Bayazit.visibility;
			var v = hxGeomAlgo_Visibility.getVisibleIndicesFrom(poly,i);
			this1.h[i] = v;
			hxGeomAlgo_Bayazit.reflexVertices.push(poly[i]);
			lowerDist = Infinity;
			upperDist = lowerDist;
			var _g2 = 0;
			var _g3 = poly.length;
			while(_g2 < _g3) {
				var j = _g2++;
				var tmp;
				var idx = i - 1;
				var idx1 = idx;
				var len = poly.length;
				if(idx1 < 0) {
					idx1 += len;
				}
				idx = idx1 % len;
				var p1 = poly[idx];
				var idx2 = i;
				var idx3 = idx2;
				var len1 = poly.length;
				if(idx3 < 0) {
					idx3 += len1;
				}
				idx2 = idx3 % len1;
				var a = poly[idx2];
				var idx4 = j;
				var idx5 = idx4;
				var len2 = poly.length;
				if(idx5 < 0) {
					idx5 += len2;
				}
				idx4 = idx5 % len2;
				var b = poly[idx4];
				if((a.x - p1.x) * (b.y - p1.y) - (b.x - p1.x) * (a.y - p1.y) > 0) {
					var idx6 = i - 1;
					var idx7 = idx6;
					var len3 = poly.length;
					if(idx7 < 0) {
						idx7 += len3;
					}
					idx6 = idx7 % len3;
					var p2 = poly[idx6];
					var idx8 = i;
					var idx9 = idx8;
					var len4 = poly.length;
					if(idx9 < 0) {
						idx9 += len4;
					}
					idx8 = idx9 % len4;
					var a1 = poly[idx8];
					var idx10 = j - 1;
					var idx11 = idx10;
					var len5 = poly.length;
					if(idx11 < 0) {
						idx11 += len5;
					}
					idx10 = idx11 % len5;
					var b1 = poly[idx10];
					tmp = (a1.x - p2.x) * (b1.y - p2.y) - (b1.x - p2.x) * (a1.y - p2.y) <= 0;
				} else {
					tmp = false;
				}
				if(tmp) {
					var idx12 = i - 1;
					var idx13 = idx12;
					var len6 = poly.length;
					if(idx13 < 0) {
						idx13 += len6;
					}
					idx12 = idx13 % len6;
					var idx14 = i;
					var idx15 = idx14;
					var len7 = poly.length;
					if(idx15 < 0) {
						idx15 += len7;
					}
					idx14 = idx15 % len7;
					var idx16 = j;
					var idx17 = idx16;
					var len8 = poly.length;
					if(idx17 < 0) {
						idx17 += len8;
					}
					idx16 = idx17 % len8;
					var idx18 = j - 1;
					var idx19 = idx18;
					var len9 = poly.length;
					if(idx19 < 0) {
						idx19 += len9;
					}
					idx18 = idx19 % len9;
					p = hxGeomAlgo_PolyTools.intersection(poly[idx12],poly[idx14],poly[idx16],poly[idx18]);
					var idx20 = i + 1;
					var idx21 = idx20;
					var len10 = poly.length;
					if(idx21 < 0) {
						idx21 += len10;
					}
					idx20 = idx21 % len10;
					var p3 = poly[idx20];
					var idx22 = i;
					var idx23 = idx22;
					var len11 = poly.length;
					if(idx23 < 0) {
						idx23 += len11;
					}
					idx22 = idx23 % len11;
					var a2 = poly[idx22];
					if((a2.x - p3.x) * (p.y - p3.y) - (p.x - p3.x) * (a2.y - p3.y) < 0) {
						var v1 = poly[i];
						var x = v1.x - p.x;
						var x1 = v1.y - p.y;
						d = x * x + x1 * x1;
						if(d < lowerDist) {
							lowerDist = d;
							lowerInt = p;
							lowerIdx = j;
						}
					}
				}
				var tmp1;
				var idx24 = i + 1;
				var idx25 = idx24;
				var len12 = poly.length;
				if(idx25 < 0) {
					idx25 += len12;
				}
				idx24 = idx25 % len12;
				var p4 = poly[idx24];
				var idx26 = i;
				var idx27 = idx26;
				var len13 = poly.length;
				if(idx27 < 0) {
					idx27 += len13;
				}
				idx26 = idx27 % len13;
				var a3 = poly[idx26];
				var idx28 = j + 1;
				var idx29 = idx28;
				var len14 = poly.length;
				if(idx29 < 0) {
					idx29 += len14;
				}
				idx28 = idx29 % len14;
				var b2 = poly[idx28];
				if((a3.x - p4.x) * (b2.y - p4.y) - (b2.x - p4.x) * (a3.y - p4.y) > 0) {
					var idx30 = i + 1;
					var idx31 = idx30;
					var len15 = poly.length;
					if(idx31 < 0) {
						idx31 += len15;
					}
					idx30 = idx31 % len15;
					var p5 = poly[idx30];
					var idx32 = i;
					var idx33 = idx32;
					var len16 = poly.length;
					if(idx33 < 0) {
						idx33 += len16;
					}
					idx32 = idx33 % len16;
					var a4 = poly[idx32];
					var idx34 = j;
					var idx35 = idx34;
					var len17 = poly.length;
					if(idx35 < 0) {
						idx35 += len17;
					}
					idx34 = idx35 % len17;
					var b3 = poly[idx34];
					tmp1 = (a4.x - p5.x) * (b3.y - p5.y) - (b3.x - p5.x) * (a4.y - p5.y) <= 0;
				} else {
					tmp1 = false;
				}
				if(tmp1) {
					var idx36 = i + 1;
					var idx37 = idx36;
					var len18 = poly.length;
					if(idx37 < 0) {
						idx37 += len18;
					}
					idx36 = idx37 % len18;
					var idx38 = i;
					var idx39 = idx38;
					var len19 = poly.length;
					if(idx39 < 0) {
						idx39 += len19;
					}
					idx38 = idx39 % len19;
					var idx40 = j;
					var idx41 = idx40;
					var len20 = poly.length;
					if(idx41 < 0) {
						idx41 += len20;
					}
					idx40 = idx41 % len20;
					var idx42 = j + 1;
					var idx43 = idx42;
					var len21 = poly.length;
					if(idx43 < 0) {
						idx43 += len21;
					}
					idx42 = idx43 % len21;
					p = hxGeomAlgo_PolyTools.intersection(poly[idx36],poly[idx38],poly[idx40],poly[idx42]);
					var idx44 = i - 1;
					var idx45 = idx44;
					var len22 = poly.length;
					if(idx45 < 0) {
						idx45 += len22;
					}
					idx44 = idx45 % len22;
					var p6 = poly[idx44];
					var idx46 = i;
					var idx47 = idx46;
					var len23 = poly.length;
					if(idx47 < 0) {
						idx47 += len23;
					}
					idx46 = idx47 % len23;
					var a5 = poly[idx46];
					if((a5.x - p6.x) * (p.y - p6.y) - (p.x - p6.x) * (a5.y - p6.y) > 0) {
						var v2 = poly[i];
						var x2 = v2.x - p.x;
						var x3 = v2.y - p.y;
						d = x2 * x2 + x3 * x3;
						if(d < upperDist) {
							upperDist = d;
							upperInt = p;
							upperIdx = j;
						}
					}
				}
			}
			if(lowerIdx == (upperIdx + 1) % poly.length) {
				p.x = (lowerInt.x + upperInt.x) / 2;
				p.y = (lowerInt.y + upperInt.y) / 2;
				hxGeomAlgo_Bayazit.steinerPoints.push(p);
				if(i < upperIdx) {
					var _g4 = i;
					var _g5 = upperIdx + 1;
					while(_g4 < _g5) {
						var k = _g4++;
						lowerPoly.push(poly[k]);
					}
					lowerPoly.push(p);
					upperPoly.push(p);
					if(lowerIdx != 0) {
						var _g6 = lowerIdx;
						var _g7 = poly.length;
						while(_g6 < _g7) {
							var k1 = _g6++;
							upperPoly.push(poly[k1]);
						}
					}
					var _g8 = 0;
					var _g9 = i + 1;
					while(_g8 < _g9) {
						var k2 = _g8++;
						upperPoly.push(poly[k2]);
					}
				} else {
					if(i != 0) {
						var _g10 = i;
						var _g11 = poly.length;
						while(_g10 < _g11) {
							var k3 = _g10++;
							lowerPoly.push(poly[k3]);
						}
					}
					var _g12 = 0;
					var _g13 = upperIdx + 1;
					while(_g12 < _g13) {
						var k4 = _g12++;
						lowerPoly.push(poly[k4]);
					}
					lowerPoly.push(p);
					upperPoly.push(p);
					var _g14 = lowerIdx;
					var _g15 = i + 1;
					while(_g14 < _g15) {
						var k5 = _g14++;
						upperPoly.push(poly[k5]);
					}
				}
			} else {
				if(lowerIdx > upperIdx) {
					upperIdx += poly.length;
				}
				closestDist = Infinity;
				var _g16 = lowerIdx;
				var _g17 = upperIdx + 1;
				while(_g16 < _g17) {
					var j1 = _g16++;
					var tmp2;
					var idx48 = i - 1;
					var idx49 = idx48;
					var len24 = poly.length;
					if(idx49 < 0) {
						idx49 += len24;
					}
					idx48 = idx49 % len24;
					var p7 = poly[idx48];
					var idx50 = i;
					var idx51 = idx50;
					var len25 = poly.length;
					if(idx51 < 0) {
						idx51 += len25;
					}
					idx50 = idx51 % len25;
					var a6 = poly[idx50];
					var idx52 = j1;
					var idx53 = idx52;
					var len26 = poly.length;
					if(idx53 < 0) {
						idx53 += len26;
					}
					idx52 = idx53 % len26;
					var b4 = poly[idx52];
					if((a6.x - p7.x) * (b4.y - p7.y) - (b4.x - p7.x) * (a6.y - p7.y) >= 0) {
						var idx54 = i + 1;
						var idx55 = idx54;
						var len27 = poly.length;
						if(idx55 < 0) {
							idx55 += len27;
						}
						idx54 = idx55 % len27;
						var p8 = poly[idx54];
						var idx56 = i;
						var idx57 = idx56;
						var len28 = poly.length;
						if(idx57 < 0) {
							idx57 += len28;
						}
						idx56 = idx57 % len28;
						var a7 = poly[idx56];
						var idx58 = j1;
						var idx59 = idx58;
						var len29 = poly.length;
						if(idx59 < 0) {
							idx59 += len29;
						}
						idx58 = idx59 % len29;
						var b5 = poly[idx58];
						tmp2 = (a7.x - p8.x) * (b5.y - p8.y) - (b5.x - p8.x) * (a7.y - p8.y) <= 0;
					} else {
						tmp2 = false;
					}
					if(tmp2) {
						var idx60 = i;
						var idx61 = idx60;
						var len30 = poly.length;
						if(idx61 < 0) {
							idx61 += len30;
						}
						idx60 = idx61 % len30;
						var v3 = poly[idx60];
						var idx62 = j1;
						var idx63 = idx62;
						var len31 = poly.length;
						if(idx63 < 0) {
							idx63 += len31;
						}
						idx62 = idx63 % len31;
						var w = poly[idx62];
						var x4 = v3.x - w.x;
						var x5 = v3.y - w.y;
						d = x4 * x4 + x5 * x5;
						if(d < closestDist) {
							var ijVisible = hxGeomAlgo_Bayazit.visibility.h[i].indexOf(j1 % poly.length) >= 0;
							if(ijVisible) {
								closestDist = d;
								var idx64 = j1;
								var idx65 = idx64;
								var len32 = poly.length;
								if(idx65 < 0) {
									idx65 += len32;
								}
								idx64 = idx65 % len32;
								closestVert = poly[idx64];
								closestIdx = j1 % poly.length;
							}
						}
					}
				}
				if(i < closestIdx) {
					var _g18 = i;
					var _g19 = closestIdx + 1;
					while(_g18 < _g19) {
						var k6 = _g18++;
						lowerPoly.push(poly[k6]);
					}
					if(closestIdx != 0) {
						var _g20 = closestIdx;
						var _g21 = poly.length;
						while(_g20 < _g21) {
							var k7 = _g20++;
							upperPoly.push(poly[k7]);
						}
					}
					var _g22 = 0;
					var _g23 = i + 1;
					while(_g22 < _g23) {
						var k8 = _g22++;
						upperPoly.push(poly[k8]);
					}
				} else {
					if(i != 0) {
						var _g24 = i;
						var _g25 = poly.length;
						while(_g24 < _g25) {
							var k9 = _g24++;
							lowerPoly.push(poly[k9]);
						}
					}
					var _g26 = 0;
					var _g27 = closestIdx + 1;
					while(_g26 < _g27) {
						var k10 = _g26++;
						lowerPoly.push(poly[k10]);
					}
					var _g28 = closestIdx;
					var _g29 = i + 1;
					while(_g28 < _g29) {
						var k11 = _g28++;
						upperPoly.push(poly[k11]);
					}
				}
			}
			if(lowerPoly.length < upperPoly.length) {
				hxGeomAlgo_Bayazit._decomposePoly(lowerPoly,polys);
				hxGeomAlgo_Bayazit._decomposePoly(upperPoly,polys);
			} else {
				hxGeomAlgo_Bayazit._decomposePoly(upperPoly,polys);
				hxGeomAlgo_Bayazit._decomposePoly(lowerPoly,polys);
			}
			return;
		}
	}
	polys.push(poly);
};
var hxGeomAlgo_Connectivity = $hxEnums["hxGeomAlgo.Connectivity"] = { __ename__ : "hxGeomAlgo.Connectivity", __constructs__ : ["FOUR_CONNECTED","EIGHT_CONNECTED"]
	,FOUR_CONNECTED: {_hx_index:0,__enum__:"hxGeomAlgo.Connectivity",toString:$estr}
	,EIGHT_CONNECTED: {_hx_index:1,__enum__:"hxGeomAlgo.Connectivity",toString:$estr}
};
hxGeomAlgo_Connectivity.__empty_constructs__ = [hxGeomAlgo_Connectivity.FOUR_CONNECTED,hxGeomAlgo_Connectivity.EIGHT_CONNECTED];
var hxGeomAlgo_HxPointData = function(x,y) {
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.x = x;
	this.y = y;
};
$hxClasses["hxGeomAlgo.HxPointData"] = hxGeomAlgo_HxPointData;
hxGeomAlgo_HxPointData.__name__ = "hxGeomAlgo.HxPointData";
hxGeomAlgo_HxPointData.prototype = {
	x: null
	,y: null
	,toString: function() {
		return "(" + this.x + ", " + this.y + ")";
	}
	,__class__: hxGeomAlgo_HxPointData
};
var hxGeomAlgo_HxPoint = $hx_exports["hxGeomAlgo"]["HxPoint"] = {};
hxGeomAlgo_HxPoint.__properties__ = {set_y:"set_y",get_y:"get_y",set_x:"set_x",get_x:"get_x"};
hxGeomAlgo_HxPoint.get_x = function(this1) {
	return this1.x;
};
hxGeomAlgo_HxPoint.set_x = function(this1,value) {
	return this1.x = value;
};
hxGeomAlgo_HxPoint.get_y = function(this1) {
	return this1.y;
};
hxGeomAlgo_HxPoint.set_y = function(this1,value) {
	return this1.y = value;
};
hxGeomAlgo_HxPoint._new = function(x,y) {
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	var this1 = new hxGeomAlgo_HxPointData(x,y);
	return this1;
};
hxGeomAlgo_HxPoint.setTo = function(this1,newX,newY) {
	this1.x = newX;
	this1.y = newY;
};
hxGeomAlgo_HxPoint.equals = function(this1,p) {
	if(p != null && this1.x == p.x) {
		return this1.y == p.y;
	} else {
		return false;
	}
};
hxGeomAlgo_HxPoint.clone = function(this1) {
	return hxGeomAlgo_HxPoint._new(this1.x,this1.y);
};
hxGeomAlgo_HxPoint.toString = function(this1) {
	return "(" + this1.x + ", " + this1.y + ")";
};
hxGeomAlgo_HxPoint.fromPointStruct = function(p) {
	return hxGeomAlgo_HxPoint._new(p.x,p.y);
};
hxGeomAlgo_HxPoint.toPointStruct = function(this1) {
	return { x : this1.x, y : this1.y};
};
var hxGeomAlgo_PolyTools = $hx_exports["hxGeomAlgo"]["PolyTools"] = function() { };
$hxClasses["hxGeomAlgo.PolyTools"] = hxGeomAlgo_PolyTools;
hxGeomAlgo_PolyTools.__name__ = "hxGeomAlgo.PolyTools";
hxGeomAlgo_PolyTools.isCCW = function(poly) {
	if(poly.length <= 2) {
		return true;
	}
	var signedArea = 0.;
	var _g = 0;
	var _g1 = poly.length;
	while(_g < _g1) {
		var i = _g++;
		var idx = i - 1;
		var idx1 = idx;
		var len = poly.length;
		if(idx1 < 0) {
			idx1 += len;
		}
		idx = idx1 % len;
		var idx2 = i - 1;
		var idx3 = idx2;
		var len1 = poly.length;
		if(idx3 < 0) {
			idx3 += len1;
		}
		idx2 = idx3 % len1;
		signedArea += poly[idx].x * poly[i].y - poly[i].x * poly[idx2].y;
	}
	return signedArea < 0;
};
hxGeomAlgo_PolyTools.isCW = function(poly) {
	if(poly.length <= 2) {
		return true;
	}
	var signedArea = 0.;
	var _g = 0;
	var _g1 = poly.length;
	while(_g < _g1) {
		var i = _g++;
		var idx = i - 1;
		var idx1 = idx;
		var len = poly.length;
		if(idx1 < 0) {
			idx1 += len;
		}
		idx = idx1 % len;
		var idx2 = i - 1;
		var idx3 = idx2;
		var len1 = poly.length;
		if(idx3 < 0) {
			idx3 += len1;
		}
		idx2 = idx3 % len1;
		signedArea += poly[idx].x * poly[i].y - poly[i].x * poly[idx2].y;
	}
	return signedArea > 0;
};
hxGeomAlgo_PolyTools.makeCCW = function(poly) {
	var reversed = false;
	if(!hxGeomAlgo_PolyTools.isCCW(poly)) {
		poly.reverse();
		reversed = true;
	}
	return reversed;
};
hxGeomAlgo_PolyTools.makeCW = function(poly) {
	var reversed = false;
	if(hxGeomAlgo_PolyTools.isCCW(poly)) {
		poly.reverse();
		reversed = true;
	}
	return reversed;
};
hxGeomAlgo_PolyTools.isConvex = function(poly) {
	var isPositive = null;
	var _g = 0;
	var _g1 = poly.length;
	while(_g < _g1) {
		var i = _g++;
		var lower = i == 0 ? poly.length - 1 : i - 1;
		var middle = i;
		var upper = i == poly.length - 1 ? 0 : i + 1;
		var dx0 = poly[middle].x - poly[lower].x;
		var dy0 = poly[middle].y - poly[lower].y;
		var dx1 = poly[upper].x - poly[middle].x;
		var dy1 = poly[upper].y - poly[middle].y;
		var cross = dx0 * dy1 - dx1 * dy0;
		var newIsPositive = cross > 0;
		if(cross == 0) {
			continue;
		}
		if(isPositive == null) {
			isPositive = newIsPositive;
		} else if(isPositive != newIsPositive) {
			return false;
		}
	}
	return true;
};
hxGeomAlgo_PolyTools.isSimple = function(poly) {
	var len = poly.length;
	if(len <= 3) {
		return true;
	}
	var _g = 0;
	var _g1 = len;
	while(_g < _g1) {
		var i = _g++;
		var p0 = i;
		var p1 = i == len - 1 ? 0 : i + 1;
		var _g2 = i + 1;
		var _g3 = len;
		while(_g2 < _g3) {
			var j = _g2++;
			var q0 = j;
			var q1 = j == len - 1 ? 0 : j + 1;
			var intersection = hxGeomAlgo_PolyTools.segmentIntersect(poly[p0],poly[p1],poly[q0],poly[q1]);
			var tmp;
			var tmp1;
			if(intersection != null) {
				var tmp2;
				var w = poly[p0];
				var x = intersection.x - w.x;
				var x1 = intersection.y - w.y;
				if(!(Math.sqrt(x * x + x1 * x1) < hxGeomAlgo_PolyTools.EPSILON)) {
					var w1 = poly[p1];
					var x2 = intersection.x - w1.x;
					var x3 = intersection.y - w1.y;
					tmp2 = Math.sqrt(x2 * x2 + x3 * x3) < hxGeomAlgo_PolyTools.EPSILON;
				} else {
					tmp2 = true;
				}
				tmp1 = !tmp2;
			} else {
				tmp1 = false;
			}
			if(tmp1) {
				var tmp3;
				var w2 = poly[q0];
				var x4 = intersection.x - w2.x;
				var x5 = intersection.y - w2.y;
				if(!(Math.sqrt(x4 * x4 + x5 * x5) < hxGeomAlgo_PolyTools.EPSILON)) {
					var w3 = poly[q1];
					var x6 = intersection.x - w3.x;
					var x7 = intersection.y - w3.y;
					tmp3 = Math.sqrt(x6 * x6 + x7 * x7) < hxGeomAlgo_PolyTools.EPSILON;
				} else {
					tmp3 = true;
				}
				tmp = !tmp3;
			} else {
				tmp = false;
			}
			if(tmp) {
				return false;
			}
		}
	}
	return true;
};
hxGeomAlgo_PolyTools.segmentIntersect = function(p0,p1,q0,q1) {
	var a1 = p1.y - p0.y;
	var b1 = p0.x - p1.x;
	var c1 = p1.x * p0.y - p0.x * p1.y;
	var a2 = q1.y - q0.y;
	var b2 = q0.x - q1.x;
	var c2 = q1.x * q0.y - q0.x * q1.y;
	var denom = a1 * b2 - a2 * b1;
	if(denom == 0) {
		return null;
	}
	var intersectionPoint = hxGeomAlgo_HxPoint._new();
	intersectionPoint.x = (b1 * c2 - b2 * c1) / denom;
	intersectionPoint.y = (a2 * c1 - a1 * c2) / denom;
	var x = p0.x - p1.x;
	var x1 = p0.y - p1.y;
	var p0p1 = x * x + x1 * x1;
	var x = q0.x - q1.x;
	var x1 = q0.y - q1.y;
	var q0q1 = x * x + x1 * x1;
	var x = intersectionPoint.x - p1.x;
	var x1 = intersectionPoint.y - p1.y;
	if(x * x + x1 * x1 > p0p1) {
		return null;
	}
	var x = intersectionPoint.x - p0.x;
	var x1 = intersectionPoint.y - p0.y;
	if(x * x + x1 * x1 > p0p1) {
		return null;
	}
	var x = intersectionPoint.x - q1.x;
	var x1 = intersectionPoint.y - q1.y;
	if(x * x + x1 * x1 > q0q1) {
		return null;
	}
	var x = intersectionPoint.x - q0.x;
	var x1 = intersectionPoint.y - q0.y;
	if(x * x + x1 * x1 > q0q1) {
		return null;
	}
	return intersectionPoint;
};
hxGeomAlgo_PolyTools.findDuplicatePoints = function(poly,consecutiveOnly,wrapAround) {
	if(wrapAround == null) {
		wrapAround = true;
	}
	if(consecutiveOnly == null) {
		consecutiveOnly = true;
	}
	var len = poly.length;
	if(len <= 1) {
		return [];
	}
	var dupIndices = [];
	var _g = 0;
	var _g1 = len - 1;
	while(_g < _g1) {
		var i = _g++;
		var j = i + 1;
		while(j < len) {
			var this1 = poly[i];
			var p = poly[j];
			var foundDup = p != null && this1.x == p.x && this1.y == p.y;
			if(foundDup) {
				dupIndices.push(i);
			}
			if(consecutiveOnly || foundDup && !consecutiveOnly) {
				break;
			}
			++j;
		}
	}
	var tmp;
	if(wrapAround && consecutiveOnly) {
		var this1 = poly[0];
		var p = poly[len - 1];
		tmp = p != null && this1.x == p.x && this1.y == p.y;
	} else {
		tmp = false;
	}
	if(tmp) {
		dupIndices.push(len - 1);
	}
	return dupIndices;
};
hxGeomAlgo_PolyTools.intersection = function(p1,p2,q1,q2) {
	var res = null;
	var a1 = p2.y - p1.y;
	var b1 = p1.x - p2.x;
	var c1 = a1 * p1.x + b1 * p1.y;
	var a2 = q2.y - q1.y;
	var b2 = q1.x - q2.x;
	var c2 = a2 * q1.x + b2 * q1.y;
	var det = a1 * b2 - a2 * b1;
	if(!(Math.abs(det) <= hxGeomAlgo_PolyTools.EPSILON)) {
		res = hxGeomAlgo_HxPoint._new();
		res.x = (b2 * c1 - b1 * c2) / det;
		res.y = (a1 * c2 - a2 * c1) / det;
	}
	return res;
};
hxGeomAlgo_PolyTools.isReflex = function(poly,idx) {
	var idx1 = idx - 1;
	var idx2 = idx1;
	var len = poly.length;
	if(idx2 < 0) {
		idx2 += len;
	}
	idx1 = idx2 % len;
	var p = poly[idx1];
	var idx1 = idx;
	var idx2 = idx1;
	var len = poly.length;
	if(idx2 < 0) {
		idx2 += len;
	}
	idx1 = idx2 % len;
	var a = poly[idx1];
	var idx1 = idx + 1;
	var idx = idx1;
	var len = poly.length;
	if(idx < 0) {
		idx += len;
	}
	idx1 = idx % len;
	var b = poly[idx1];
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) < 0;
};
hxGeomAlgo_PolyTools.at = function(poly,idx) {
	var idx1 = idx;
	var len = poly.length;
	if(idx1 < 0) {
		idx1 += len;
	}
	idx = idx1 % len;
	return poly[idx];
};
hxGeomAlgo_PolyTools.wrappedIdx = function(poly,idx) {
	var len = poly.length;
	if(idx < 0) {
		idx += len;
	}
	return idx % len;
};
hxGeomAlgo_PolyTools.side = function(p,a,b) {
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y);
};
hxGeomAlgo_PolyTools.isLeft = function(p,a,b) {
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) > 0;
};
hxGeomAlgo_PolyTools.isLeftOrOn = function(p,a,b) {
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) >= 0;
};
hxGeomAlgo_PolyTools.isRight = function(p,a,b) {
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) < 0;
};
hxGeomAlgo_PolyTools.isRightOrOn = function(p,a,b) {
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) <= 0;
};
hxGeomAlgo_PolyTools.isCollinear = function(p,a,b) {
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) == 0;
};
hxGeomAlgo_PolyTools.distance = function(v,w) {
	var x = v.x - w.x;
	var x1 = v.y - w.y;
	return Math.sqrt(x * x + x1 * x1);
};
hxGeomAlgo_PolyTools.distanceToSegment = function(p,v,w) {
	return Math.sqrt(hxGeomAlgo_PolyTools.distanceToSegmentSquared(p,v,w));
};
hxGeomAlgo_PolyTools.distanceSquared = function(v,w) {
	var x = v.x - w.x;
	var x1 = v.y - w.y;
	return x * x + x1 * x1;
};
hxGeomAlgo_PolyTools.distanceToSegmentSquared = function(p,v,w) {
	var x = v.x - w.x;
	var x1 = v.y - w.y;
	var l2 = x * x + x1 * x1;
	if(l2 == 0) {
		var x = p.x - v.x;
		var x1 = p.y - v.y;
		return x * x + x1 * x1;
	}
	var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
	if(t < 0) {
		var x = p.x - v.x;
		var x1 = p.y - v.y;
		return x * x + x1 * x1;
	}
	if(t > 1) {
		var x = p.x - w.x;
		var x1 = p.y - w.y;
		return x * x + x1 * x1;
	}
	var this1 = hxGeomAlgo_PolyTools.point;
	this1.x = v.x + t * (w.x - v.x);
	this1.y = v.y + t * (w.y - v.y);
	var w = hxGeomAlgo_PolyTools.point;
	var x = p.x - w.x;
	var x1 = p.y - w.y;
	return x * x + x1 * x1;
};
hxGeomAlgo_PolyTools.getCentroid = function(poly) {
	var c = hxGeomAlgo_HxPoint._new();
	var area = hxGeomAlgo_PolyTools.getArea(poly);
	if(area != 0) {
		var len = poly.length;
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			var p0 = poly[i];
			var p1 = poly[(i + 1) % len];
			var m = p0.x * p1.y - p1.x * p0.y;
			c.x += (p0.x + p1.x) * m;
			c.y += (p0.y + p1.y) * m;
		}
		c.x /= 6 * area;
		c.y /= 6 * area;
	} else {
		c = hxGeomAlgo_HxPoint.EMPTY;
	}
	return c;
};
hxGeomAlgo_PolyTools.getArea = function(poly) {
	var area = 0.0;
	var len = poly.length;
	var _g = 0;
	var _g1 = len;
	while(_g < _g1) {
		var i = _g++;
		var p0 = poly[i];
		var p1 = poly[(i + 1) % len];
		area += p0.x * p1.y - p1.x * p0.y;
	}
	area = .5 * area;
	return area;
};
hxGeomAlgo_PolyTools.meet = function(p,q) {
	return new hxGeomAlgo_HomogCoord(p.y - q.y,q.x - p.x,p.x * q.y - p.y * q.x);
};
hxGeomAlgo_PolyTools.dot = function(p,q) {
	return p.x * q.x + p.y * q.y;
};
hxGeomAlgo_PolyTools.sqr = function(x) {
	return x * x;
};
hxGeomAlgo_PolyTools.eq = function(a,b) {
	return Math.abs(a - b) <= hxGeomAlgo_PolyTools.EPSILON;
};
hxGeomAlgo_PolyTools.clear = function(array) {
	array.length = 0;
};
hxGeomAlgo_PolyTools.toFloatArray = function(poly,out) {
	if(out == null) {
		out = [];
	}
	var _g = 0;
	while(_g < poly.length) {
		var p = poly[_g];
		++_g;
		out.push(p.x);
		out.push(p.y);
	}
	return out;
};
hxGeomAlgo_PolyTools.reverseFloatArray = function(poly,inPlace) {
	if(inPlace == null) {
		inPlace = false;
	}
	var res = inPlace ? poly : [];
	var nPoints = poly.length >> 1;
	var _g = 0;
	var _g1 = nPoints;
	while(_g < _g1) {
		var i = _g++;
		var xPos = (nPoints - i - 1) * 2;
		res[i * 2] = poly[xPos];
		res[i * 2 + 1] = poly[xPos + 1];
	}
	return res;
};
hxGeomAlgo_PolyTools.flatten = function(array,out) {
	var res = out != null ? out : [];
	var _g = 0;
	while(_g < array.length) {
		var arr = array[_g];
		++_g;
		var _g1 = 0;
		while(_g1 < arr.length) {
			var item = arr[_g1];
			++_g1;
			res.push(item);
		}
	}
	return res;
};
hxGeomAlgo_PolyTools.toPointArray = function(poly,out) {
	if(out == null) {
		out = [];
	}
	var size = poly.length;
	if(poly.length % 2 == 1) {
		--size;
	}
	var _g = 0;
	var _g1 = size >> 1;
	while(_g < _g1) {
		var i = _g++;
		out.push(hxGeomAlgo_HxPoint._new(poly[i * 2],poly[i * 2 + 1]));
	}
	return out;
};
hxGeomAlgo_PolyTools.parsePoints = function(str) {
	var _g = [];
	var _g1 = 0;
	var _g2 = new EReg("[^-eE\\.\\d]+","g").split(str);
	while(_g1 < _g2.length) {
		var v = _g2[_g1];
		++_g1;
		if(v != null && v != "") {
			_g.push(v);
		}
	}
	var _this = _g;
	var f = Std.parseFloat;
	var result = new Array(_this.length);
	var _g = 0;
	var _g1 = _this.length;
	while(_g < _g1) {
		var i = _g++;
		result[i] = f(_this[i]);
	}
	var floats = result;
	var pts = [];
	var n = floats.length;
	var _g = 0;
	var _g1 = n / 2 | 0;
	while(_g < _g1) {
		var i = _g++;
		pts.push(hxGeomAlgo_HxPoint._new(floats[i * 2],floats[i * 2 + 1]));
	}
	return pts;
};
hxGeomAlgo_PolyTools.inflateLine = function(start,end,thickness) {
	var halfWidth = thickness / 2;
	var dx = end.x - start.x;
	var dy = end.y - start.y;
	var len = Math.sqrt(dx * dx + dy * dy);
	var nx = dx / len * halfWidth;
	var ny = dy / len * halfWidth;
	return [hxGeomAlgo_HxPoint._new(start.x - ny,start.y + nx),hxGeomAlgo_HxPoint._new(end.x - ny,end.y + nx),hxGeomAlgo_HxPoint._new(end.x + ny,end.y - nx),hxGeomAlgo_HxPoint._new(start.x + ny,start.y - nx)];
};
hxGeomAlgo_PolyTools.clip = function(subjPoly,clipPoly) {
	var cond = clipPoly.length >= 3 && hxGeomAlgo_PolyTools.isConvex(clipPoly);
	var res = [];
	var output = subjPoly;
	var isInside = hxGeomAlgo_PolyTools.isCCW(clipPoly) ? hxGeomAlgo_PolyTools.isRight : hxGeomAlgo_PolyTools.isLeft;
	var clipEdgeStart;
	var clipEdgeEnd;
	var inputEdgeStart;
	var inputEdgeEnd;
	var clipLen = clipPoly.length;
	var _g = 0;
	var _g1 = clipLen;
	while(_g < _g1) {
		var i = _g++;
		clipEdgeStart = clipPoly[i];
		var idx = i + 1;
		var len = clipPoly.length;
		if(idx < 0) {
			idx += len;
		}
		clipEdgeEnd = clipPoly[idx % len];
		var input = output;
		output = [];
		inputEdgeStart = input[input.length - 1];
		var _g2 = 0;
		var _g3 = input.length;
		while(_g2 < _g3) {
			var j = _g2++;
			inputEdgeEnd = input[j];
			if(isInside(inputEdgeEnd,clipEdgeStart,clipEdgeEnd)) {
				if(!isInside(inputEdgeStart,clipEdgeStart,clipEdgeEnd)) {
					var intersectionPoint = hxGeomAlgo_PolyTools.intersection(inputEdgeStart,inputEdgeEnd,clipEdgeStart,clipEdgeEnd);
					if(intersectionPoint != null) {
						output.push(intersectionPoint);
					}
				}
				output.push(inputEdgeEnd);
			} else if(isInside(inputEdgeStart,clipEdgeStart,clipEdgeEnd)) {
				var intersectionPoint1 = hxGeomAlgo_PolyTools.intersection(inputEdgeStart,inputEdgeEnd,clipEdgeStart,clipEdgeEnd);
				if(intersectionPoint1 != null) {
					output.push(intersectionPoint1);
				}
			}
			inputEdgeStart = inputEdgeEnd;
		}
		res.push(output);
	}
	return res;
};
hxGeomAlgo_PolyTools.lerp = function(a,b,t) {
	return (1.0 - t) * a + t * b;
};
hxGeomAlgo_PolyTools.lerpPoints = function(a,b,t) {
	return hxGeomAlgo_HxPoint._new((1.0 - t) * a.x + t * b.x,(1.0 - t) * a.y + t * b.y);
};
hxGeomAlgo_PolyTools.exposeEnum = function(enumClass,as) {
	var dotPath = (as != null ? as : enumClass.__ename__).split(".");
	var exports = $hx_exports;
	var i = 0;
	while(i < dotPath.length - 1) {
		var currPath = dotPath[i];
		exports[currPath] = exports[currPath] || { };
		exports = exports[currPath];
		++i;
	}
	exports[dotPath[i]] = enumClass;
};
var hxGeomAlgo_CCLabeler = $hx_exports["hxGeomAlgo"]["CCLabeler"] = function(pixels,alphaThreshold,traceContours,connectivity,calcArea) {
	if(calcArea == null) {
		calcArea = false;
	}
	if(traceContours == null) {
		traceContours = true;
	}
	if(alphaThreshold == null) {
		alphaThreshold = 1;
	}
	this.hue = .60;
	this.colors = [];
	this.secondContourPoint = hxGeomAlgo_HxPoint._new();
	this.contourPoint = hxGeomAlgo_HxPoint._new();
	this.labelIndex = 0;
	this.tracingDir = 0;
	this.searchDir = [{ dx : 1, dy : 0},{ dx : 1, dy : 1},{ dx : 0, dy : 1},{ dx : -1, dy : 1},{ dx : -1, dy : 0},{ dx : -1, dy : -1},{ dx : 0, dy : -1},{ dx : 1, dy : -1}];
	this.UNLABELED = 0;
	this.MARKED = -1;
	this.setSource(pixels);
	this.alphaThreshold = alphaThreshold;
	this.connectivity = connectivity != null ? connectivity : hxGeomAlgo_Connectivity.EIGHT_CONNECTED;
	this.traceContours = traceContours;
	this.calcArea = calcArea;
	this.numComponents = 0;
};
$hxClasses["hxGeomAlgo.CCLabeler"] = hxGeomAlgo_CCLabeler;
hxGeomAlgo_CCLabeler.__name__ = "hxGeomAlgo.CCLabeler";
hxGeomAlgo_CCLabeler.prototype = {
	alphaThreshold: null
	,labelMap: null
	,traceContours: null
	,calcArea: null
	,connectivity: null
	,contours: null
	,areaMap: null
	,numComponents: null
	,MARKED: null
	,UNLABELED: null
	,searchDir: null
	,tracingDir: null
	,labelIndex: null
	,contourPoint: null
	,secondContourPoint: null
	,sourcePixels: null
	,markedPixels: null
	,width: null
	,height: null
	,colors: null
	,hue: null
	,setSource: function(pixels) {
		this.sourcePixels = pixels;
		this.width = this.sourcePixels.width;
		this.height = this.sourcePixels.height;
		var this1 = new hxPixels__$Pixels_PixelsData(this.width,this.height,true);
		this.labelMap = this1;
		this.labelMap.format = pixels.format;
		Pixels.fillRect(this.labelMap,0,0,this.width,this.height,this.UNLABELED);
		var this1 = new hxPixels__$Pixels_PixelsData(this.width,this.height,true);
		this.markedPixels = this1;
		this.markedPixels.format = pixels.format;
		Pixels.fillRect(this.markedPixels,0,0,this.width,this.height,0);
	}
	,run: function() {
		this.contours = [];
		this.areaMap = new haxe_ds_IntMap();
		this.numComponents = 0;
		this.labelIndex = 0;
		var isLabeled;
		var leftLabeledPixel;
		var x;
		var y = 0;
		while(y < this.height) {
			x = 0;
			while(x < this.width) {
				isLabeled = this.getPixel32(this.labelMap,x,y,this.UNLABELED) != this.UNLABELED;
				if(this.isPixelSolid(x,y)) {
					if(!isLabeled && !this.isPixelSolid(x,y - 1)) {
						this.setLabel(x,y,this.labelToColor(this.labelIndex));
						isLabeled = true;
						this.contourTrace(x,y,this.labelToColor(this.labelIndex),7);
						this.labelIndex++;
					}
					if(!this.isPixelSolid(x,y + 1) && this.getPixel32(this.markedPixels,x,y + 1,this.MARKED) != this.MARKED) {
						if(!isLabeled) {
							leftLabeledPixel = this.getPixel32(this.labelMap,x - 1,y);
							this.setLabel(x,y,leftLabeledPixel);
							isLabeled = true;
						}
						this.contourTrace(x,y,this.getPixel32(this.labelMap,x,y),3);
					}
					if(!isLabeled) {
						leftLabeledPixel = this.getPixel32(this.labelMap,x - 1,y);
						this.setLabel(x,y,leftLabeledPixel);
					}
				}
				++x;
			}
			++y;
		}
		this.numComponents = this.labelIndex;
		return this.labelMap;
	}
	,contourTrace: function(x,y,labelColor,dir) {
		var startX = x;
		var startY = y;
		var poly = null;
		var nextPointExists;
		if(this.traceContours) {
			poly = [];
			poly.push(hxGeomAlgo_HxPoint._new(x,y));
			this.contours.push(poly);
		}
		var this1 = this.contourPoint;
		this1.x = x;
		this1.y = y;
		this.tracingDir = dir;
		var firstPoint = true;
		while(true) {
			nextPointExists = this.nextOnContour(x,y,this.contourPoint);
			if(firstPoint) {
				var this1 = this.secondContourPoint;
				this1.x = this.contourPoint.x;
				this1.y = this.contourPoint.y;
				firstPoint = false;
			}
			if(nextPointExists) {
				this.tracingDir = (this.tracingDir + 6) % 8;
				x = this.contourPoint.x | 0;
				y = this.contourPoint.y | 0;
				if(x == startX && y == startY) {
					this.nextOnContour(x,y,this.contourPoint);
					if(this.contourPoint.x == this.secondContourPoint.x && this.contourPoint.y == this.secondContourPoint.y) {
						break;
					}
				} else {
					if(this.traceContours) {
						var this2 = this.contourPoint;
						poly.push(hxGeomAlgo_HxPoint._new(this2.x,this2.y));
					}
					this.setLabel(x,y,labelColor);
				}
			} else {
				break;
			}
		}
	}
	,nextOnContour: function(x,y,nextPoint) {
		var isolatedPixel = true;
		var cx;
		var cy;
		var numSteps = 8;
		var step = 1;
		if(this.connectivity == hxGeomAlgo_Connectivity.FOUR_CONNECTED) {
			if((this.tracingDir & 1) == 1) {
				this.tracingDir = (this.tracingDir + 1) % 8;
			}
			numSteps = 4;
			step = 2;
		}
		var dir = this.tracingDir;
		var _g = 0;
		var _g1 = numSteps;
		while(_g < _g1) {
			var i = _g++;
			cx = x + this.searchDir[this.tracingDir].dx;
			cy = y + this.searchDir[this.tracingDir].dy;
			nextPoint.x = cx;
			nextPoint.y = cy;
			if(this.isPixelSolid(cx,cy)) {
				isolatedPixel = false;
				break;
			} else {
				this.setPixel32(this.markedPixels,cx,cy,this.MARKED);
			}
			this.tracingDir = (this.tracingDir + step) % 8;
		}
		return !isolatedPixel;
	}
	,labelToColor: function(label) {
		if(label >= this.colors.length) {
			this.colors[label] = -16777216 | this.getColorFromHSV(this.hue,.9,1);
			this.hue = (this.hue + .12) % 1.0;
		}
		return this.colors[label];
	}
	,setLabel: function(x,y,labelColor) {
		this.setPixel32(this.labelMap,x,y,labelColor);
	}
	,getPixel32: function(pixels,x,y,outerValue) {
		if(outerValue == null) {
			outerValue = 0;
		}
		var res = outerValue;
		if(!(x < 0 || y < 0 || x >= this.width || y >= this.height)) {
			var pos = y * pixels.width + x << 2;
			var a = pixels.bytes.b[pos + pixels.format.ch0] << 24;
			var r = pixels.bytes.b[pos + pixels.format.ch1] << 16;
			var g = pixels.bytes.b[pos + pixels.format.ch2] << 8;
			var b = pixels.bytes.b[pos + pixels.format.ch3];
			res = a | r | g | b;
		}
		return res;
	}
	,setPixel32: function(pixels,x,y,color) {
		if(!(x < 0 || y < 0 || x >= this.width || y >= this.height)) {
			var pos = y * pixels.width + x << 2;
			var a = color >> 24 & 255;
			var r = color >> 16 & 255;
			var g = color >> 8 & 255;
			var b = color & 255;
			pixels.bytes.b[pos + pixels.format.ch0] = a;
			pixels.bytes.b[pos + pixels.format.ch1] = r;
			pixels.bytes.b[pos + pixels.format.ch2] = g;
			pixels.bytes.b[pos + pixels.format.ch3] = b;
			if(this.calcArea && pixels == this.labelMap) {
				var a = this.areaMap.h.hasOwnProperty(color) ? this.areaMap.h[color] : 0;
				this.areaMap.h[color] = a + 1;
			}
		}
	}
	,isPixelSolid: function(x,y) {
		if(!(x < 0 || y < 0 || x >= this.width || y >= this.height)) {
			var this1 = this.sourcePixels;
			var i = y * this.width + x << 2;
			return this1.bytes.b[(i & -4) + this1.format.channelMap[i & 3]] >= this.alphaThreshold;
		} else {
			return false;
		}
	}
	,isOutOfBounds: function(x,y) {
		if(!(x < 0 || y < 0 || x >= this.width)) {
			return y >= this.height;
		} else {
			return true;
		}
	}
	,getColorFromHSV: function(h,s,v) {
		h = h * 360 | 0;
		var hi = Math.floor(h / 60) % 6;
		var f = h / 60 - Math.floor(h / 60);
		var p = v * (1 - s);
		var q = v * (1 - f * s);
		var t = v * (1 - (1 - f) * s);
		switch(hi) {
		case 0:
			return (v * 255 | 0) << 16 | (t * 255 | 0) << 8 | (p * 255 | 0);
		case 1:
			return (q * 255 | 0) << 16 | (v * 255 | 0) << 8 | (p * 255 | 0);
		case 2:
			return (p * 255 | 0) << 16 | (v * 255 | 0) << 8 | (t * 255 | 0);
		case 3:
			return (p * 255 | 0) << 16 | (q * 255 | 0) << 8 | (v * 255 | 0);
		case 4:
			return (t * 255 | 0) << 16 | (p * 255 | 0) << 8 | (v * 255 | 0);
		case 5:
			return (v * 255 | 0) << 16 | (p * 255 | 0) << 8 | (q * 255 | 0);
		default:
			return 0;
		}
	}
	,__class__: hxGeomAlgo_CCLabeler
};
var hxGeomAlgo_Chaikin = $hx_exports["hxGeomAlgo"]["Chaikin"] = function() { };
$hxClasses["hxGeomAlgo.Chaikin"] = hxGeomAlgo_Chaikin;
hxGeomAlgo_Chaikin.__name__ = "hxGeomAlgo.Chaikin";
hxGeomAlgo_Chaikin.smooth = function(poly,iterations,close,ratio) {
	if(ratio == null) {
		ratio = .25;
	}
	if(close == null) {
		close = false;
	}
	if(iterations == null) {
		iterations = 3;
	}
	var smoothedPoints = hxGeomAlgo_Chaikin._smooth(poly,iterations,close,ratio);
	if(!close && smoothedPoints.length > 2) {
		smoothedPoints[0] = poly[0];
		smoothedPoints[smoothedPoints.length - 1] = poly[poly.length - 1];
	}
	return smoothedPoints;
};
hxGeomAlgo_Chaikin.cut = function(a,b,ratio,newAB) {
	newAB[0] = hxGeomAlgo_HxPoint._new((1.0 - ratio) * a.x + ratio * b.x,(1.0 - ratio) * a.y + ratio * b.y);
	newAB[1] = hxGeomAlgo_HxPoint._new((1.0 - ratio) * b.x + ratio * a.x,(1.0 - ratio) * b.y + ratio * a.y);
};
hxGeomAlgo_Chaikin._smooth = function(poly,iterations,close,ratio) {
	if(iterations <= 0 || poly.length <= 2) {
		return poly.slice();
	}
	var smoothedPoints = [];
	var newAB = [];
	newAB.length = 2;
	if(ratio > 0.5) {
		ratio = 1.0 - ratio;
	}
	var numCorners = poly.length;
	if(!close) {
		--numCorners;
	}
	var _g = 0;
	var _g1 = numCorners;
	while(_g < _g1) {
		var i = _g++;
		var idx = i;
		var idx1 = idx;
		var len = poly.length;
		if(idx1 < 0) {
			idx1 += len;
		}
		idx = idx1 % len;
		var a = poly[idx];
		var idx2 = i + 1;
		var idx3 = idx2;
		var len1 = poly.length;
		if(idx3 < 0) {
			idx3 += len1;
		}
		idx2 = idx3 % len1;
		var b = poly[idx2];
		newAB[0] = hxGeomAlgo_HxPoint._new((1.0 - ratio) * a.x + ratio * b.x,(1.0 - ratio) * a.y + ratio * b.y);
		newAB[1] = hxGeomAlgo_HxPoint._new((1.0 - ratio) * b.x + ratio * a.x,(1.0 - ratio) * b.y + ratio * a.y);
		smoothedPoints.push(newAB[0]);
		smoothedPoints.push(newAB[1]);
	}
	return hxGeomAlgo_Chaikin._smooth(smoothedPoints,iterations - 1,close,ratio);
};
var hxGeomAlgo_Debug = function() { };
$hxClasses["hxGeomAlgo.Debug"] = hxGeomAlgo_Debug;
hxGeomAlgo_Debug.__name__ = "hxGeomAlgo.Debug";
hxGeomAlgo_Debug.assert = function(cond,message,pos) {
	return;
};
var hxGeomAlgo_EarCut = $hx_exports["hxGeomAlgo"]["EarCut"] = function() { };
$hxClasses["hxGeomAlgo.EarCut"] = hxGeomAlgo_EarCut;
hxGeomAlgo_EarCut.__name__ = "hxGeomAlgo.EarCut";
hxGeomAlgo_EarCut.triangulate = function(poly,holes) {
	var data = hxGeomAlgo_PolyTools.toFloatArray(poly);
	var holeIndices = null;
	var allVertices = poly;
	if(holes != null && holes.length > 0) {
		allVertices = poly.concat([]);
		hxGeomAlgo_PolyTools.flatten(holes,allVertices);
		holeIndices = [];
		var holeIdx = poly.length;
		var _g = 0;
		while(_g < holes.length) {
			var hole = holes[_g];
			++_g;
			var _g1 = 0;
			var _g2 = hxGeomAlgo_PolyTools.toFloatArray(hole);
			while(_g1 < _g2.length) {
				var f = _g2[_g1];
				++_g1;
				data.push(f);
			}
			holeIndices.push(holeIdx);
			holeIdx += hole.length;
		}
	}
	var triIndices = hxGeomAlgo_EarCut.earcut(data,holeIndices);
	var res = [];
	var i = 0;
	while(i < triIndices.length) {
		var tri = [allVertices[triIndices[i]],allVertices[triIndices[i + 1]],allVertices[triIndices[i + 2]]];
		res.push(tri);
		i += 3;
	}
	return res;
};
hxGeomAlgo_EarCut.earcut = function(data,holeIndices,dim) {
	if(dim == null) {
		dim = 2;
	}
	var hasHoles = holeIndices != null && holeIndices.length > 0;
	var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
	var outerNode = hxGeomAlgo_EarCut.linkedList(data,0,outerLen,dim,true);
	var triangles = [];
	if(outerNode == null) {
		return triangles;
	}
	outerNode = hxGeomAlgo_EarCut.filterPoints(outerNode);
	var size = NaN;
	var y = size;
	var x = y;
	var maxY = x;
	var maxX = maxY;
	var minY = maxX;
	var minX = minY;
	if(hasHoles) {
		outerNode = hxGeomAlgo_EarCut.eliminateHoles(data,holeIndices,outerNode,dim);
	}
	if(data.length > 80 * dim) {
		maxX = data[0];
		minX = maxX;
		maxY = data[1];
		minY = maxY;
		var i = dim;
		while(i < outerLen) {
			x = data[i];
			y = data[i + 1];
			if(x < minX) {
				minX = x;
			}
			if(y < minY) {
				minY = y;
			}
			if(x > maxX) {
				maxX = x;
			}
			if(y > maxY) {
				maxY = y;
			}
			i += dim;
		}
		size = Math.max(maxX - minX,maxY - minY);
	}
	hxGeomAlgo_EarCut.earcutLinked(outerNode,triangles,dim,minX,minY,size);
	return triangles;
};
hxGeomAlgo_EarCut.linkedList = function(data,start,end,dim,clockwise) {
	var i;
	var last = null;
	if(clockwise == hxGeomAlgo_EarCut.signedArea(data,start,end,dim) > 0) {
		i = start;
		while(i < end) {
			last = hxGeomAlgo_EarCut.insertNode(i,data[i],data[i + 1],last);
			i += dim;
		}
	} else {
		i = end - dim;
		while(i >= start) {
			last = hxGeomAlgo_EarCut.insertNode(i,data[i],data[i + 1],last);
			i -= dim;
		}
	}
	var tmp;
	if(last != null) {
		var p2 = last.next;
		tmp = last.x == p2.x && last.y == p2.y;
	} else {
		tmp = false;
	}
	if(tmp) {
		hxGeomAlgo_EarCut.removeNode(last);
		last = last.next;
	}
	return last;
};
hxGeomAlgo_EarCut.filterPoints = function(start,end) {
	if(start == null) {
		return start;
	}
	if(end == null) {
		end = start;
	}
	var p = start;
	var again;
	while(true) {
		again = false;
		var tmp;
		if(!p.steiner) {
			var p2 = p.next;
			if(!(p.x == p2.x && p.y == p2.y)) {
				var p1 = p.prev;
				var r = p.next;
				tmp = (p.y - p1.y) * (r.x - p.x) - (p.x - p1.x) * (r.y - p.y) == 0;
			} else {
				tmp = true;
			}
		} else {
			tmp = false;
		}
		if(tmp) {
			hxGeomAlgo_EarCut.removeNode(p);
			end = p.prev;
			p = end;
			if(p == p.next) {
				return null;
			}
			again = true;
		} else {
			p = p.next;
		}
		if(!(again || p != end)) {
			break;
		}
	}
	return end;
};
hxGeomAlgo_EarCut.earcutLinked = function(ear,triangles,dim,minX,minY,size,pass) {
	if(pass == null) {
		pass = 0;
	}
	if(ear == null) {
		return;
	}
	if(pass == 0 && !isNaN(size)) {
		hxGeomAlgo_EarCut.indexCurve(ear,minX,minY,size);
	}
	var stop = ear;
	var prev;
	var next;
	while(ear.prev != ear.next) {
		prev = ear.prev;
		next = ear.next;
		if(!isNaN(size) ? hxGeomAlgo_EarCut.isEarHashed(ear,minX,minY,size) : hxGeomAlgo_EarCut.isEar(ear)) {
			triangles.push(prev.i / dim | 0);
			triangles.push(ear.i / dim | 0);
			triangles.push(next.i / dim | 0);
			hxGeomAlgo_EarCut.removeNode(ear);
			ear = next.next;
			stop = next.next;
			continue;
		}
		ear = next;
		if(ear == stop) {
			if(pass == 0) {
				hxGeomAlgo_EarCut.earcutLinked(hxGeomAlgo_EarCut.filterPoints(ear),triangles,dim,minX,minY,size,1);
			} else if(pass == 1) {
				ear = hxGeomAlgo_EarCut.cureLocalIntersections(ear,triangles,dim);
				hxGeomAlgo_EarCut.earcutLinked(ear,triangles,dim,minX,minY,size,2);
			} else if(pass == 2) {
				hxGeomAlgo_EarCut.splitEarcut(ear,triangles,dim,minX,minY,size);
			}
			break;
		}
	}
};
hxGeomAlgo_EarCut.isEar = function(ear) {
	var a = ear.prev;
	var b = ear;
	var c = ear.next;
	if((b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y) >= 0) {
		return false;
	}
	var p = ear.next.next;
	while(p != ear.prev) {
		var tmp;
		if(hxGeomAlgo_EarCut.pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)) {
			var p1 = p.prev;
			var r = p.next;
			tmp = (p.y - p1.y) * (r.x - p.x) - (p.x - p1.x) * (r.y - p.y) >= 0;
		} else {
			tmp = false;
		}
		if(tmp) {
			return false;
		}
		p = p.next;
	}
	return true;
};
hxGeomAlgo_EarCut.isEarHashed = function(ear,minX,minY,size) {
	var a = ear.prev;
	var b = ear;
	var c = ear.next;
	if((b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y) >= 0) {
		return false;
	}
	var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x;
	var minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y;
	var maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x;
	var maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
	var minZ = hxGeomAlgo_EarCut.zOrder(minTX,minTY,minX,minY,size);
	var maxZ = hxGeomAlgo_EarCut.zOrder(maxTX,maxTY,minX,minY,size);
	var p = ear.nextZ;
	while(p != null && p.z <= maxZ) {
		var tmp;
		if(p != ear.prev && p != ear.next && hxGeomAlgo_EarCut.pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)) {
			var p1 = p.prev;
			var r = p.next;
			tmp = (p.y - p1.y) * (r.x - p.x) - (p.x - p1.x) * (r.y - p.y) >= 0;
		} else {
			tmp = false;
		}
		if(tmp) {
			return false;
		}
		p = p.nextZ;
	}
	p = ear.prevZ;
	while(p != null && p.z >= minZ) {
		var tmp;
		if(p != ear.prev && p != ear.next && hxGeomAlgo_EarCut.pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)) {
			var p1 = p.prev;
			var r = p.next;
			tmp = (p.y - p1.y) * (r.x - p.x) - (p.x - p1.x) * (r.y - p.y) >= 0;
		} else {
			tmp = false;
		}
		if(tmp) {
			return false;
		}
		p = p.prevZ;
	}
	return true;
};
hxGeomAlgo_EarCut.cureLocalIntersections = function(start,triangles,dim) {
	var p = start;
	while(true) {
		var a = p.prev;
		var b = p.next.next;
		if(!(a.x == b.x && a.y == b.y) && hxGeomAlgo_EarCut.intersects(a,p,p.next,b) && hxGeomAlgo_EarCut.locallyInside(a,b) && hxGeomAlgo_EarCut.locallyInside(b,a)) {
			triangles.push(a.i / dim | 0);
			triangles.push(p.i / dim | 0);
			triangles.push(b.i / dim | 0);
			hxGeomAlgo_EarCut.removeNode(p);
			hxGeomAlgo_EarCut.removeNode(p.next);
			start = b;
			p = start;
		}
		p = p.next;
		if(!(p != start)) {
			break;
		}
	}
	return p;
};
hxGeomAlgo_EarCut.splitEarcut = function(start,triangles,dim,minX,minY,size) {
	var a = start;
	while(true) {
		var b = a.next.next;
		while(b != a.prev) {
			if(a.i != b.i && hxGeomAlgo_EarCut.isValidDiagonal(a,b)) {
				var c = hxGeomAlgo_EarCut.splitPolygon(a,b);
				a = hxGeomAlgo_EarCut.filterPoints(a,a.next);
				c = hxGeomAlgo_EarCut.filterPoints(c,c.next);
				hxGeomAlgo_EarCut.earcutLinked(a,triangles,dim,minX,minY,size);
				hxGeomAlgo_EarCut.earcutLinked(c,triangles,dim,minX,minY,size);
				return;
			}
			b = b.next;
		}
		a = a.next;
		if(!(a != start)) {
			break;
		}
	}
};
hxGeomAlgo_EarCut.eliminateHoles = function(data,holeIndices,outerNode,dim) {
	var queue = [];
	var start;
	var end;
	var list;
	var i = 0;
	var len = holeIndices.length;
	while(i < len) {
		start = holeIndices[i] * dim;
		end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
		list = hxGeomAlgo_EarCut.linkedList(data,start,end,dim,false);
		if(list == list.next) {
			list.steiner = true;
		}
		queue.push(hxGeomAlgo_EarCut.getLeftmost(list));
		++i;
	}
	haxe_ds_ArraySort.sort(queue,hxGeomAlgo_EarCut.compareX);
	var _g = 0;
	var _g1 = queue.length;
	while(_g < _g1) {
		var i = _g++;
		hxGeomAlgo_EarCut.eliminateHole(queue[i],outerNode);
		outerNode = hxGeomAlgo_EarCut.filterPoints(outerNode,outerNode.next);
	}
	return outerNode;
};
hxGeomAlgo_EarCut.compareX = function(a,b) {
	return a.x - b.x | 0;
};
hxGeomAlgo_EarCut.eliminateHole = function(hole,outerNode) {
	outerNode = hxGeomAlgo_EarCut.findHoleBridge(hole,outerNode);
	if(outerNode != null) {
		var b = hxGeomAlgo_EarCut.splitPolygon(outerNode,hole);
		hxGeomAlgo_EarCut.filterPoints(b,b.next);
	}
};
hxGeomAlgo_EarCut.findHoleBridge = function(hole,outerNode) {
	var p = outerNode;
	var hx = hole.x;
	var hy = hole.y;
	var qx = -Infinity;
	var m = null;
	while(true) {
		if(hy <= p.y && hy >= p.next.y) {
			var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
			if(x <= hx && x > qx) {
				qx = x;
				if(x == hx) {
					if(hy == p.y) {
						return p;
					}
					if(hy == p.next.y) {
						return p.next;
					}
				}
				m = p.x < p.next.x ? p : p.next;
			}
		}
		p = p.next;
		if(!(p != outerNode)) {
			break;
		}
	}
	if(m == null) {
		return null;
	}
	if(hx == qx) {
		return m.prev;
	}
	var stop = m;
	var mx = m.x;
	var my = m.y;
	var tanMin = Infinity;
	var tan;
	p = m.next;
	while(p != stop) {
		if(hx >= p.x && p.x >= mx && hxGeomAlgo_EarCut.pointInTriangle(hy < my ? hx : qx,hy,mx,my,hy < my ? qx : hx,hy,p.x,p.y)) {
			tan = Math.abs(hy - p.y) / (hx - p.x);
			if((tan < tanMin || tan == tanMin && p.x > m.x) && hxGeomAlgo_EarCut.locallyInside(p,hole)) {
				m = p;
				tanMin = tan;
			}
		}
		p = p.next;
	}
	return m;
};
hxGeomAlgo_EarCut.indexCurve = function(start,minX,minY,size) {
	var p = start;
	while(true) {
		if(p.z == null) {
			p.z = hxGeomAlgo_EarCut.zOrder(p.x,p.y,minX,minY,size);
		}
		p.prevZ = p.prev;
		p.nextZ = p.next;
		p = p.next;
		if(!(p != start)) {
			break;
		}
	}
	p.prevZ.nextZ = null;
	p.prevZ = null;
	hxGeomAlgo_EarCut.sortLinked(p);
};
hxGeomAlgo_EarCut.sortLinked = function(list) {
	var i;
	var p = null;
	var q = null;
	var e = null;
	var tail = null;
	var numMerges;
	var pSize;
	var qSize;
	var inSize = 1;
	while(true) {
		p = list;
		list = null;
		tail = null;
		numMerges = 0;
		while(p != null) {
			++numMerges;
			q = p;
			pSize = 0;
			var _g = 0;
			var _g1 = inSize;
			while(_g < _g1) {
				var i = _g++;
				++pSize;
				q = q.nextZ;
				if(q == null) {
					break;
				}
			}
			qSize = inSize;
			while(pSize > 0 || qSize > 0 && q != null) {
				if(pSize == 0) {
					e = q;
					q = q.nextZ;
					--qSize;
				} else if(qSize == 0 || q == null) {
					e = p;
					p = p.nextZ;
					--pSize;
				} else if(p.z <= q.z) {
					e = p;
					p = p.nextZ;
					--pSize;
				} else {
					e = q;
					q = q.nextZ;
					--qSize;
				}
				if(tail != null) {
					tail.nextZ = e;
				} else {
					list = e;
				}
				e.prevZ = tail;
				tail = e;
			}
			p = q;
		}
		tail.nextZ = null;
		inSize *= 2;
		if(!(numMerges > 1)) {
			break;
		}
	}
	return list;
};
hxGeomAlgo_EarCut.zOrder = function(x,y,minX,minY,size) {
	var _x = 32767 * (x - minX) / size | 0;
	var _y = 32767 * (y - minY) / size | 0;
	_x = (_x | _x << 8) & 16711935;
	_x = (_x | _x << 4) & 252645135;
	_x = (_x | _x << 2) & 858993459;
	_x = (_x | _x << 1) & 1431655765;
	_y = (_y | _y << 8) & 16711935;
	_y = (_y | _y << 4) & 252645135;
	_y = (_y | _y << 2) & 858993459;
	_y = (_y | _y << 1) & 1431655765;
	return _x | _y << 1;
};
hxGeomAlgo_EarCut.getLeftmost = function(start) {
	var p = start;
	var leftmost = start;
	while(true) {
		if(p.x < leftmost.x) {
			leftmost = p;
		}
		p = p.next;
		if(!(p != start)) {
			break;
		}
	}
	return leftmost;
};
hxGeomAlgo_EarCut.pointInTriangle = function(ax,ay,bx,by,cx,cy,px,py) {
	if((cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0) {
		return (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
	} else {
		return false;
	}
};
hxGeomAlgo_EarCut.isValidDiagonal = function(a,b) {
	if(a.next.i != b.i && a.prev.i != b.i && !hxGeomAlgo_EarCut.intersectsPolygon(a,b) && hxGeomAlgo_EarCut.locallyInside(a,b) && hxGeomAlgo_EarCut.locallyInside(b,a)) {
		return hxGeomAlgo_EarCut.middleInside(a,b);
	} else {
		return false;
	}
};
hxGeomAlgo_EarCut.area = function(p,q,r) {
	return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
};
hxGeomAlgo_EarCut.equals = function(p1,p2) {
	if(p1.x == p2.x) {
		return p1.y == p2.y;
	} else {
		return false;
	}
};
hxGeomAlgo_EarCut.intersects = function(p1,q1,p2,q2) {
	if(p1.x == q1.x && p1.y == q1.y && (p2.x == q2.x && p2.y == q2.y) || p1.x == q2.x && p1.y == q2.y && (p2.x == q1.x && p2.y == q1.y)) {
		return true;
	}
	if((q1.y - p1.y) * (p2.x - q1.x) - (q1.x - p1.x) * (p2.y - q1.y) > 0 != (q1.y - p1.y) * (q2.x - q1.x) - (q1.x - p1.x) * (q2.y - q1.y) > 0) {
		return (q2.y - p2.y) * (p1.x - q2.x) - (q2.x - p2.x) * (p1.y - q2.y) > 0 != (q2.y - p2.y) * (q1.x - q2.x) - (q2.x - p2.x) * (q1.y - q2.y) > 0;
	} else {
		return false;
	}
};
hxGeomAlgo_EarCut.intersectsPolygon = function(a,b) {
	var p = a;
	while(true) {
		if(p.i != a.i && p.next.i != a.i && p.i != b.i && p.next.i != b.i && hxGeomAlgo_EarCut.intersects(p,p.next,a,b)) {
			return true;
		}
		p = p.next;
		if(!(p != a)) {
			break;
		}
	}
	return false;
};
hxGeomAlgo_EarCut.locallyInside = function(a,b) {
	var p = a.prev;
	var r = a.next;
	if((a.y - p.y) * (r.x - a.x) - (a.x - p.x) * (r.y - a.y) < 0) {
		var r = a.next;
		if((b.y - a.y) * (r.x - b.x) - (b.x - a.x) * (r.y - b.y) >= 0) {
			var q = a.prev;
			return (q.y - a.y) * (b.x - q.x) - (q.x - a.x) * (b.y - q.y) >= 0;
		} else {
			return false;
		}
	} else {
		var r = a.prev;
		if(!((b.y - a.y) * (r.x - b.x) - (b.x - a.x) * (r.y - b.y) < 0)) {
			var q = a.next;
			return (q.y - a.y) * (b.x - q.x) - (q.x - a.x) * (b.y - q.y) < 0;
		} else {
			return true;
		}
	}
};
hxGeomAlgo_EarCut.middleInside = function(a,b) {
	var p = a;
	var inside = false;
	var px = (a.x + b.x) / 2;
	var py = (a.y + b.y) / 2;
	while(true) {
		if(p.y > py != p.next.y > py && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) {
			inside = !inside;
		}
		p = p.next;
		if(!(p != a)) {
			break;
		}
	}
	return inside;
};
hxGeomAlgo_EarCut.splitPolygon = function(a,b) {
	var a2 = new hxGeomAlgo_EarNode(a.i,a.x,a.y);
	var b2 = new hxGeomAlgo_EarNode(b.i,b.x,b.y);
	var an = a.next;
	var bp = b.prev;
	a.next = b;
	b.prev = a;
	a2.next = an;
	an.prev = a2;
	b2.next = a2;
	a2.prev = b2;
	bp.next = b2;
	b2.prev = bp;
	return b2;
};
hxGeomAlgo_EarCut.insertNode = function(i,x,y,last) {
	var p = new hxGeomAlgo_EarNode(i,x,y);
	if(last == null) {
		p.prev = p;
		p.next = p;
	} else {
		p.next = last.next;
		p.prev = last;
		last.next.prev = p;
		last.next = p;
	}
	return p;
};
hxGeomAlgo_EarCut.removeNode = function(p) {
	p.next.prev = p.prev;
	p.prev.next = p.next;
	if(p.prevZ != null) {
		p.prevZ.nextZ = p.nextZ;
	}
	if(p.nextZ != null) {
		p.nextZ.prevZ = p.prevZ;
	}
};
hxGeomAlgo_EarCut.deviation = function(data,holeIndices,dim,triangles) {
	var hasHoles = holeIndices != null && holeIndices.length > 0;
	var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
	var polygonArea = Math.abs(hxGeomAlgo_EarCut.signedArea(data,0,outerLen,dim));
	if(hasHoles) {
		var i = 0;
		var len = holeIndices.length;
		while(i < len) {
			var start = holeIndices[i] * dim;
			var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
			polygonArea -= Math.abs(hxGeomAlgo_EarCut.signedArea(data,start,end,dim));
			++i;
		}
	}
	var trianglesArea = 0.;
	var i = 0;
	while(i < triangles.length) {
		var a = triangles[i] * dim;
		var b = triangles[i + 1] * dim;
		var c = triangles[i + 2] * dim;
		trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
		i += 3;
	}
	if(polygonArea == 0 && trianglesArea == 0) {
		return 0;
	} else {
		return Math.abs((trianglesArea - polygonArea) / polygonArea);
	}
};
hxGeomAlgo_EarCut.signedArea = function(data,start,end,dim) {
	var sum = 0.;
	var i = start;
	var j = end - dim;
	while(i < end) {
		sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
		j = i;
		i += dim;
	}
	return sum;
};
hxGeomAlgo_EarCut.flatten = function(data) {
	var dim = data[0][0].length;
	var result = { vertices : [], holes : [], dimensions : dim};
	var holeIndex = 0;
	var _g = 0;
	var _g1 = data.length;
	while(_g < _g1) {
		var i = _g++;
		var _g2 = 0;
		var _g3 = data[i].length;
		while(_g2 < _g3) {
			var j = _g2++;
			var _g4 = 0;
			var _g5 = dim;
			while(_g4 < _g5) {
				var d = _g4++;
				result.vertices.push(data[i][j][d]);
			}
		}
		if(i > 0) {
			holeIndex += data[i - 1].length;
			result.holes.push(holeIndex);
		}
	}
	return result;
};
hxGeomAlgo_EarCut.polygonize = function(triangulation) {
	var polys = [];
	if(triangulation.length == 0) {
		return [];
	} else {
		var covered = [];
		var _g = 0;
		var _g1 = triangulation.length;
		while(_g < _g1) {
			var i = _g++;
			covered[i] = false;
		}
		var notDone = true;
		while(notDone) {
			var poly = null;
			var currTri = -1;
			var _g = 0;
			var _g1 = triangulation.length;
			while(_g < _g1) {
				var i = _g++;
				if(covered[i]) {
					continue;
				}
				currTri = i;
				break;
			}
			if(currTri == -1) {
				notDone = false;
			} else {
				poly = triangulation[currTri];
				covered[currTri] = true;
				var _g2 = 0;
				var _g3 = triangulation.length;
				while(_g2 < _g3) {
					var i1 = _g2++;
					if(covered[i1]) {
						continue;
					}
					var newPoly = hxGeomAlgo_EarCut.addTriangle(poly,triangulation[i1]);
					if(newPoly == null) {
						continue;
					}
					if(hxGeomAlgo_PolyTools.isConvex(newPoly)) {
						poly = newPoly;
						covered[i1] = true;
					}
				}
				polys.push(poly);
			}
		}
	}
	return polys;
};
hxGeomAlgo_EarCut.addTriangle = function(poly,t) {
	var firstP = -1;
	var firstT = -1;
	var secondP = -1;
	var secondT = -1;
	var _g = 0;
	var _g1 = poly.length;
	while(_g < _g1) {
		var i = _g++;
		if(t[0].x == poly[i].x && t[0].y == poly[i].y) {
			if(firstP == -1) {
				firstP = i;
				firstT = 0;
			} else {
				secondP = i;
				secondT = 0;
			}
		} else if(t[1].x == poly[i].x && t[1].y == poly[i].y) {
			if(firstP == -1) {
				firstP = i;
				firstT = 1;
			} else {
				secondP = i;
				secondT = 1;
			}
		} else if(t[2].x == poly[i].x && t[2].y == poly[i].y) {
			if(firstP == -1) {
				firstP = i;
				firstT = 2;
			} else {
				secondP = i;
				secondT = 2;
			}
		}
	}
	if(firstP == 0 && secondP == poly.length - 1) {
		firstP = poly.length - 1;
		secondP = 0;
	}
	if(secondP == -1) {
		return null;
	}
	var tipT = 0;
	if(tipT == firstT || tipT == secondT) {
		tipT = 1;
	}
	if(tipT == firstT || tipT == secondT) {
		tipT = 2;
	}
	var newPoints = [];
	var _g = 0;
	var _g1 = poly.length;
	while(_g < _g1) {
		var i = _g++;
		newPoints.push(poly[i]);
		if(i == firstP) {
			newPoints.push(t[tipT]);
		}
	}
	return newPoints;
};
var hxGeomAlgo_EarNode = function(i,x,y) {
	this.i = i;
	this.x = x;
	this.y = y;
	this.prev = null;
	this.next = null;
	this.z = null;
	this.prevZ = null;
	this.nextZ = null;
	this.steiner = false;
};
$hxClasses["hxGeomAlgo.EarNode"] = hxGeomAlgo_EarNode;
hxGeomAlgo_EarNode.__name__ = "hxGeomAlgo.EarNode";
hxGeomAlgo_EarNode.prototype = {
	i: null
	,x: null
	,y: null
	,prev: null
	,next: null
	,z: null
	,prevZ: null
	,nextZ: null
	,steiner: null
	,__class__: hxGeomAlgo_EarNode
};
var hxGeomAlgo_Heapable = function() { };
$hxClasses["hxGeomAlgo.Heapable"] = hxGeomAlgo_Heapable;
hxGeomAlgo_Heapable.__name__ = "hxGeomAlgo.Heapable";
hxGeomAlgo_Heapable.__isInterface__ = true;
hxGeomAlgo_Heapable.prototype = {
	position: null
	,compare: null
	,__class__: hxGeomAlgo_Heapable
};
var hxGeomAlgo_Heap = function() {
	this.length = 0;
	this.data = [];
};
$hxClasses["hxGeomAlgo.Heap"] = hxGeomAlgo_Heap;
hxGeomAlgo_Heap.__name__ = "hxGeomAlgo.Heap";
hxGeomAlgo_Heap.prototype = {
	data: null
	,length: null
	,push: function(obj) {
		var i = this.length;
		this.set(obj,i);
		this.length++;
		if(this.length > 1) {
			this.bubbleUp(i);
		}
	}
	,pop: function() {
		if(this.length == 0) {
			return null;
		}
		var res = this.data[0];
		var len = this.length;
		var lastObj = this.data[len - 1];
		this.data[len - 1] = null;
		this.length--;
		if(len > 1) {
			this.set(lastObj,0);
			this.bubbleDown(0);
		}
		return res;
	}
	,top: function() {
		if(this.length > 0) {
			return this.data[0];
		} else {
			return null;
		}
	}
	,remove: function(obj) {
		var pos = obj.position;
		var len = this.length;
		var lastObj = this.data[len - 1];
		this.data[len - 1] = null;
		this.length--;
		if(pos != len - 1) {
			this.set(lastObj,pos);
			if(lastObj.compare(obj) < 0) {
				this.bubbleUp(pos);
			} else {
				this.bubbleDown(pos);
			}
		}
		return pos;
	}
	,clear: function() {
		this.data.length = 0;
		this.length = 0;
	}
	,bubbleDown: function(i) {
		var left = 2 * i + 1;
		var right = 2 * i + 2;
		var curr = i;
		if(left < this.length && this.data[left].compare(this.data[curr]) < 0) {
			curr = left;
		}
		if(right < this.length && this.data[right].compare(this.data[curr]) < 0) {
			curr = right;
		}
		if(curr != i) {
			var temp = this.data[curr];
			this.set(this.data[i],curr);
			this.set(temp,i);
			this.bubbleDown(curr);
		}
	}
	,bubbleUp: function(i) {
		while(i > 0 && this.data[i].compare(this.data[i - 1 >> 1]) <= 0) {
			var parent = i - 1 >> 1;
			var temp = this.data[parent];
			this.set(this.data[i],parent);
			this.set(temp,i);
			i = parent;
		}
	}
	,validate: function() {
		if(this.length > 0) {
			this._validate(0);
		}
	}
	,toArray: function() {
		return [].concat(this.data);
	}
	,_validate: function(i) {
		var len = this.length;
		var left = 2 * i + 1;
		var right = 2 * i + 2;
		if(left < len) {
			var cond = this.data[i].compare(this.data[left]) <= 0;
			this._validate(2 * i + 1);
		}
		if(right < len) {
			var cond = this.data[i].compare(this.data[right]) <= 0;
			this._validate(2 * i + 2);
		}
	}
	,set: function(obj,index) {
		this.data[index] = obj;
		obj.position = index;
	}
	,leftOf: function(i) {
		return 2 * i + 1;
	}
	,rightOf: function(i) {
		return 2 * i + 2;
	}
	,parentOf: function(i) {
		return i - 1 >> 1;
	}
	,swap: function(i,j) {
		var temp = this.data[i];
		this.set(this.data[j],i);
		this.set(temp,j);
	}
	,__class__: hxGeomAlgo_Heap
};
var hxGeomAlgo_HertelMehlhorn = $hx_exports["hxGeomAlgo"]["HertelMehlhorn"] = function() { };
$hxClasses["hxGeomAlgo.HertelMehlhorn"] = hxGeomAlgo_HertelMehlhorn;
hxGeomAlgo_HertelMehlhorn.__name__ = "hxGeomAlgo.HertelMehlhorn";
hxGeomAlgo_HertelMehlhorn.diagonals = null;
hxGeomAlgo_HertelMehlhorn.polygonize = function(triangulation) {
	var res = triangulation.concat([]);
	hxGeomAlgo_HertelMehlhorn.diagonals = [];
	var poly;
	var qoly;
	var newPoly;
	var d1;
	var d2;
	var p;
	var q;
	var isDiagonal;
	var polyIt;
	var qolyIt;
	var j;
	var outerIt = 0;
	var innerIt = 0;
	while(outerIt < res.length) {
		poly = res[outerIt];
		qoly = res[0];
		polyIt = 0;
		qolyIt = 0;
		while(polyIt < poly.length) {
			d1 = poly[polyIt];
			var idx = polyIt + 1;
			var idx1 = idx;
			var len = poly.length;
			if(idx1 < 0) {
				idx1 += len;
			}
			idx = idx1 % len;
			d2 = poly[idx];
			isDiagonal = false;
			innerIt = outerIt + 1;
			while(innerIt < res.length) {
				qoly = res[innerIt];
				qolyIt = 0;
				while(qolyIt < qoly.length) {
					q = qoly[qolyIt];
					if(d2.x != q.x || d2.y != q.y) {
						++qolyIt;
						continue;
					}
					var idx2 = qolyIt + 1;
					var idx3 = idx2;
					var len1 = qoly.length;
					if(idx3 < 0) {
						idx3 += len1;
					}
					idx2 = idx3 % len1;
					q = qoly[idx2];
					if(d1.x != q.x || d1.y != q.y) {
						++qolyIt;
						continue;
					}
					isDiagonal = true;
					break;
				}
				if(isDiagonal) {
					break;
				}
				++innerIt;
			}
			if(!isDiagonal) {
				++polyIt;
				continue;
			}
			var d = { from : d1, to : d2};
			hxGeomAlgo_HertelMehlhorn.diagonals.push(d);
			var idx4 = polyIt + 2;
			var idx5 = idx4;
			var len2 = poly.length;
			if(idx5 < 0) {
				idx5 += len2;
			}
			idx4 = idx5 % len2;
			p = poly[idx4];
			var idx6 = qolyIt - 1;
			var idx7 = idx6;
			var len3 = qoly.length;
			if(idx7 < 0) {
				idx7 += len3;
			}
			idx6 = idx7 % len3;
			q = qoly[idx6];
			if((q.x - d1.x) * (p.y - d1.y) - (p.x - d1.x) * (q.y - d1.y) < 0) {
				++polyIt;
				continue;
			}
			if((p.x - d2.x) * (q.y - d2.y) - (q.x - d2.x) * (p.y - d2.y) < 0) {
				++polyIt;
				continue;
			}
			newPoly = [];
			j = polyIt + 1;
			while(true) {
				var idx8 = j;
				var len4 = poly.length;
				if(idx8 < 0) {
					idx8 += len4;
				}
				if(!(idx8 % len4 != polyIt)) {
					break;
				}
				var idx9 = j;
				var idx10 = idx9;
				var len5 = poly.length;
				if(idx10 < 0) {
					idx10 += len5;
				}
				idx9 = idx10 % len5;
				newPoly.push(poly[idx9]);
				++j;
			}
			j = qolyIt + 1;
			while(true) {
				var idx11 = j;
				var len6 = qoly.length;
				if(idx11 < 0) {
					idx11 += len6;
				}
				if(!(idx11 % len6 != qolyIt)) {
					break;
				}
				var idx12 = j;
				var idx13 = idx12;
				var len7 = qoly.length;
				if(idx13 < 0) {
					idx13 += len7;
				}
				idx12 = idx13 % len7;
				newPoly.push(qoly[idx12]);
				++j;
			}
			if(hxGeomAlgo_PolyTools.isConvex(newPoly)) {
				res.splice(innerIt,1);
				res[outerIt] = newPoly;
				poly = newPoly;
				polyIt = -1;
			}
			++polyIt;
		}
		++outerIt;
	}
	return res;
};
var hxGeomAlgo_HomogCoord = function(x,y,w) {
	if(w == null) {
		w = 1;
	}
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.x = x;
	this.y = y;
	this.w = w;
};
$hxClasses["hxGeomAlgo.HomogCoord"] = hxGeomAlgo_HomogCoord;
hxGeomAlgo_HomogCoord.__name__ = "hxGeomAlgo.HomogCoord";
hxGeomAlgo_HomogCoord.det = function(p,q,r) {
	return p.w * q.perpdot(r) - q.w * p.perpdot(r) + r.w * p.perpdot(q);
};
hxGeomAlgo_HomogCoord.ccw = function(p,q,r) {
	return hxGeomAlgo_HomogCoord.det(p,q,r) > 0;
};
hxGeomAlgo_HomogCoord.cw = function(p,q,r) {
	return hxGeomAlgo_HomogCoord.det(p,q,r) < 0;
};
hxGeomAlgo_HomogCoord.prototype = {
	x: null
	,y: null
	,w: null
	,add: function(p) {
		this.x += p.x;
		this.y += p.y;
		return this;
	}
	,sub: function(p) {
		this.x -= p.x;
		this.y -= p.y;
		return this;
	}
	,neg: function() {
		this.w = -this.w;
		this.x = -this.x;
		this.y = -this.y;
		return this;
	}
	,mul: function(m) {
		this.w *= m;
		this.x *= m;
		this.y *= m;
		return this;
	}
	,div: function(m) {
		this.w /= m;
		this.x /= m;
		this.y /= m;
		return this;
	}
	,normalize: function() {
		return this.div(this.length());
	}
	,lengthSquared: function() {
		return this.x * this.x + this.y * this.y;
	}
	,length: function() {
		return Math.sqrt(this.lengthSquared());
	}
	,perp: function() {
		var tmp = -this.y;
		this.y = this.x;
		this.x = tmp;
		return this;
	}
	,dotPoint: function(p) {
		return this.w + this.x * p.x + this.y * p.y;
	}
	,dot: function(p) {
		return this.w * p.w + this.x * p.x + this.y * p.y;
	}
	,perpdot: function(p) {
		return this.x * p.y - this.y * p.x;
	}
	,dotperp: function(p) {
		return -this.x * p.y + this.y * p.x;
	}
	,equals: function(p) {
		if(p.w * this.x == this.w * p.x) {
			return p.w * this.y == this.w * p.y;
		} else {
			return false;
		}
	}
	,left: function(p) {
		return this.dotPoint(p) > 0;
	}
	,right: function(p) {
		return this.dotPoint(p) < 0;
	}
	,toScreen: function() {
		return hxGeomAlgo_HxPoint._new(this.x / this.w,-this.y / this.w);
	}
	,toPoint: function() {
		return hxGeomAlgo_HxPoint._new(this.x / this.w,this.y / this.w);
	}
	,meet: function(p) {
		return new hxGeomAlgo_HomogCoord(p.w * this.y - this.w * p.y,this.w * p.x - p.w * this.x,this.x * p.y - this.y * p.x);
	}
	,meetPoint: function(p) {
		return new hxGeomAlgo_HomogCoord(this.y - this.w * p.y,this.w * p.x - this.x,this.x * p.y - this.y * p.x);
	}
	,toString: function() {
		return " (w:" + this.w + "; x:" + this.x + ", y:" + this.y + ")  ";
	}
	,__class__: hxGeomAlgo_HomogCoord
};
var hxGeomAlgo_IsoContours = $hx_exports["hxGeomAlgo"]["IsoContours"] = function(pixels,isoFunction) {
	this.pixels = pixels;
	this.width = pixels.width;
	this.height = pixels.height;
	this.values = null;
	this.isoFunction = isoFunction != null ? isoFunction : hxGeomAlgo_IsoContours.isoAlpha;
};
$hxClasses["hxGeomAlgo.IsoContours"] = hxGeomAlgo_IsoContours;
hxGeomAlgo_IsoContours.__name__ = "hxGeomAlgo.IsoContours";
hxGeomAlgo_IsoContours.isoAlpha = function(pixels,x,y) {
	if(x < 0 || y < 0 || x >= pixels.width || y >= pixels.height) {
		return 0;
	} else {
		var pos = y * pixels.width + x << 2;
		var a = pixels.bytes.b[pos + pixels.format.ch0] << 24;
		var r = pixels.bytes.b[pos + pixels.format.ch1] << 16;
		var g = pixels.bytes.b[pos + pixels.format.ch2] << 8;
		var b = pixels.bytes.b[pos + pixels.format.ch3];
		return (a | r | g | b) >> 24 & 255;
	}
};
hxGeomAlgo_IsoContours.isOutOfBounds = function(pixels,x,y) {
	if(!(x < 0 || y < 0 || x >= pixels.width)) {
		return y >= pixels.height;
	} else {
		return true;
	}
};
hxGeomAlgo_IsoContours.prototype = {
	isoFunction: null
	,pixels: null
	,width: null
	,height: null
	,values: null
	,adjacencyMap: null
	,find: function(isoValue,addBorders,recalcValues) {
		if(recalcValues == null) {
			recalcValues = true;
		}
		if(addBorders == null) {
			addBorders = true;
		}
		if(isoValue == null) {
			isoValue = 0;
		}
		this.march(isoValue,addBorders,recalcValues);
		var contours = this.merge();
		return contours;
	}
	,merge: function() {
		var isoLines = [];
		var segment = null;
		while(true) {
			segment = this.adjacencyMap.getFirstSegment();
			if(!(segment != null)) {
				break;
			}
			var start = segment.from;
			var end = segment.to;
			var reversedIsoLine = [start];
			var isoLine = [end];
			while(true) {
				end = this.adjacencyMap.getEndingPointOf(end);
				start = this.adjacencyMap.getStartingPointOf(start);
				if(end != null) {
					isoLine.push(end);
				}
				if(start != null) {
					reversedIsoLine.push(start);
				}
				if(start == null && end == null) {
					break;
				}
			}
			reversedIsoLine.reverse();
			isoLines.push(reversedIsoLine.concat(isoLine));
		}
		return isoLines;
	}
	,march: function(isoValue,addBorders,recalcValues) {
		if(recalcValues == null) {
			recalcValues = true;
		}
		if(addBorders == null) {
			addBorders = true;
		}
		if(isoValue == null) {
			isoValue = 0;
		}
		this.adjacencyMap = new hxGeomAlgo_AdjacencyMap();
		var paddedWidth = this.width + 2;
		var paddedHeight = this.height + 2;
		if(recalcValues || this.values == null) {
			var this1 = new Array(paddedWidth * paddedHeight);
			this.values = this1;
			var _g = 0;
			var _g1 = paddedHeight;
			while(_g < _g1) {
				var y = _g++;
				var _g2 = 0;
				var _g3 = paddedWidth;
				while(_g2 < _g3) {
					var x = _g2++;
					var pos = y * paddedWidth + x;
					var value = this.isoFunction(this.pixels,x - 1,y - 1);
					this.values[pos] = value;
				}
			}
		}
		var offset = -.5;
		var startX = 0;
		var startY = 0;
		var endX = this.width + 1;
		var endY = this.height + 1;
		if(!addBorders) {
			startX = 1;
			startY = 1;
			endX = this.width;
			endY = this.height;
		}
		var _g = startY;
		var _g1 = endY;
		while(_g < _g1) {
			var y = _g++;
			var _g2 = startX;
			var _g3 = endX;
			while(_g2 < _g3) {
				var x = _g2++;
				var pos = y * paddedWidth + x;
				var topLeft = this.values[pos];
				var topRight = this.values[pos + 1];
				var bottomRight = this.values[pos + 1 + paddedWidth];
				var bottomLeft = this.values[pos + paddedWidth];
				var binaryIdx = 0;
				if(topLeft > isoValue) {
					binaryIdx += 8;
				}
				if(topRight > isoValue) {
					binaryIdx += 4;
				}
				if(bottomRight > isoValue) {
					binaryIdx += 2;
				}
				if(bottomLeft > isoValue) {
					++binaryIdx;
				}
				if(binaryIdx != 0 && binaryIdx != 15) {
					var topPoint = hxGeomAlgo_HxPoint._new(offset + x + this.interp(isoValue,topLeft,topRight),offset + y);
					var leftPoint = hxGeomAlgo_HxPoint._new(offset + x,offset + y + this.interp(isoValue,topLeft,bottomLeft));
					var rightPoint = hxGeomAlgo_HxPoint._new(offset + x + 1,offset + y + this.interp(isoValue,topRight,bottomRight));
					var bottomPoint = hxGeomAlgo_HxPoint._new(offset + x + this.interp(isoValue,bottomLeft,bottomRight),offset + y + 1);
					if(binaryIdx == 5 || binaryIdx == 10) {
						var avgValue = (topLeft + topRight + bottomRight + bottomLeft) / 4;
						if(avgValue <= 0) {
							binaryIdx = ~binaryIdx & 15;
						}
					}
					switch(binaryIdx) {
					case 1:
						this.adjacencyMap.addSegment(leftPoint,bottomPoint);
						break;
					case 2:
						this.adjacencyMap.addSegment(bottomPoint,rightPoint);
						break;
					case 3:
						this.adjacencyMap.addSegment(leftPoint,rightPoint);
						break;
					case 4:
						this.adjacencyMap.addSegment(rightPoint,topPoint);
						break;
					case 5:
						this.adjacencyMap.addSegment(leftPoint,topPoint);
						this.adjacencyMap.addSegment(rightPoint,bottomPoint);
						break;
					case 6:
						this.adjacencyMap.addSegment(bottomPoint,topPoint);
						break;
					case 7:
						this.adjacencyMap.addSegment(leftPoint,topPoint);
						break;
					case 8:
						this.adjacencyMap.addSegment(topPoint,leftPoint);
						break;
					case 9:
						this.adjacencyMap.addSegment(topPoint,bottomPoint);
						break;
					case 10:
						this.adjacencyMap.addSegment(bottomPoint,leftPoint);
						this.adjacencyMap.addSegment(topPoint,rightPoint);
						break;
					case 11:
						this.adjacencyMap.addSegment(topPoint,rightPoint);
						break;
					case 12:
						this.adjacencyMap.addSegment(rightPoint,leftPoint);
						break;
					case 13:
						this.adjacencyMap.addSegment(rightPoint,bottomPoint);
						break;
					case 14:
						this.adjacencyMap.addSegment(bottomPoint,leftPoint);
						break;
					default:
					}
				}
			}
		}
	}
	,interp: function(isoValue,fromValue,toValue) {
		if(fromValue == toValue) {
			return 0;
		}
		return (isoValue - fromValue) / (toValue - fromValue);
	}
	,__class__: hxGeomAlgo_IsoContours
};
var hxGeomAlgo_AdjacencyMap = function() {
	this.firstIdx = 0;
	this.pointSet = new haxe_ds_StringMap();
	this.segments = [];
	this.mapStartToEnd = new haxe_ds_ObjectMap();
	this.mapEndToStart = new haxe_ds_ObjectMap();
};
$hxClasses["hxGeomAlgo.AdjacencyMap"] = hxGeomAlgo_AdjacencyMap;
hxGeomAlgo_AdjacencyMap.__name__ = "hxGeomAlgo.AdjacencyMap";
hxGeomAlgo_AdjacencyMap.prototype = {
	pointSet: null
	,firstIdx: null
	,segments: null
	,mapStartToEnd: null
	,mapEndToStart: null
	,addSegment: function(from,to) {
		if(to != null && from.x == to.x && from.y == to.y) {
			return;
		}
		var fromKey = "(" + from.x + ", " + from.y + ")";
		var toKey = "(" + to.x + ", " + to.y + ")";
		if(!Object.prototype.hasOwnProperty.call(this.pointSet.h,fromKey)) {
			this.pointSet.h[fromKey] = from;
		} else {
			from = this.pointSet.h[fromKey];
		}
		if(!Object.prototype.hasOwnProperty.call(this.pointSet.h,toKey)) {
			this.pointSet.h[toKey] = to;
		} else {
			to = this.pointSet.h[toKey];
		}
		var idx = this.segments.length;
		this.segments.push(new hxGeomAlgo__$IsoContours_Segment(from,to));
		if(this.mapStartToEnd.h.__keys__[from.__id__] != null) {
			this.mapStartToEnd.h[from.__id__].push(idx);
		} else {
			this.mapStartToEnd.set(from,[idx]);
		}
		if(this.mapEndToStart.h.__keys__[to.__id__] != null) {
			this.mapEndToStart.h[to.__id__].push(idx);
		} else {
			this.mapEndToStart.set(to,[idx]);
		}
	}
	,getStartingPointOf: function(end) {
		if(end == null) {
			return null;
		}
		var start = null;
		if(this.mapEndToStart.h.__keys__[end.__id__] != null) {
			var entry = this.mapEndToStart.h[end.__id__];
			var idx = entry[0];
			start = this.segments[idx].from;
			this.removeSegmentAt(idx);
		}
		return start;
	}
	,getEndingPointOf: function(start) {
		if(start == null) {
			return null;
		}
		var end = null;
		if(this.mapStartToEnd.h.__keys__[start.__id__] != null) {
			var entry = this.mapStartToEnd.h[start.__id__];
			var idx = entry[0];
			end = this.segments[idx].to;
			this.removeSegmentAt(idx);
		}
		return end;
	}
	,getFirstSegment: function() {
		var segment = null;
		var _g = this.firstIdx;
		var _g1 = this.segments.length;
		while(_g < _g1) {
			var i = _g++;
			segment = this.segments[i];
			if(segment != null) {
				this.removeSegmentAt(i);
				this.firstIdx = i;
				break;
			}
		}
		return segment;
	}
	,removeSegmentAt: function(i) {
		var segment = this.segments[i];
		var start = segment.from;
		var end = segment.to;
		var entry = this.mapStartToEnd.h[start.__id__];
		HxOverrides.remove(entry,i);
		if(entry.length == 0) {
			this.mapStartToEnd.remove(start);
		}
		entry = this.mapEndToStart.h[end.__id__];
		HxOverrides.remove(entry,i);
		if(entry.length == 0) {
			this.mapEndToStart.remove(end);
		}
		this.segments[i] = null;
	}
	,__class__: hxGeomAlgo_AdjacencyMap
};
var hxGeomAlgo__$IsoContours_Segment = function(from,to) {
	this.from = from;
	this.to = to;
};
$hxClasses["hxGeomAlgo._IsoContours.Segment"] = hxGeomAlgo__$IsoContours_Segment;
hxGeomAlgo__$IsoContours_Segment.__name__ = "hxGeomAlgo._IsoContours.Segment";
hxGeomAlgo__$IsoContours_Segment.prototype = {
	from: null
	,to: null
	,__class__: hxGeomAlgo__$IsoContours_Segment
};
var hxGeomAlgo_StepDirection = $hxEnums["hxGeomAlgo.StepDirection"] = { __ename__ : "hxGeomAlgo.StepDirection", __constructs__ : ["NONE","UP","LEFT","DOWN","RIGHT"]
	,NONE: {_hx_index:0,__enum__:"hxGeomAlgo.StepDirection",toString:$estr}
	,UP: {_hx_index:1,__enum__:"hxGeomAlgo.StepDirection",toString:$estr}
	,LEFT: {_hx_index:2,__enum__:"hxGeomAlgo.StepDirection",toString:$estr}
	,DOWN: {_hx_index:3,__enum__:"hxGeomAlgo.StepDirection",toString:$estr}
	,RIGHT: {_hx_index:4,__enum__:"hxGeomAlgo.StepDirection",toString:$estr}
};
hxGeomAlgo_StepDirection.__empty_constructs__ = [hxGeomAlgo_StepDirection.NONE,hxGeomAlgo_StepDirection.UP,hxGeomAlgo_StepDirection.LEFT,hxGeomAlgo_StepDirection.DOWN,hxGeomAlgo_StepDirection.RIGHT];
var hxGeomAlgo_MarchingSquares = $hx_exports["hxGeomAlgo"]["MarchingSquares"] = function(pixels,alphaThreshold) {
	if(alphaThreshold == null) {
		alphaThreshold = 1;
	}
	this.nextStep = hxGeomAlgo_StepDirection.NONE;
	this.prevStep = hxGeomAlgo_StepDirection.NONE;
	this.setSource(pixels);
	this.alphaThreshold = alphaThreshold;
};
$hxClasses["hxGeomAlgo.MarchingSquares"] = hxGeomAlgo_MarchingSquares;
hxGeomAlgo_MarchingSquares.__name__ = "hxGeomAlgo.MarchingSquares";
hxGeomAlgo_MarchingSquares.prototype = {
	alphaThreshold: null
	,prevStep: null
	,nextStep: null
	,pixels: null
	,width: null
	,height: null
	,setSource: function(pixels) {
		this.pixels = pixels;
		this.width = this.pixels.width;
		this.height = this.pixels.height;
	}
	,march: function(startPoint) {
		if(startPoint == null) {
			startPoint = this.findStartPoint();
		}
		if(startPoint == null) {
			return [];
		}
		var perimeter = this.walkPerimeter(startPoint.x | 0,startPoint.y | 0);
		var tmp;
		if(perimeter.length > 1) {
			var this1 = perimeter[0];
			var p = perimeter[perimeter.length - 1];
			tmp = p != null && this1.x == p.x && this1.y == p.y;
		} else {
			tmp = false;
		}
		if(tmp) {
			perimeter.pop();
		}
		return perimeter;
	}
	,findStartPoint: function(line) {
		if(line == null) {
			line = 0;
		}
		var found = false;
		var _g = line;
		var _g1 = this.height;
		while(_g < _g1) {
			var y = _g++;
			var _g2 = 0;
			var _g3 = this.width;
			while(_g2 < _g3) {
				var x = _g2++;
				if(this.isPixelSolid(x,y)) {
					return hxGeomAlgo_HxPoint._new(x,y);
				}
			}
		}
		return null;
	}
	,walkPerimeter: function(startX,startY) {
		if(startX < 0) {
			startX = 0;
		}
		if(startX > this.width) {
			startX = this.width;
		}
		if(startY < 0) {
			startY = 0;
		}
		if(startY > this.height) {
			startY = this.height;
		}
		var lastAddedPoint = hxGeomAlgo_HxPoint._new(-1,-1);
		var pointList = [];
		var x = startX;
		var y = startY;
		var done = false;
		while(!done) {
			this.step(x,y);
			var newPoint = hxGeomAlgo_HxPoint._new(x >= this.width ? x - 1 : x,y >= this.height ? y - 1 : y);
			if(!(newPoint != null && lastAddedPoint.x == newPoint.x && lastAddedPoint.y == newPoint.y)) {
				pointList.push(newPoint);
				lastAddedPoint = newPoint;
			}
			switch(this.nextStep._hx_index) {
			case 1:
				--y;
				break;
			case 2:
				--x;
				break;
			case 3:
				++y;
				break;
			case 4:
				++x;
				break;
			default:
			}
			done = x == startX && y == startY;
		}
		return pointList;
	}
	,step: function(x,y) {
		var upLeft = this.isPixelSolid(x - 1,y - 1);
		var upRight = this.isPixelSolid(x,y - 1);
		var downLeft = this.isPixelSolid(x - 1,y);
		var downRight = this.isPixelSolid(x,y);
		this.prevStep = this.nextStep;
		var state = 0;
		if(upLeft) {
			state |= 1;
		}
		if(upRight) {
			state |= 2;
		}
		if(downLeft) {
			state |= 4;
		}
		if(downRight) {
			state |= 8;
		}
		switch(state) {
		case 1:case 5:case 13:
			this.nextStep = hxGeomAlgo_StepDirection.UP;
			break;
		case 2:case 3:case 7:
			this.nextStep = hxGeomAlgo_StepDirection.RIGHT;
			break;
		case 6:
			this.nextStep = this.prevStep == hxGeomAlgo_StepDirection.UP ? hxGeomAlgo_StepDirection.LEFT : hxGeomAlgo_StepDirection.RIGHT;
			break;
		case 8:case 10:case 11:
			this.nextStep = hxGeomAlgo_StepDirection.DOWN;
			break;
		case 9:
			this.nextStep = this.prevStep == hxGeomAlgo_StepDirection.RIGHT ? hxGeomAlgo_StepDirection.UP : hxGeomAlgo_StepDirection.DOWN;
			break;
		case 4:case 12:case 14:
			this.nextStep = hxGeomAlgo_StepDirection.LEFT;
			break;
		default:
		}
	}
	,isPixelSolid: function(x,y) {
		if(x >= 0 && y >= 0 && x < this.width && y < this.height) {
			var this1 = this.pixels;
			var i = y * this.width + x << 2;
			return this1.bytes.b[(i & -4) + this1.format.channelMap[i & 3]] >= this.alphaThreshold;
		} else {
			return false;
		}
	}
	,__class__: hxGeomAlgo_MarchingSquares
};
var hxGeomAlgo_PairDeque = function() {
	this.lastIdx = this.frontTopIdx = -1;
	this.backTopIdx = 0;
	this.front = [];
	this.back = [];
};
$hxClasses["hxGeomAlgo.PairDeque"] = hxGeomAlgo_PairDeque;
hxGeomAlgo_PairDeque.__name__ = "hxGeomAlgo.PairDeque";
hxGeomAlgo_PairDeque.prototype = {
	front: null
	,back: null
	,frontTopIdx: null
	,backTopIdx: null
	,lastIdx: null
	,push: function(i,j) {
		if(this.front.length <= ++this.frontTopIdx) {
			this.front.push(-1);
			this.back.push(-1);
		}
		this.front[this.frontTopIdx] = i;
		this.back[this.frontTopIdx] = j;
		this.lastIdx = this.frontTopIdx;
	}
	,pushNarrow: function(i,j) {
		if(!this.isFrontEmpty() && i <= this.frontTop()) {
			return;
		}
		while(!this.isFrontEmpty() && this.backBottom() >= j) this.popFront();
		this.push(i,j);
	}
	,isFrontEmpty: function() {
		return this.frontTopIdx < 0;
	}
	,frontHasNext: function() {
		return this.frontTopIdx > 0;
	}
	,flush: function() {
		this.lastIdx = this.frontTopIdx = -1;
	}
	,frontTop: function() {
		if(this.frontTopIdx < 0) {
			return 0;
		}
		return this.front[this.frontTopIdx];
	}
	,frontPeekNext: function() {
		return this.front[this.frontTopIdx - 1];
	}
	,backBottom: function() {
		return this.back[this.frontTopIdx];
	}
	,popFront: function() {
		return this.front[this.frontTopIdx--];
	}
	,restore: function() {
		this.backTopIdx = 0;
		this.frontTopIdx = this.lastIdx;
	}
	,isBackEmpty: function() {
		return this.backTopIdx > this.lastIdx;
	}
	,backHasNext: function() {
		return this.backTopIdx < this.lastIdx;
	}
	,frontBottom: function() {
		return this.front[this.backTopIdx];
	}
	,backPeekNext: function() {
		return this.back[this.backTopIdx + 1];
	}
	,backTop: function() {
		return this.back[this.backTopIdx];
	}
	,popBack: function() {
		return this.back[this.backTopIdx++];
	}
	,toString: function() {
		var stringBuffer_b = "";
		stringBuffer_b += Std.string("fp:" + this.frontTopIdx + ", bp:" + this.backTopIdx + ", last:" + this.lastIdx + ": ");
		var _g = 0;
		var _g1 = this.lastIdx + 1;
		while(_g < _g1) {
			var i = _g++;
			stringBuffer_b += Std.string(this.front[i] + "," + this.back[i] + "  ");
		}
		return stringBuffer_b;
	}
	,__class__: hxGeomAlgo_PairDeque
};
var hxGeomAlgo_PoleOfInaccessibility = $hx_exports["hxGeomAlgo"]["PoleOfInaccessibility"] = function() { };
$hxClasses["hxGeomAlgo.PoleOfInaccessibility"] = hxGeomAlgo_PoleOfInaccessibility;
hxGeomAlgo_PoleOfInaccessibility.__name__ = "hxGeomAlgo.PoleOfInaccessibility";
hxGeomAlgo_PoleOfInaccessibility.SQRT2 = null;
hxGeomAlgo_PoleOfInaccessibility.calculate = function(poly,precision,debug) {
	if(debug == null) {
		debug = false;
	}
	if(precision == null) {
		precision = 1.0;
	}
	if(poly == null || poly.length <= 0) {
		return hxGeomAlgo_HxPoint.EMPTY;
	}
	var minX = Infinity;
	var minY = Infinity;
	var maxX = -Infinity;
	var maxY = -Infinity;
	var _g = 0;
	while(_g < poly.length) {
		var ring = poly[_g];
		++_g;
		var _g1 = 0;
		while(_g1 < ring.length) {
			var p = ring[_g1];
			++_g1;
			if(p.x < minX) {
				minX = p.x;
			}
			if(p.y < minY) {
				minY = p.y;
			}
			if(p.x > maxX) {
				maxX = p.x;
			}
			if(p.y > maxY) {
				maxY = p.y;
			}
		}
	}
	var width = maxX - minX;
	var height = maxY - minY;
	var cellSize = Math.min(width,height);
	var h = cellSize / 2;
	var cellQueue = new hxGeomAlgo_Heap();
	if(cellSize == 0.0) {
		return hxGeomAlgo_HxPoint._new(minX,minY);
	}
	var x = minX;
	var y = minY;
	while(x < maxX) {
		y = minY;
		while(y < maxY) {
			cellQueue.push(new hxGeomAlgo__$PoleOfInaccessibility_Cell(x + h,y + h,h,poly));
			y += cellSize;
		}
		x += cellSize;
	}
	var bestCell = hxGeomAlgo_PoleOfInaccessibility.getCentroidCell(poly);
	var bboxCell = new hxGeomAlgo__$PoleOfInaccessibility_Cell(minX + width / 2,minY + height / 2,0,poly);
	if(bboxCell.d > bestCell.d) {
		bestCell = bboxCell;
	}
	var numProbes = cellQueue.length;
	while(cellQueue.length > 0) {
		var cell = cellQueue.pop();
		if(cell.d > bestCell.d) {
			bestCell = cell;
			if(debug) {
				haxe_Log.trace("found best " + Math.round(1e4 * cell.d) / 1e4 + " after " + numProbes + " probes",{ fileName : "src/hxGeomAlgo/PoleOfInaccessibility.hx", lineNumber : 84, className : "hxGeomAlgo.PoleOfInaccessibility", methodName : "calculate"});
			}
		}
		if(cell.max - bestCell.d <= precision) {
			continue;
		}
		h = cell.h / 2;
		cellQueue.push(new hxGeomAlgo__$PoleOfInaccessibility_Cell(cell.x - h,cell.y - h,h,poly));
		cellQueue.push(new hxGeomAlgo__$PoleOfInaccessibility_Cell(cell.x + h,cell.y - h,h,poly));
		cellQueue.push(new hxGeomAlgo__$PoleOfInaccessibility_Cell(cell.x - h,cell.y + h,h,poly));
		cellQueue.push(new hxGeomAlgo__$PoleOfInaccessibility_Cell(cell.x + h,cell.y + h,h,poly));
		numProbes += 4;
	}
	if(debug) {
		haxe_Log.trace("num probes: " + numProbes,{ fileName : "src/hxGeomAlgo/PoleOfInaccessibility.hx", lineNumber : 100, className : "hxGeomAlgo.PoleOfInaccessibility", methodName : "calculate"});
		haxe_Log.trace("best distance: " + bestCell.d,{ fileName : "src/hxGeomAlgo/PoleOfInaccessibility.hx", lineNumber : 101, className : "hxGeomAlgo.PoleOfInaccessibility", methodName : "calculate"});
	}
	return hxGeomAlgo_HxPoint._new(bestCell.x,bestCell.y);
};
hxGeomAlgo_PoleOfInaccessibility.pointToPolygonDist = function(x,y,poly) {
	var inside = false;
	var minDistSq = Infinity;
	var _g = 0;
	var _g1 = poly.length;
	while(_g < _g1) {
		var k = _g++;
		var ring = poly[k];
		var i = 0;
		var len = ring.length;
		var j = len - 1;
		while(i < len) {
			var a = ring[i];
			var b = ring[j];
			if(a.y > y != b.y > y && x < (b.x - a.x) * (y - a.y) / (b.y - a.y) + a.x) {
				inside = !inside;
			}
			minDistSq = Math.min(minDistSq,hxGeomAlgo_PoleOfInaccessibility.getSegDistSq(x,y,a,b));
			++i;
			j = i - 1;
		}
	}
	return (inside ? 1 : -1) * Math.sqrt(minDistSq);
};
hxGeomAlgo_PoleOfInaccessibility.getCentroidCell = function(poly) {
	var area = 0.0;
	var x = 0.0;
	var y = 0.0;
	var points = poly[0];
	var i = 0;
	var len = points.length;
	var j = len - 1;
	while(i < len) {
		var a = points[i];
		var b = points[j];
		var f = a.x * b.y - b.x * a.y;
		x += (a.x + b.x) * f;
		y += (a.y + b.y) * f;
		area += f * 3;
		++i;
	}
	if(area == 0.0) {
		return new hxGeomAlgo__$PoleOfInaccessibility_Cell(points[0].x,points[0].y,0,poly);
	}
	return new hxGeomAlgo__$PoleOfInaccessibility_Cell(x / area,y / area,0,poly);
};
hxGeomAlgo_PoleOfInaccessibility.getSegDistSq = function(px,py,a,b) {
	var x = a.x;
	var y = a.y;
	var dx = b.x - x;
	var dy = b.y - y;
	if(dx != 0 || dy != 0) {
		var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);
		if(t > 1) {
			x = b.x;
			y = b.y;
		} else if(t > 0) {
			x += dx * t;
			y += dy * t;
		}
	}
	dx = px - x;
	dy = py - y;
	return dx * dx + dy * dy;
};
var hxGeomAlgo__$PoleOfInaccessibility_Cell = function(x,y,h,polygon) {
	this.x = x;
	this.y = y;
	this.h = h;
	this.d = hxGeomAlgo_PoleOfInaccessibility.pointToPolygonDist(x,y,polygon);
	this.max = this.d + this.h * hxGeomAlgo_PoleOfInaccessibility.SQRT2;
};
$hxClasses["hxGeomAlgo._PoleOfInaccessibility.Cell"] = hxGeomAlgo__$PoleOfInaccessibility_Cell;
hxGeomAlgo__$PoleOfInaccessibility_Cell.__name__ = "hxGeomAlgo._PoleOfInaccessibility.Cell";
hxGeomAlgo__$PoleOfInaccessibility_Cell.__interfaces__ = [hxGeomAlgo_Heapable];
hxGeomAlgo__$PoleOfInaccessibility_Cell.prototype = {
	position: null
	,x: null
	,y: null
	,h: null
	,d: null
	,max: null
	,compare: function(other) {
		var diff = other.max - this.max;
		if(diff < 0) {
			return -1;
		} else if(diff > 0) {
			return 1;
		} else {
			return 0;
		}
	}
	,__class__: hxGeomAlgo__$PoleOfInaccessibility_Cell
};
var hxGeomAlgo_RamerDouglasPeucker = $hx_exports["hxGeomAlgo"]["RamerDouglasPeucker"] = function() { };
$hxClasses["hxGeomAlgo.RamerDouglasPeucker"] = hxGeomAlgo_RamerDouglasPeucker;
hxGeomAlgo_RamerDouglasPeucker.__name__ = "hxGeomAlgo.RamerDouglasPeucker";
hxGeomAlgo_RamerDouglasPeucker.simplify = function(points,epsilon) {
	if(epsilon == null) {
		epsilon = 1;
	}
	var firstPoint = points[0];
	var lastPoint = points[points.length - 1];
	if(points.length < 2) {
		return [].concat(points);
	}
	var index = -1;
	var dist = 0.;
	var _g = 1;
	var _g1 = points.length - 1;
	while(_g < _g1) {
		var i = _g++;
		var currDist = Math.sqrt(hxGeomAlgo_PolyTools.distanceToSegmentSquared(points[i],firstPoint,lastPoint));
		if(currDist > dist) {
			dist = currDist;
			index = i;
		}
	}
	if(dist > epsilon) {
		var l1 = points.slice(0,index + 1);
		var l2 = points.slice(index);
		var r1 = hxGeomAlgo_RamerDouglasPeucker.simplify(l1,epsilon);
		var r2 = hxGeomAlgo_RamerDouglasPeucker.simplify(l2,epsilon);
		var rs = r1.slice(0,r1.length - 1).concat(r2);
		return rs;
	} else {
		return [firstPoint,lastPoint];
	}
};
var hxGeomAlgo_SnoeyinkKeil = $hx_exports["hxGeomAlgo"]["SnoeyinkKeil"] = function() { };
$hxClasses["hxGeomAlgo.SnoeyinkKeil"] = hxGeomAlgo_SnoeyinkKeil;
hxGeomAlgo_SnoeyinkKeil.__name__ = "hxGeomAlgo.SnoeyinkKeil";
hxGeomAlgo_SnoeyinkKeil.poly = null;
hxGeomAlgo_SnoeyinkKeil.reversed = null;
hxGeomAlgo_SnoeyinkKeil.diagonals = null;
hxGeomAlgo_SnoeyinkKeil.decomposePoly = function(simplePoly) {
	var res = [];
	var indices = hxGeomAlgo_SnoeyinkKeil.decomposePolyIndices(simplePoly);
	var _g = 0;
	while(_g < indices.length) {
		var polyIndices = indices[_g];
		++_g;
		var currPoly = [];
		res.push(currPoly);
		var _g1 = 0;
		while(_g1 < polyIndices.length) {
			var idx = polyIndices[_g1];
			++_g1;
			currPoly.push(simplePoly[idx]);
		}
	}
	return res;
};
hxGeomAlgo_SnoeyinkKeil.decomposePolyIndices = function(simplePoly) {
	var res = [];
	hxGeomAlgo_SnoeyinkKeil.diagonals = [];
	if(simplePoly.length < 3) {
		return res;
	}
	hxGeomAlgo_SnoeyinkKeil.poly = [];
	var _g = 0;
	while(_g < simplePoly.length) {
		var p = simplePoly[_g];
		++_g;
		hxGeomAlgo_SnoeyinkKeil.poly.push(hxGeomAlgo_HxPoint._new(p.x,p.y));
	}
	hxGeomAlgo_SnoeyinkKeil.reversed = hxGeomAlgo_PolyTools.makeCW(hxGeomAlgo_SnoeyinkKeil.poly);
	var i;
	var j;
	var k;
	var n = hxGeomAlgo_SnoeyinkKeil.poly.length;
	var decomp = new hxGeomAlgo_DecompPoly(hxGeomAlgo_SnoeyinkKeil.poly);
	decomp.init();
	var _g = 3;
	var _g1 = n;
	while(_g < _g1) {
		var l = _g++;
		i = decomp.reflexIter();
		while(i + l < n) {
			k = i + l;
			if(decomp.visible(i,k)) {
				decomp.initPairs(i,k);
				if(decomp.isReflex(k)) {
					var _g2 = i + 1;
					var _g3 = k;
					while(_g2 < _g3) {
						var j1 = _g2++;
						decomp.typeA(i,j1,k);
					}
				} else {
					j = decomp.reflexIter(i + 1);
					while(j < k - 1) {
						decomp.typeA(i,j,k);
						j = decomp.reflexNext(j);
					}
					decomp.typeA(i,k - 1,k);
				}
			}
			i = decomp.reflexNext(i);
		}
		k = decomp.reflexIter(l);
		while(k < n) {
			i = k - l;
			if(!decomp.isReflex(i) && decomp.visible(i,k)) {
				decomp.initPairs(i,k);
				decomp.typeB(i,i + 1,k);
				j = decomp.reflexIter(i + 2);
				while(j < k) {
					decomp.typeB(i,j,k);
					j = decomp.reflexNext(j);
				}
			}
			k = decomp.reflexNext(k);
		}
	}
	decomp.guard = 3 * n;
	decomp.recoverSolution(0,n - 1);
	res = decomp.decompIndices();
	if(hxGeomAlgo_SnoeyinkKeil.reversed) {
		var _g = 0;
		while(_g < res.length) {
			var poly = res[_g];
			++_g;
			var _g1 = 0;
			var _g2 = poly.length;
			while(_g1 < _g2) {
				var i = _g1++;
				poly[i] = n - poly[i] - 1;
			}
		}
		var _g = 0;
		var _g1 = hxGeomAlgo_SnoeyinkKeil.diagonals;
		while(_g < _g1.length) {
			var d = _g1[_g];
			++_g;
			var tmp = d.from;
			d.from = n - d.to - 1;
			d.to = n - tmp - 1;
		}
	}
	return res;
};
var hxGeomAlgo_DecompPoly = function(poly) {
	this._diags = [];
	this._polys = [];
	this._indicesSet = new haxe_ds_IntMap();
	this.poly = poly;
	this.n = poly.length;
};
$hxClasses["hxGeomAlgo.DecompPoly"] = hxGeomAlgo_DecompPoly;
hxGeomAlgo_DecompPoly.__name__ = "hxGeomAlgo.DecompPoly";
hxGeomAlgo_DecompPoly.prototype = {
	guard: null
	,poly: null
	,n: null
	,subDecomp: null
	,_reflexFirst: null
	,_reflexNext: null
	,_reflexFlag: null
	,_indicesSet: null
	,_polys: null
	,_diags: null
	,init: function() {
		this.initReflex();
		this.subDecomp = new hxGeomAlgo_SubDecomp(this._reflexFlag);
		this.initVisibility();
		this.initSubProblems();
	}
	,initReflex: function() {
		this._reflexFlag = [];
		this._reflexNext = [];
		var _g = 0;
		var _g1 = this.n;
		while(_g < _g1) {
			var i = _g++;
			this._reflexFlag[i] = false;
			this._reflexNext[i] = -1;
		}
		var wrap = 0;
		this._reflexFlag[wrap] = true;
		var i = this.n - 1;
		while(i > 0) {
			var poly = this.poly;
			var idx = i - 1;
			var idx1 = idx;
			var len = poly.length;
			if(idx1 < 0) {
				idx1 += len;
			}
			idx = idx1 % len;
			var p = poly[idx];
			var poly1 = this.poly;
			var idx2 = i;
			var idx3 = idx2;
			var len1 = poly1.length;
			if(idx3 < 0) {
				idx3 += len1;
			}
			idx2 = idx3 % len1;
			var a = poly1[idx2];
			var poly2 = this.poly;
			var idx4 = wrap;
			var idx5 = idx4;
			var len2 = poly2.length;
			if(idx5 < 0) {
				idx5 += len2;
			}
			idx4 = idx5 % len2;
			var b = poly2[idx4];
			this._reflexFlag[i] = (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) < 0;
			wrap = i;
			--i;
		}
		this._reflexFirst = this.n;
		i = this.n - 1;
		while(i >= 0) {
			this._reflexNext[i] = this._reflexFirst;
			if(this.isReflex(i)) {
				this._reflexFirst = i;
			}
			--i;
		}
	}
	,isReflex: function(i) {
		return this._reflexFlag[i];
	}
	,reflexNext: function(i) {
		return this._reflexNext[i];
	}
	,reflexIter: function(n) {
		if(n == null || n <= 0) {
			return this._reflexFirst;
		}
		if(n > this._reflexNext.length) {
			return this._reflexNext.length;
		}
		return this._reflexNext[n - 1];
	}
	,visible: function(i,j) {
		return this.subDecomp.weight(i,j) < hxGeomAlgo_DecompPoly.BAD;
	}
	,initVisibility: function() {
		var visIndices;
		var i = this.reflexIter();
		while(i < this.n) {
			visIndices = hxGeomAlgo_Visibility.getVisibleIndicesFrom(this.poly,i);
			while(visIndices.length > 0) {
				var j = visIndices.pop();
				if(j < i) {
					this.subDecomp.setWeight(j,i,hxGeomAlgo_DecompPoly.INFINITY);
				} else {
					this.subDecomp.setWeight(i,j,hxGeomAlgo_DecompPoly.INFINITY);
				}
			}
			i = this._reflexNext[i];
		}
	}
	,setAfter: function(i) {
		var cond = this.isReflex(i);
		this.subDecomp.setWeight(i,i + 1,0);
		if(this.visible(i,i + 2)) {
			this.subDecomp.initWithWeight(i,i + 2,0,i + 1,i + 1);
		}
	}
	,setBefore: function(i) {
		var cond = this.isReflex(i);
		this.subDecomp.setWeight(i - 1,i,0);
		if(this.visible(i - 2,i)) {
			this.subDecomp.initWithWeight(i - 2,i,0,i - 1,i - 1);
		}
	}
	,initSubProblems: function() {
		var i = this.reflexIter();
		if(i == 0) {
			this.setAfter(i);
			i = this._reflexNext[i];
		}
		if(i == 1) {
			this.subDecomp.setWeight(0,1,0);
			this.setAfter(i);
			i = this._reflexNext[i];
		}
		while(i < this.n - 2) {
			this.setBefore(i);
			this.setAfter(i);
			i = this._reflexNext[i];
		}
		if(i == this.n - 2) {
			this.setBefore(i);
			this.subDecomp.setWeight(i,i + 1,0);
			i = this._reflexNext[i];
		}
		if(i == this.n - 1) {
			this.setBefore(i);
		}
	}
	,initPairs: function(i,k) {
		this.subDecomp.init(i,k);
	}
	,recoverSolution: function(i,k) {
		var j;
		this.guard--;
		if(k - i <= 1) {
			return;
		}
		var pair = this.subDecomp.pairs(i,k);
		if(this.isReflex(i)) {
			j = pair.backTop();
			this.recoverSolution(j,k);
			if(j - i > 1) {
				if(pair.frontBottom() != pair.backTop()) {
					var pd = this.subDecomp.pairs(i,j);
					pd.restore();
					while(!pd.isBackEmpty() && pair.frontBottom() != pd.frontBottom()) pd.popBack();
				}
				this.recoverSolution(i,j);
			}
		} else {
			j = pair.frontTop();
			this.recoverSolution(i,j);
			if(k - j > 1) {
				if(pair.frontTop() != pair.backBottom()) {
					var pd = this.subDecomp.pairs(j,k);
					pd.restore();
					while(!pd.isFrontEmpty() && pair.backBottom() != pd.backBottom()) pd.popFront();
				}
				this.recoverSolution(j,k);
			}
		}
	}
	,typeA: function(i,j,k) {
		if(!this.visible(i,j)) {
			return;
		}
		var top = j;
		var w = this.subDecomp.weight(i,j);
		if(k - j > 1) {
			if(!this.visible(j,k)) {
				return;
			}
			w += this.subDecomp.weight(j,k) + 1;
		}
		if(j - i > 1) {
			var pair = this.subDecomp.pairs(i,j);
			var poly = this.poly;
			var idx = k;
			var idx1 = idx;
			var len = poly.length;
			if(idx1 < 0) {
				idx1 += len;
			}
			idx = idx1 % len;
			var p = poly[idx];
			var poly = this.poly;
			var idx = j;
			var idx1 = idx;
			var len = poly.length;
			if(idx1 < 0) {
				idx1 += len;
			}
			idx = idx1 % len;
			var a = poly[idx];
			var poly = this.poly;
			var idx = pair.backTop();
			var idx1 = idx;
			var len = poly.length;
			if(idx1 < 0) {
				idx1 += len;
			}
			idx = idx1 % len;
			var b = poly[idx];
			if(!((a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) > 0)) {
				while(true) {
					var tmp;
					if(pair.backHasNext()) {
						var poly = this.poly;
						var idx = k;
						var idx1 = idx;
						var len = poly.length;
						if(idx1 < 0) {
							idx1 += len;
						}
						idx = idx1 % len;
						var p = poly[idx];
						var poly1 = this.poly;
						var idx2 = j;
						var idx3 = idx2;
						var len1 = poly1.length;
						if(idx3 < 0) {
							idx3 += len1;
						}
						idx2 = idx3 % len1;
						var a = poly1[idx2];
						var poly2 = this.poly;
						var idx4 = pair.backPeekNext();
						var idx5 = idx4;
						var len2 = poly2.length;
						if(idx5 < 0) {
							idx5 += len2;
						}
						idx4 = idx5 % len2;
						var b = poly2[idx4];
						tmp = !((a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) > 0);
					} else {
						tmp = false;
					}
					if(!tmp) {
						break;
					}
					pair.popBack();
				}
				var tmp;
				if(!pair.isBackEmpty()) {
					var poly = this.poly;
					var idx = k;
					var idx1 = idx;
					var len = poly.length;
					if(idx1 < 0) {
						idx1 += len;
					}
					idx = idx1 % len;
					var p = poly[idx];
					var poly = this.poly;
					var idx = i;
					var idx1 = idx;
					var len = poly.length;
					if(idx1 < 0) {
						idx1 += len;
					}
					idx = idx1 % len;
					var a = poly[idx];
					var poly = this.poly;
					var idx = pair.frontBottom();
					var idx1 = idx;
					var len = poly.length;
					if(idx1 < 0) {
						idx1 += len;
					}
					idx = idx1 % len;
					var b = poly[idx];
					tmp = !((a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) < 0);
				} else {
					tmp = false;
				}
				if(tmp) {
					top = pair.frontBottom();
				} else {
					++w;
				}
			} else {
				++w;
			}
		}
		this.update(i,k,w,top,j);
	}
	,typeB: function(i,j,k) {
		if(!this.visible(j,k)) {
			return;
		}
		var top = j;
		var w = this.subDecomp.weight(j,k);
		if(j - i > 1) {
			if(!this.visible(i,j)) {
				return;
			}
			w += this.subDecomp.weight(i,j) + 1;
		}
		if(k - j > 1) {
			var pair = this.subDecomp.pairs(j,k);
			var poly = this.poly;
			var idx = i;
			var idx1 = idx;
			var len = poly.length;
			if(idx1 < 0) {
				idx1 += len;
			}
			idx = idx1 % len;
			var p = poly[idx];
			var poly = this.poly;
			var idx = j;
			var idx1 = idx;
			var len = poly.length;
			if(idx1 < 0) {
				idx1 += len;
			}
			idx = idx1 % len;
			var a = poly[idx];
			var poly = this.poly;
			var idx = pair.frontTop();
			var idx1 = idx;
			var len = poly.length;
			if(idx1 < 0) {
				idx1 += len;
			}
			idx = idx1 % len;
			var b = poly[idx];
			if(!((a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) < 0)) {
				while(true) {
					var tmp;
					if(pair.frontHasNext()) {
						var poly = this.poly;
						var idx = i;
						var idx1 = idx;
						var len = poly.length;
						if(idx1 < 0) {
							idx1 += len;
						}
						idx = idx1 % len;
						var p = poly[idx];
						var poly1 = this.poly;
						var idx2 = j;
						var idx3 = idx2;
						var len1 = poly1.length;
						if(idx3 < 0) {
							idx3 += len1;
						}
						idx2 = idx3 % len1;
						var a = poly1[idx2];
						var poly2 = this.poly;
						var idx4 = pair.frontPeekNext();
						var idx5 = idx4;
						var len2 = poly2.length;
						if(idx5 < 0) {
							idx5 += len2;
						}
						idx4 = idx5 % len2;
						var b = poly2[idx4];
						tmp = !((a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) < 0);
					} else {
						tmp = false;
					}
					if(!tmp) {
						break;
					}
					pair.popFront();
				}
				var tmp;
				if(!pair.isFrontEmpty()) {
					var poly = this.poly;
					var idx = i;
					var idx1 = idx;
					var len = poly.length;
					if(idx1 < 0) {
						idx1 += len;
					}
					idx = idx1 % len;
					var p = poly[idx];
					var poly = this.poly;
					var idx = k;
					var idx1 = idx;
					var len = poly.length;
					if(idx1 < 0) {
						idx1 += len;
					}
					idx = idx1 % len;
					var a = poly[idx];
					var poly = this.poly;
					var idx = pair.backBottom();
					var idx1 = idx;
					var len = poly.length;
					if(idx1 < 0) {
						idx1 += len;
					}
					idx = idx1 % len;
					var b = poly[idx];
					tmp = !((a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) > 0);
				} else {
					tmp = false;
				}
				if(tmp) {
					top = pair.backBottom();
				} else {
					++w;
				}
			} else {
				++w;
			}
		}
		this.update(i,k,w,j,top);
	}
	,update: function(a,b,w,i,j) {
		var ow = this.subDecomp.weight(a,b);
		if(w <= ow) {
			var pair = this.subDecomp.pairs(a,b);
			if(w < ow) {
				pair.flush();
				this.subDecomp.setWeight(a,b,w);
			}
			pair.pushNarrow(i,j);
		}
	}
	,_decompByDiags: function(i,k,outIndices,level) {
		if(level == null) {
			level = 0;
		}
		if(level == 0) {
			this._indicesSet.h[0] = true;
			this._indicesSet.h[this.poly.length - 1] = true;
		}
		var j;
		var ijReal = true;
		var jkReal = true;
		var nDiags = 0;
		if(k - i <= 1) {
			return;
		}
		var pair = this.subDecomp.pairs(i,k);
		if(this.isReflex(i)) {
			j = pair.backTop();
			ijReal = pair.frontBottom() == pair.backTop();
		} else {
			j = pair.frontTop();
			jkReal = pair.backBottom() == pair.frontTop();
		}
		if(ijReal) {
			this._indicesSet.h[i] = true;
			this._indicesSet.h[j] = true;
			this._diags.push({ from : i, to : j});
			++nDiags;
		}
		if(jkReal) {
			this._indicesSet.h[j] = true;
			this._indicesSet.h[k] = true;
			this._diags.push({ from : j, to : k});
			++nDiags;
		}
		this.guard--;
		if(nDiags > 1) {
			var _g = [];
			var k1 = this._indicesSet.keys();
			while(k1.hasNext()) {
				var k2 = k1.next();
				_g.push(k2);
			}
			var indices = _g;
			indices.sort($bind(this,this.intCmp));
			if(indices.length > 0) {
				outIndices.push(indices);
				this._indicesSet = new haxe_ds_IntMap();
			}
		}
		if(ijReal && j - i > 1) {
			this._decompByDiags(j,k,outIndices,level + 1);
			this._decompByDiags(i,j,outIndices,level + 1);
		} else {
			this._decompByDiags(i,j,outIndices,level + 1);
			this._decompByDiags(j,k,outIndices,level + 1);
		}
	}
	,intCmp: function(a,b) {
		if(a == b) {
			return 0;
		} else if(b < a) {
			return 1;
		} else {
			return -1;
		}
	}
	,decompIndices: function() {
		var res = [];
		this.guard = 3 * this.n;
		this._decompByDiags(0,this.poly.length - 1,res);
		hxGeomAlgo_SnoeyinkKeil.diagonals = this._diags;
		return res;
	}
	,toString: function() {
		return this.poly.length + ": " + this.poly.toString();
	}
	,__class__: hxGeomAlgo_DecompPoly
};
var hxGeomAlgo_SubDecomp = function(reflex) {
	var n = reflex.length;
	var r = 0;
	this.rx = [];
	var _g = 0;
	var _g1 = n;
	while(_g < _g1) {
		var i = _g++;
		var tmp;
		if(reflex[i]) {
			++r;
			tmp = r - 1;
		} else {
			tmp = 0;
		}
		this.rx[i] = tmp;
	}
	var j = r;
	this.wt = [];
	this.pd = [];
	var _g = 0;
	var _g1 = n;
	while(_g < _g1) {
		var i = _g++;
		if(!reflex[i]) {
			this.rx[i] = j++;
		}
		this.wt[i] = [];
		this.pd[i] = [];
		var _g2 = 0;
		var _g3 = n;
		while(_g2 < _g3) {
			var k = _g2++;
			if(i < r || k < r) {
				this.wt[i][k] = hxGeomAlgo_DecompPoly.BAD;
				this.pd[i][k] = null;
			} else {
				break;
			}
		}
	}
};
$hxClasses["hxGeomAlgo.SubDecomp"] = hxGeomAlgo_SubDecomp;
hxGeomAlgo_SubDecomp.__name__ = "hxGeomAlgo.SubDecomp";
hxGeomAlgo_SubDecomp.prototype = {
	wt: null
	,pd: null
	,rx: null
	,setWeight: function(i,j,w) {
		this.wt[this.rx[i]][this.rx[j]] = w;
	}
	,weight: function(i,j) {
		return this.wt[this.rx[i]][this.rx[j]];
	}
	,pairs: function(i,j) {
		return this.pd[this.rx[i]][this.rx[j]];
	}
	,init: function(i,j) {
		return this.pd[this.rx[i]][this.rx[j]] = new hxGeomAlgo_PairDeque();
	}
	,initWithWeight: function(i,j,w,a,b) {
		this.setWeight(i,j,w);
		this.init(i,j).push(a,b);
	}
	,__class__: hxGeomAlgo_SubDecomp
};
var hxGeomAlgo_WindingRule = $hxEnums["hxGeomAlgo.WindingRule"] = { __ename__ : "hxGeomAlgo.WindingRule", __constructs__ : ["ODD","NON_ZERO","POSITIVE","NEGATIVE","ABS_GEQ_TWO"]
	,ODD: {_hx_index:0,__enum__:"hxGeomAlgo.WindingRule",toString:$estr}
	,NON_ZERO: {_hx_index:1,__enum__:"hxGeomAlgo.WindingRule",toString:$estr}
	,POSITIVE: {_hx_index:2,__enum__:"hxGeomAlgo.WindingRule",toString:$estr}
	,NEGATIVE: {_hx_index:3,__enum__:"hxGeomAlgo.WindingRule",toString:$estr}
	,ABS_GEQ_TWO: {_hx_index:4,__enum__:"hxGeomAlgo.WindingRule",toString:$estr}
};
hxGeomAlgo_WindingRule.__empty_constructs__ = [hxGeomAlgo_WindingRule.ODD,hxGeomAlgo_WindingRule.NON_ZERO,hxGeomAlgo_WindingRule.POSITIVE,hxGeomAlgo_WindingRule.NEGATIVE,hxGeomAlgo_WindingRule.ABS_GEQ_TWO];
var hxGeomAlgo_ResultType = $hxEnums["hxGeomAlgo.ResultType"] = { __ename__ : "hxGeomAlgo.ResultType", __constructs__ : ["POLYGONS","CONNECTED_POLYGONS","BOUNDARY_CONTOURS","EXPERIMENTAL_DELAUNAY"]
	,POLYGONS: {_hx_index:0,__enum__:"hxGeomAlgo.ResultType",toString:$estr}
	,CONNECTED_POLYGONS: {_hx_index:1,__enum__:"hxGeomAlgo.ResultType",toString:$estr}
	,BOUNDARY_CONTOURS: {_hx_index:2,__enum__:"hxGeomAlgo.ResultType",toString:$estr}
	,EXPERIMENTAL_DELAUNAY: {_hx_index:3,__enum__:"hxGeomAlgo.ResultType",toString:$estr}
};
hxGeomAlgo_ResultType.__empty_constructs__ = [hxGeomAlgo_ResultType.POLYGONS,hxGeomAlgo_ResultType.CONNECTED_POLYGONS,hxGeomAlgo_ResultType.BOUNDARY_CONTOURS,hxGeomAlgo_ResultType.EXPERIMENTAL_DELAUNAY];
var hxGeomAlgo_Tess2 = $hx_exports["hxGeomAlgo"]["Tess2"] = function() { };
$hxClasses["hxGeomAlgo.Tess2"] = hxGeomAlgo_Tess2;
hxGeomAlgo_Tess2.__name__ = "hxGeomAlgo.Tess2";
hxGeomAlgo_Tess2.tesselate = function(contours,windingRule,resultType,polySize,vertexDim,normal) {
	if(vertexDim == null) {
		vertexDim = 2;
	}
	if(polySize == null) {
		polySize = 3;
	}
	var tess = new hxGeomAlgo_Tesselator();
	var _g = 0;
	var _g1 = contours.length;
	while(_g < _g1) {
		var i = _g++;
		tess.addContour(vertexDim,contours[i]);
	}
	tess.tesselate(windingRule == null ? hxGeomAlgo_WindingRule.ODD : windingRule,resultType == null ? hxGeomAlgo_ResultType.POLYGONS : resultType,polySize,vertexDim,normal == null ? [0,0,1] : normal);
	return { vertices : tess.vertices, vertexIndices : tess.vertexIndices, vertexCount : tess.vertexCount, elements : tess.elements, elementCount : tess.elementCount};
};
hxGeomAlgo_Tess2.union = function(contoursA,contoursB,resultType,polySize,vertexDim) {
	if(vertexDim == null) {
		vertexDim = 2;
	}
	if(polySize == null) {
		polySize = 3;
	}
	var contours = contoursA.concat(contoursB);
	return hxGeomAlgo_Tess2.tesselate(contours,hxGeomAlgo_WindingRule.NON_ZERO,resultType,polySize,vertexDim);
};
hxGeomAlgo_Tess2.intersection = function(contoursA,contoursB,resultType,polySize,vertexDim) {
	if(vertexDim == null) {
		vertexDim = 2;
	}
	if(polySize == null) {
		polySize = 3;
	}
	var contours = contoursA.concat(contoursB);
	return hxGeomAlgo_Tess2.tesselate(contours,hxGeomAlgo_WindingRule.ABS_GEQ_TWO,resultType,polySize,vertexDim);
};
hxGeomAlgo_Tess2.difference = function(contoursA,contoursB,resultType,polySize,vertexDim) {
	if(vertexDim == null) {
		vertexDim = 2;
	}
	if(polySize == null) {
		polySize = 3;
	}
	var _g = [];
	var _g1 = 0;
	while(_g1 < contoursB.length) {
		var poly = contoursB[_g1];
		++_g1;
		_g.push(hxGeomAlgo_PolyTools.reverseFloatArray(poly));
	}
	var diffB = _g;
	var contours = contoursA.concat(diffB);
	return hxGeomAlgo_Tess2.tesselate(contours,hxGeomAlgo_WindingRule.POSITIVE,resultType,polySize,vertexDim);
};
hxGeomAlgo_Tess2.convertResult = function(vertices,elements,resultType,polySize,out) {
	if(out == null) {
		out = [];
	}
	var tmp = resultType._hx_index != 2;
	var i = 0;
	switch(resultType._hx_index) {
	case 0:case 3:
		while(i < elements.length) {
			var poly = [];
			var _g = 0;
			var _g1 = polySize;
			while(_g < _g1) {
				var j = _g++;
				var idx = elements[i + j];
				if(idx == -1) {
					continue;
				}
				poly.push(hxGeomAlgo_HxPoint._new(vertices[idx * 2],vertices[idx * 2 + 1]));
			}
			out.push(poly);
			i += polySize;
		}
		break;
	case 1:
		while(i < elements.length) {
			var poly = [];
			var _g = 0;
			var _g1 = polySize;
			while(_g < _g1) {
				var j = _g++;
				var idx = elements[i + j];
				if(idx == -1) {
					continue;
				}
				poly.push(hxGeomAlgo_HxPoint._new(vertices[idx * 2],vertices[idx * 2 + 1]));
			}
			out.push(poly);
			i += polySize * 2;
		}
		break;
	case 2:
		while(i < elements.length) {
			var poly = [];
			var start = elements[i];
			var count = elements[i + 1];
			var _g = 0;
			var _g1 = count;
			while(_g < _g1) {
				var j = _g++;
				var idx = start + j;
				poly.push(hxGeomAlgo_HxPoint._new(vertices[idx * 2],vertices[idx * 2 + 1]));
			}
			out.push(poly);
			i += 2;
		}
		break;
	}
	return out;
};
var hxGeomAlgo__$Tess2_TessVertex = function() {
	this.idx = 0;
	this.n = 0;
	this.pqHandle = 0;
	this.t = 0.0;
	this.s = 0.0;
	this.coords = [0,0,0];
	this.anEdge = null;
	this.prev = null;
	this.next = null;
};
$hxClasses["hxGeomAlgo._Tess2.TessVertex"] = hxGeomAlgo__$Tess2_TessVertex;
hxGeomAlgo__$Tess2_TessVertex.__name__ = "hxGeomAlgo._Tess2.TessVertex";
hxGeomAlgo__$Tess2_TessVertex.prototype = {
	next: null
	,prev: null
	,anEdge: null
	,coords: null
	,s: null
	,t: null
	,pqHandle: null
	,n: null
	,idx: null
	,__class__: hxGeomAlgo__$Tess2_TessVertex
};
var hxGeomAlgo__$Tess2_TessFace = function() {
	this.inside = false;
	this.marked = false;
	this.n = 0;
	this.trail = null;
	this.anEdge = null;
	this.prev = null;
	this.next = null;
};
$hxClasses["hxGeomAlgo._Tess2.TessFace"] = hxGeomAlgo__$Tess2_TessFace;
hxGeomAlgo__$Tess2_TessFace.__name__ = "hxGeomAlgo._Tess2.TessFace";
hxGeomAlgo__$Tess2_TessFace.prototype = {
	next: null
	,prev: null
	,anEdge: null
	,trail: null
	,n: null
	,marked: null
	,inside: null
	,__class__: hxGeomAlgo__$Tess2_TessFace
};
var hxGeomAlgo__$Tess2_TessHalfEdge = function(side) {
	this.winding = 0;
	this.activeRegion = null;
	this.Lface = null;
	this.Org = null;
	this.Lnext = null;
	this.Onext = null;
	this.Sym = null;
	this.next = null;
	this.side = side;
};
$hxClasses["hxGeomAlgo._Tess2.TessHalfEdge"] = hxGeomAlgo__$Tess2_TessHalfEdge;
hxGeomAlgo__$Tess2_TessHalfEdge.__name__ = "hxGeomAlgo._Tess2.TessHalfEdge";
hxGeomAlgo__$Tess2_TessHalfEdge.prototype = {
	next: null
	,Sym: null
	,Onext: null
	,Lnext: null
	,Org: null
	,Lface: null
	,activeRegion: null
	,winding: null
	,side: null
	,mark: null
	,get_Rface: function() {
		return this.Sym.Lface;
	}
	,set_Rface: function(v) {
		return this.Sym.Lface = v;
	}
	,get_Dst: function() {
		return this.Sym.Org;
	}
	,set_Dst: function(v) {
		return this.Sym.Org = v;
	}
	,get_Oprev: function() {
		return this.Sym.Lnext;
	}
	,set_Oprev: function(v) {
		return this.Sym.Lnext = v;
	}
	,get_Lprev: function() {
		return this.Onext.Sym;
	}
	,set_Lprev: function(v) {
		return this.Onext.Sym = v;
	}
	,get_Dprev: function() {
		return this.Lnext.Sym;
	}
	,set_Dprev: function(v) {
		return this.Lnext.Sym = v;
	}
	,get_Rprev: function() {
		return this.Sym.Onext;
	}
	,set_Rprev: function(v) {
		return this.Sym.Onext = v;
	}
	,get_Dnext: function() {
		return this.Sym.Onext.Sym;
	}
	,set_Dnext: function(v) {
		return this.Sym.Onext.Sym = v;
	}
	,get_Rnext: function() {
		return this.Sym.Lnext.Sym;
	}
	,set_Rnext: function(v) {
		return this.Sym.Lnext.Sym = v;
	}
	,__class__: hxGeomAlgo__$Tess2_TessHalfEdge
	,__properties__: {set_Rnext:"set_Rnext",get_Rnext:"get_Rnext",set_Dnext:"set_Dnext",get_Dnext:"get_Dnext",set_Rprev:"set_Rprev",get_Rprev:"get_Rprev",set_Dprev:"set_Dprev",get_Dprev:"get_Dprev",set_Lprev:"set_Lprev",get_Lprev:"get_Lprev",set_Oprev:"set_Oprev",get_Oprev:"get_Oprev",set_Dst:"set_Dst",get_Dst:"get_Dst",set_Rface:"set_Rface",get_Rface:"get_Rface"}
};
var hxGeomAlgo__$Tess2_TessMesh = function() {
	this.eSym = new hxGeomAlgo__$Tess2_TessHalfEdge(1);
	this.e = new hxGeomAlgo__$Tess2_TessHalfEdge(0);
	this.f = new hxGeomAlgo__$Tess2_TessFace();
	this.v = new hxGeomAlgo__$Tess2_TessVertex();
	this.v.next = this.v.prev = this.v;
	this.v.anEdge = null;
	this.f.next = this.f.prev = this.f;
	this.f.anEdge = null;
	this.f.trail = null;
	this.f.marked = false;
	this.f.inside = false;
	this.e.next = this.e;
	this.e.Sym = this.eSym;
	this.e.Onext = null;
	this.e.Lnext = null;
	this.e.Org = null;
	this.e.Lface = null;
	this.e.winding = 0;
	this.e.activeRegion = null;
	this.e.mark = false;
	this.eSym.next = this.eSym;
	this.eSym.Sym = this.e;
	this.eSym.Onext = null;
	this.eSym.Lnext = null;
	this.eSym.Org = null;
	this.eSym.Lface = null;
	this.eSym.winding = 0;
	this.eSym.activeRegion = null;
	this.e.Sym.mark = false;
	this.vHead = this.v;
	this.fHead = this.f;
	this.eHead = this.e;
	this.eHeadSym = this.eSym;
};
$hxClasses["hxGeomAlgo._Tess2.TessMesh"] = hxGeomAlgo__$Tess2_TessMesh;
hxGeomAlgo__$Tess2_TessMesh.__name__ = "hxGeomAlgo._Tess2.TessMesh";
hxGeomAlgo__$Tess2_TessMesh.flipEdge = function(mesh,edge) {
	var a0 = edge;
	var a1 = a0.Lnext;
	var a2 = a1.Lnext;
	var b0 = edge.Sym;
	var b1 = b0.Lnext;
	var b2 = b1.Lnext;
	var aOrg = a0.Org;
	var aOpp = a2.Org;
	var bOrg = b0.Org;
	var bOpp = b2.Org;
	var fa = a0.Lface;
	var fb = b0.Lface;
	var cond = hxGeomAlgo__$Tess2_Geom.edgeIsInternal(edge);
	a0.Org = bOpp;
	a0.Onext = b1.Sym;
	b0.Org = aOpp;
	b0.Onext = a1.Sym;
	a2.Onext = b0;
	b2.Onext = a0;
	b1.Onext = a2.Sym;
	a1.Onext = b2.Sym;
	a0.Lnext = a2;
	a2.Lnext = b1;
	b1.Lnext = a0;
	b0.Lnext = b2;
	b2.Lnext = a1;
	a1.Lnext = b0;
	a1.Lface = fb;
	b1.Lface = fa;
	fa.anEdge = a0;
	fb.anEdge = b0;
	if(aOrg.anEdge == a0) {
		aOrg.anEdge = b1;
	}
	if(bOrg.anEdge == b0) {
		bOrg.anEdge = a1;
	}
	var cond = a0.get_Oprev().Onext.Org == a0.Org;
};
hxGeomAlgo__$Tess2_TessMesh.prototype = {
	v: null
	,f: null
	,e: null
	,eSym: null
	,vHead: null
	,fHead: null
	,eHead: null
	,eHeadSym: null
	,makeEdge_: function(eNext) {
		var e = new hxGeomAlgo__$Tess2_TessHalfEdge(0);
		var eSym = new hxGeomAlgo__$Tess2_TessHalfEdge(1);
		if(eNext.Sym.side < eNext.side) {
			eNext = eNext.Sym;
		}
		var ePrev = eNext.Sym.next;
		eSym.next = ePrev;
		ePrev.Sym.next = e;
		e.next = eNext;
		eNext.Sym.next = eSym;
		e.Sym = eSym;
		e.Onext = e;
		e.Lnext = eSym;
		e.Org = null;
		e.Lface = null;
		e.winding = 0;
		e.activeRegion = null;
		eSym.Sym = e;
		eSym.Onext = eSym;
		eSym.Lnext = e;
		eSym.Org = null;
		eSym.Lface = null;
		eSym.winding = 0;
		eSym.activeRegion = null;
		return e;
	}
	,splice_: function(a,b) {
		var aOnext = a.Onext;
		var bOnext = b.Onext;
		aOnext.Sym.Lnext = b;
		bOnext.Sym.Lnext = a;
		a.Onext = bOnext;
		b.Onext = aOnext;
	}
	,makeVertex_: function(newVertex,eOrig,vNext) {
		var vNew = newVertex;
		var vPrev = vNext.prev;
		vNew.prev = vPrev;
		vPrev.next = vNew;
		vNew.next = vNext;
		vNext.prev = vNew;
		vNew.anEdge = eOrig;
		var e = eOrig;
		while(true) {
			e.Org = vNew;
			e = e.Onext;
			if(!(e != eOrig)) {
				break;
			}
		}
	}
	,makeFace_: function(newFace,eOrig,fNext) {
		var fNew = newFace;
		var fPrev = fNext.prev;
		fNew.prev = fPrev;
		fPrev.next = fNew;
		fNew.next = fNext;
		fNext.prev = fNew;
		fNew.anEdge = eOrig;
		fNew.trail = null;
		fNew.marked = false;
		fNew.inside = fNext.inside;
		var e = eOrig;
		while(true) {
			e.Lface = fNew;
			e = e.Lnext;
			if(!(e != eOrig)) {
				break;
			}
		}
	}
	,killEdge_: function(eDel) {
		if(eDel.Sym.side < eDel.side) {
			eDel = eDel.Sym;
		}
		var eNext = eDel.next;
		var ePrev = eDel.Sym.next;
		eNext.Sym.next = ePrev;
		ePrev.Sym.next = eNext;
	}
	,killVertex_: function(vDel,newOrg) {
		var eStart = vDel.anEdge;
		var e = eStart;
		while(true) {
			e.Org = newOrg;
			e = e.Onext;
			if(!(e != eStart)) {
				break;
			}
		}
		var vPrev = vDel.prev;
		var vNext = vDel.next;
		vNext.prev = vPrev;
		vPrev.next = vNext;
	}
	,killFace_: function(fDel,newLface) {
		var eStart = fDel.anEdge;
		var e = eStart;
		while(true) {
			e.Lface = newLface;
			e = e.Lnext;
			if(!(e != eStart)) {
				break;
			}
		}
		var fPrev = fDel.prev;
		var fNext = fDel.next;
		fNext.prev = fPrev;
		fPrev.next = fNext;
	}
	,makeEdge: function() {
		var newVertex1 = new hxGeomAlgo__$Tess2_TessVertex();
		var newVertex2 = new hxGeomAlgo__$Tess2_TessVertex();
		var newFace = new hxGeomAlgo__$Tess2_TessFace();
		var e = this.makeEdge_(this.eHead);
		this.makeVertex_(newVertex1,e,this.vHead);
		this.makeVertex_(newVertex2,e.Sym,this.vHead);
		this.makeFace_(newFace,e,this.fHead);
		return e;
	}
	,splice: function(eOrg,eDst) {
		var joiningLoops = false;
		var joiningVertices = false;
		if(eOrg == eDst) {
			return;
		}
		if(eDst.Org != eOrg.Org) {
			joiningVertices = true;
			this.killVertex_(eDst.Org,eOrg.Org);
		}
		if(eDst.Lface != eOrg.Lface) {
			joiningLoops = true;
			this.killFace_(eDst.Lface,eOrg.Lface);
		}
		this.splice_(eDst,eOrg);
		if(!joiningVertices) {
			var newVertex = new hxGeomAlgo__$Tess2_TessVertex();
			this.makeVertex_(newVertex,eDst,eOrg.Org);
			eOrg.Org.anEdge = eOrg;
		}
		if(!joiningLoops) {
			var newFace = new hxGeomAlgo__$Tess2_TessFace();
			this.makeFace_(newFace,eDst,eOrg.Lface);
			eOrg.Lface.anEdge = eOrg;
		}
	}
	,'delete': function(eDel) {
		var eDelSym = eDel.Sym;
		var joiningLoops = false;
		if(eDel.Lface != eDel.get_Rface()) {
			joiningLoops = true;
			this.killFace_(eDel.Lface,eDel.get_Rface());
		}
		if(eDel.Onext == eDel) {
			this.killVertex_(eDel.Org,null);
		} else {
			eDel.get_Rface().anEdge = eDel.get_Oprev();
			eDel.Org.anEdge = eDel.Onext;
			this.splice_(eDel,eDel.get_Oprev());
			if(!joiningLoops) {
				var newFace = new hxGeomAlgo__$Tess2_TessFace();
				this.makeFace_(newFace,eDel,eDel.Lface);
			}
		}
		if(eDelSym.Onext == eDelSym) {
			this.killVertex_(eDelSym.Org,null);
			this.killFace_(eDelSym.Lface,null);
		} else {
			eDel.Lface.anEdge = eDelSym.get_Oprev();
			eDelSym.Org.anEdge = eDelSym.Onext;
			this.splice_(eDelSym,eDelSym.get_Oprev());
		}
		this.killEdge_(eDel);
	}
	,addEdgeVertex: function(eOrg) {
		var eNew = this.makeEdge_(eOrg);
		var eNewSym = eNew.Sym;
		this.splice_(eNew,eOrg.Lnext);
		eNew.Org = eOrg.get_Dst();
		var newVertex = new hxGeomAlgo__$Tess2_TessVertex();
		this.makeVertex_(newVertex,eNewSym,eNew.Org);
		eNew.Lface = eNewSym.Lface = eOrg.Lface;
		return eNew;
	}
	,splitEdge: function(eOrg) {
		var tempHalfEdge = this.addEdgeVertex(eOrg);
		var eNew = tempHalfEdge.Sym;
		this.splice_(eOrg.Sym,eOrg.Sym.get_Oprev());
		this.splice_(eOrg.Sym,eNew);
		eOrg.set_Dst(eNew.Org);
		eNew.get_Dst().anEdge = eNew.Sym;
		eNew.set_Rface(eOrg.get_Rface());
		eNew.winding = eOrg.winding;
		eNew.Sym.winding = eOrg.Sym.winding;
		return eNew;
	}
	,connect: function(eOrg,eDst) {
		var joiningLoops = false;
		var eNew = this.makeEdge_(eOrg);
		var eNewSym = eNew.Sym;
		if(eDst.Lface != eOrg.Lface) {
			joiningLoops = true;
			this.killFace_(eDst.Lface,eOrg.Lface);
		}
		this.splice_(eNew,eOrg.Lnext);
		this.splice_(eNewSym,eDst);
		eNew.Org = eOrg.get_Dst();
		eNewSym.Org = eDst.Org;
		eNew.Lface = eNewSym.Lface = eOrg.Lface;
		eOrg.Lface.anEdge = eNewSym;
		if(!joiningLoops) {
			var newFace = new hxGeomAlgo__$Tess2_TessFace();
			this.makeFace_(newFace,eNew,eOrg.Lface);
		}
		return eNew;
	}
	,zapFace: function(fZap) {
		var eStart = fZap.anEdge;
		var e;
		var eSym;
		var eNext = eStart.Lnext;
		while(true) {
			e = eNext;
			eNext = e.Lnext;
			e.Lface = null;
			if(e.get_Rface() == null) {
				if(e.Onext == e) {
					this.killVertex_(e.Org,null);
				} else {
					e.Org.anEdge = e.Onext;
					this.splice_(e,e.get_Oprev());
				}
				eSym = e.Sym;
				if(eSym.Onext == eSym) {
					this.killVertex_(eSym.Org,null);
				} else {
					eSym.Org.anEdge = eSym.Onext;
					this.splice_(eSym,eSym.get_Oprev());
				}
				this.killEdge_(e);
			}
			if(!(e != eStart)) {
				break;
			}
		}
		var fPrev = fZap.prev;
		var fNext = fZap.next;
		fNext.prev = fPrev;
		fPrev.next = fNext;
	}
	,countFaceVerts_: function(f) {
		var eCur = f.anEdge;
		var n = 0;
		while(true) {
			++n;
			eCur = eCur.Lnext;
			if(!(eCur != f.anEdge)) {
				break;
			}
		}
		return n;
	}
	,mergeConvexFaces: function(maxVertsPerFace) {
		var eCur;
		var eNext;
		var eSym;
		var vStart;
		var curNv;
		var symNv;
		var f = this.fHead.next;
		while(f != this.fHead) {
			if(!f.inside) {
				f = f.next;
				continue;
			}
			eCur = f.anEdge;
			vStart = eCur.Org;
			while(true) {
				eNext = eCur.Lnext;
				eSym = eCur.Sym;
				if(eSym != null && eSym.Lface != null && eSym.Lface.inside) {
					curNv = this.countFaceVerts_(f);
					symNv = this.countFaceVerts_(eSym.Lface);
					if(curNv + symNv - 2 <= maxVertsPerFace) {
						if(hxGeomAlgo__$Tess2_Geom.vertCCW(eCur.get_Lprev().Org,eCur.Org,eSym.Lnext.Lnext.Org) && hxGeomAlgo__$Tess2_Geom.vertCCW(eSym.get_Lprev().Org,eSym.Org,eCur.Lnext.Lnext.Org)) {
							eNext = eSym.Lnext;
							this.delete(eSym);
							eCur = null;
							eSym = null;
						}
					}
				}
				if(eCur != null && eCur.Lnext.Org == vStart) {
					break;
				}
				eCur = eNext;
			}
			f = f.next;
		}
		return true;
	}
	,check: function() {
		var fHead = this.fHead;
		var vHead = this.vHead;
		var eHead = this.eHead;
		var f;
		var v;
		var e;
		var fPrev = fHead;
		while(true) {
			f = fPrev.next;
			if(!(f != fHead)) {
				break;
			}
			e = f.anEdge;
			while(true) {
				e = e.Lnext;
				if(!(e != f.anEdge)) {
					break;
				}
			}
			fPrev = f;
		}
		var vPrev = vHead;
		while(true) {
			v = vPrev.next;
			if(!(v != vHead)) {
				break;
			}
			e = v.anEdge;
			while(true) {
				e = e.Onext;
				if(!(e != v.anEdge)) {
					break;
				}
			}
			vPrev = v;
		}
		var ePrev = eHead;
		while(true) {
			e = ePrev.next;
			if(!(e != eHead)) {
				break;
			}
			var cond = e.get_Dst() != null;
			ePrev = e;
		}
		var cond = e.Sym.next == ePrev.Sym && e.Sym == this.eHeadSym && e.Sym.Sym == e && e.Org == null && e.get_Dst() == null && e.Lface == null && e.get_Rface() == null;
	}
	,__class__: hxGeomAlgo__$Tess2_TessMesh
};
var hxGeomAlgo__$Tess2_Geom = function() { };
$hxClasses["hxGeomAlgo._Tess2.Geom"] = hxGeomAlgo__$Tess2_Geom;
hxGeomAlgo__$Tess2_Geom.__name__ = "hxGeomAlgo._Tess2.Geom";
hxGeomAlgo__$Tess2_Geom.vertEq = function(u,v) {
	if(u.s == v.s) {
		return u.t == v.t;
	} else {
		return false;
	}
};
hxGeomAlgo__$Tess2_Geom.vertLeq = function(u,v) {
	if(!(u.s < v.s)) {
		if(u.s == v.s) {
			return u.t <= v.t;
		} else {
			return false;
		}
	} else {
		return true;
	}
};
hxGeomAlgo__$Tess2_Geom.transLeq = function(u,v) {
	if(!(u.t < v.t)) {
		if(u.t == v.t) {
			return u.s <= v.s;
		} else {
			return false;
		}
	} else {
		return true;
	}
};
hxGeomAlgo__$Tess2_Geom.edgeGoesLeft = function(e) {
	return hxGeomAlgo__$Tess2_Geom.vertLeq(e.get_Dst(),e.Org);
};
hxGeomAlgo__$Tess2_Geom.edgeGoesRight = function(e) {
	return hxGeomAlgo__$Tess2_Geom.vertLeq(e.Org,e.get_Dst());
};
hxGeomAlgo__$Tess2_Geom.edgeIsInternal = function(e) {
	if(e.get_Rface() != null) {
		return e.get_Rface().inside;
	} else {
		return false;
	}
};
hxGeomAlgo__$Tess2_Geom.vertL1dist = function(u,v) {
	return Math.abs(u.s - v.s) + Math.abs(u.t - v.t);
};
hxGeomAlgo__$Tess2_Geom.edgeEval = function(u,v,w) {
	var cond = hxGeomAlgo__$Tess2_Geom.vertLeq(u,v) && hxGeomAlgo__$Tess2_Geom.vertLeq(v,w);
	var gapL = v.s - u.s;
	var gapR = w.s - v.s;
	if(gapL + gapR > 0.0) {
		if(gapL < gapR) {
			return v.t - u.t + (u.t - w.t) * (gapL / (gapL + gapR));
		} else {
			return v.t - w.t + (w.t - u.t) * (gapR / (gapL + gapR));
		}
	}
	return 0.0;
};
hxGeomAlgo__$Tess2_Geom.edgeSign = function(u,v,w) {
	var cond = hxGeomAlgo__$Tess2_Geom.vertLeq(u,v) && hxGeomAlgo__$Tess2_Geom.vertLeq(v,w);
	var gapL = v.s - u.s;
	var gapR = w.s - v.s;
	if(gapL + gapR > 0.0) {
		return (v.t - w.t) * gapL + (v.t - u.t) * gapR;
	}
	return 0.0;
};
hxGeomAlgo__$Tess2_Geom.transEval = function(u,v,w) {
	var cond = hxGeomAlgo__$Tess2_Geom.transLeq(u,v) && hxGeomAlgo__$Tess2_Geom.transLeq(v,w);
	var gapL = v.t - u.t;
	var gapR = w.t - v.t;
	if(gapL + gapR > 0.0) {
		if(gapL < gapR) {
			return v.s - u.s + (u.s - w.s) * (gapL / (gapL + gapR));
		} else {
			return v.s - w.s + (w.s - u.s) * (gapR / (gapL + gapR));
		}
	}
	return 0.0;
};
hxGeomAlgo__$Tess2_Geom.transSign = function(u,v,w) {
	var cond = hxGeomAlgo__$Tess2_Geom.transLeq(u,v) && hxGeomAlgo__$Tess2_Geom.transLeq(v,w);
	var gapL = v.t - u.t;
	var gapR = w.t - v.t;
	if(gapL + gapR > 0.0) {
		return (v.s - w.s) * gapL + (v.s - u.s) * gapR;
	}
	return 0.0;
};
hxGeomAlgo__$Tess2_Geom.vertCCW = function(u,v,w) {
	return u.s * (v.t - w.t) + v.s * (w.t - u.t) + w.s * (u.t - v.t) >= 0.0;
};
hxGeomAlgo__$Tess2_Geom.interpolate = function(a,x,b,y) {
	if(a < 0) {
		a = 0;
	}
	if(b < 0) {
		b = 0;
	}
	if(a <= b) {
		if(b == 0) {
			return (x + y) / 2;
		} else {
			return x + (y - x) * (a / (a + b));
		}
	} else {
		return y + (x - y) * (b / (a + b));
	}
};
hxGeomAlgo__$Tess2_Geom.intersect = function(o1,d1,o2,d2,v) {
	var z1;
	var z2;
	var t;
	if(!hxGeomAlgo__$Tess2_Geom.vertLeq(o1,d1)) {
		t = o1;
		o1 = d1;
		d1 = t;
	}
	if(!hxGeomAlgo__$Tess2_Geom.vertLeq(o2,d2)) {
		t = o2;
		o2 = d2;
		d2 = t;
	}
	if(!hxGeomAlgo__$Tess2_Geom.vertLeq(o1,o2)) {
		t = o1;
		o1 = o2;
		o2 = t;
		t = d1;
		d1 = d2;
		d2 = t;
	}
	if(!hxGeomAlgo__$Tess2_Geom.vertLeq(o2,d1)) {
		v.s = (o2.s + d1.s) / 2;
	} else if(hxGeomAlgo__$Tess2_Geom.vertLeq(d1,d2)) {
		z1 = hxGeomAlgo__$Tess2_Geom.edgeEval(o1,o2,d1);
		z2 = hxGeomAlgo__$Tess2_Geom.edgeEval(o2,d1,d2);
		if(z1 + z2 < 0) {
			z1 = -z1;
			z2 = -z2;
		}
		v.s = hxGeomAlgo__$Tess2_Geom.interpolate(z1,o2.s,z2,d1.s);
	} else {
		z1 = hxGeomAlgo__$Tess2_Geom.edgeSign(o1,o2,d1);
		z2 = -hxGeomAlgo__$Tess2_Geom.edgeSign(o1,d2,d1);
		if(z1 + z2 < 0) {
			z1 = -z1;
			z2 = -z2;
		}
		v.s = hxGeomAlgo__$Tess2_Geom.interpolate(z1,o2.s,z2,d2.s);
	}
	if(!hxGeomAlgo__$Tess2_Geom.transLeq(o1,d1)) {
		t = o1;
		o1 = d1;
		d1 = t;
	}
	if(!hxGeomAlgo__$Tess2_Geom.transLeq(o2,d2)) {
		t = o2;
		o2 = d2;
		d2 = t;
	}
	if(!hxGeomAlgo__$Tess2_Geom.transLeq(o1,o2)) {
		t = o1;
		o1 = o2;
		o2 = t;
		t = d1;
		d1 = d2;
		d2 = t;
	}
	if(!hxGeomAlgo__$Tess2_Geom.transLeq(o2,d1)) {
		v.t = (o2.t + d1.t) / 2;
	} else if(hxGeomAlgo__$Tess2_Geom.transLeq(d1,d2)) {
		z1 = hxGeomAlgo__$Tess2_Geom.transEval(o1,o2,d1);
		z2 = hxGeomAlgo__$Tess2_Geom.transEval(o2,d1,d2);
		if(z1 + z2 < 0) {
			z1 = -z1;
			z2 = -z2;
		}
		v.t = hxGeomAlgo__$Tess2_Geom.interpolate(z1,o2.t,z2,d1.t);
	} else {
		z1 = hxGeomAlgo__$Tess2_Geom.transSign(o1,o2,d1);
		z2 = -hxGeomAlgo__$Tess2_Geom.transSign(o1,d2,d1);
		if(z1 + z2 < 0) {
			z1 = -z1;
			z2 = -z2;
		}
		v.t = hxGeomAlgo__$Tess2_Geom.interpolate(z1,o2.t,z2,d2.t);
	}
};
hxGeomAlgo__$Tess2_Geom.calcAngle = function(v0,v1,v2) {
	var a_0 = v2.s - v1.s;
	var a_1 = v2.t - v1.t;
	var b_0 = v0.s - v1.s;
	var b_1 = v0.t - v1.t;
	var num = a_0 * b_0 + a_1 * b_1;
	var den = Math.sqrt(a_0 * a_0 + a_1 * a_1) * Math.sqrt(b_0 * b_0 + b_1 * b_1);
	if(den > 0.0) {
		num /= den;
	}
	if(num < -1.0) {
		num = -1.0;
	}
	if(num > 1.0) {
		num = 1.0;
	}
	return Math.acos(num);
};
hxGeomAlgo__$Tess2_Geom.edgeIsLocallyDelaunay = function(e) {
	return hxGeomAlgo__$Tess2_Geom.calcAngle(e.Lnext.Org,e.Lnext.Lnext.Org,e.Org) + hxGeomAlgo__$Tess2_Geom.calcAngle(e.Sym.Lnext.Org,e.Sym.Lnext.Lnext.Org,e.Sym.Org) < Math.PI + 0.01;
};
var hxGeomAlgo__$Tess2_DictNode = function() {
	this.prev = null;
	this.next = null;
	this.key = null;
};
$hxClasses["hxGeomAlgo._Tess2.DictNode"] = hxGeomAlgo__$Tess2_DictNode;
hxGeomAlgo__$Tess2_DictNode.__name__ = "hxGeomAlgo._Tess2.DictNode";
hxGeomAlgo__$Tess2_DictNode.prototype = {
	key: null
	,next: null
	,prev: null
	,__class__: hxGeomAlgo__$Tess2_DictNode
};
var hxGeomAlgo__$Tess2_Dict = function(frame,leq) {
	this.head = new hxGeomAlgo__$Tess2_DictNode();
	this.head.next = this.head;
	this.head.prev = this.head;
	this.frame = frame;
	this.leq = leq;
};
$hxClasses["hxGeomAlgo._Tess2.Dict"] = hxGeomAlgo__$Tess2_Dict;
hxGeomAlgo__$Tess2_Dict.__name__ = "hxGeomAlgo._Tess2.Dict";
hxGeomAlgo__$Tess2_Dict.prototype = {
	head: null
	,frame: null
	,leq: null
	,min: function() {
		return this.head.next;
	}
	,max: function() {
		return this.head.prev;
	}
	,insert: function(k) {
		return this.insertBefore(this.head,k);
	}
	,search: function(key) {
		var node = this.head;
		while(true) {
			node = node.next;
			if(!(node.key != null && !this.leq(this.frame,key,node.key))) {
				break;
			}
		}
		return node;
	}
	,insertBefore: function(node,key) {
		while(true) {
			node = node.prev;
			if(!(node.key != null && !this.leq(this.frame,node.key,key))) {
				break;
			}
		}
		var newNode = new hxGeomAlgo__$Tess2_DictNode();
		newNode.key = key;
		newNode.next = node.next;
		node.next.prev = newNode;
		newNode.prev = node;
		node.next = newNode;
		return newNode;
	}
	,'delete': function(node) {
		node.next.prev = node.prev;
		node.prev.next = node.next;
	}
	,__class__: hxGeomAlgo__$Tess2_Dict
};
var hxGeomAlgo__$Tess2_PQNode = function() {
	this.handle = -1;
};
$hxClasses["hxGeomAlgo._Tess2.PQNode"] = hxGeomAlgo__$Tess2_PQNode;
hxGeomAlgo__$Tess2_PQNode.__name__ = "hxGeomAlgo._Tess2.PQNode";
hxGeomAlgo__$Tess2_PQNode.prototype = {
	handle: null
	,__class__: hxGeomAlgo__$Tess2_PQNode
};
var hxGeomAlgo__$Tess2_PQHandleElem = function() {
	this.node = -1;
	this.key = null;
};
$hxClasses["hxGeomAlgo._Tess2.PQHandleElem"] = hxGeomAlgo__$Tess2_PQHandleElem;
hxGeomAlgo__$Tess2_PQHandleElem.__name__ = "hxGeomAlgo._Tess2.PQHandleElem";
hxGeomAlgo__$Tess2_PQHandleElem.prototype = {
	key: null
	,node: null
	,__class__: hxGeomAlgo__$Tess2_PQHandleElem
};
var hxGeomAlgo__$Tess2_PriorityQ = function(size,leq) {
	this.size = 0;
	this.max = size;
	this.nodes = [];
	var _g = 0;
	var _g1 = size + 1;
	while(_g < _g1) {
		var i = _g++;
		this.nodes[i] = new hxGeomAlgo__$Tess2_PQNode();
	}
	this.handles = [];
	var _g = 0;
	var _g1 = size + 1;
	while(_g < _g1) {
		var i = _g++;
		this.handles[i] = new hxGeomAlgo__$Tess2_PQHandleElem();
	}
	this.initialized = false;
	this.freeList = 0;
	this.leq = leq;
	this.nodes[1].handle = 1;
	this.handles[1].key = null;
};
$hxClasses["hxGeomAlgo._Tess2.PriorityQ"] = hxGeomAlgo__$Tess2_PriorityQ;
hxGeomAlgo__$Tess2_PriorityQ.__name__ = "hxGeomAlgo._Tess2.PriorityQ";
hxGeomAlgo__$Tess2_PriorityQ.prototype = {
	size: null
	,max: null
	,nodes: null
	,handles: null
	,initialized: null
	,freeList: null
	,leq: null
	,floatDown_: function(curr) {
		var n = this.nodes;
		var h = this.handles;
		var hChild;
		var child;
		var hCurr = n[curr].handle;
		while(true) {
			child = curr << 1;
			if(child < this.size && this.leq(h[n[child + 1].handle].key,h[n[child].handle].key)) {
				++child;
			}
			hChild = n[child].handle;
			if(child > this.size || this.leq(h[hCurr].key,h[hChild].key)) {
				n[curr].handle = hCurr;
				h[hCurr].node = curr;
				break;
			}
			n[curr].handle = hChild;
			h[hChild].node = curr;
			curr = child;
		}
	}
	,floatUp_: function(curr) {
		var n = this.nodes;
		var h = this.handles;
		var hParent;
		var parent;
		var hCurr = n[curr].handle;
		while(true) {
			parent = curr >> 1;
			hParent = n[parent].handle;
			if(parent == 0 || this.leq(h[hParent].key,h[hCurr].key)) {
				n[curr].handle = hCurr;
				h[hCurr].node = curr;
				break;
			}
			n[curr].handle = hParent;
			h[hParent].node = curr;
			curr = parent;
		}
	}
	,init: function() {
		var i = this.size;
		while(i >= 1) {
			this.floatDown_(i);
			--i;
		}
		this.initialized = true;
	}
	,min: function() {
		return this.handles[this.nodes[1].handle].key;
	}
	,isEmpty: function() {
		return this.size == 0;
	}
	,insert: function(keyNew) {
		var free;
		var curr = ++this.size;
		if(curr * 2 > this.max) {
			this.max *= 2;
			var s = this.nodes.length;
			var _g = s;
			var _g1 = this.max + 1;
			while(_g < _g1) {
				var i = _g++;
				this.nodes[i] = new hxGeomAlgo__$Tess2_PQNode();
			}
			s = this.handles.length;
			var _g = this.handles.length;
			var _g1 = this.max + 1;
			while(_g < _g1) {
				var i = _g++;
				this.handles[i] = new hxGeomAlgo__$Tess2_PQHandleElem();
			}
		}
		if(this.freeList == 0) {
			free = curr;
		} else {
			free = this.freeList;
			this.freeList = this.handles[free].node;
		}
		this.nodes[curr].handle = free;
		this.handles[free].node = curr;
		this.handles[free].key = keyNew;
		if(this.initialized) {
			this.floatUp_(curr);
		}
		return free;
	}
	,extractMin: function() {
		var n = this.nodes;
		var h = this.handles;
		var hMin = n[1].handle;
		var min = h[hMin].key;
		if(this.size > 0) {
			n[1].handle = n[this.size].handle;
			h[n[1].handle].node = 1;
			h[hMin].key = null;
			h[hMin].node = this.freeList;
			this.freeList = hMin;
			--this.size;
			if(this.size > 0) {
				this.floatDown_(1);
			}
		}
		return min;
	}
	,'delete': function(hCurr) {
		var n = this.nodes;
		var h = this.handles;
		var curr = h[hCurr].node;
		n[curr].handle = n[this.size].handle;
		h[n[curr].handle].node = curr;
		--this.size;
		if(curr <= this.size) {
			if(curr <= 1 || this.leq(h[n[curr >> 1].handle].key,h[n[curr].handle].key)) {
				this.floatDown_(curr);
			} else {
				this.floatUp_(curr);
			}
		}
		h[hCurr].key = null;
		h[hCurr].node = this.freeList;
		this.freeList = hCurr;
	}
	,__class__: hxGeomAlgo__$Tess2_PriorityQ
};
var hxGeomAlgo__$Tess2_ActiveRegion = function() {
	this.fixUpperEdge = false;
	this.dirty = false;
	this.sentinel = false;
	this.inside = false;
	this.windingNumber = 0;
	this.nodeUp = null;
	this.eUp = null;
};
$hxClasses["hxGeomAlgo._Tess2.ActiveRegion"] = hxGeomAlgo__$Tess2_ActiveRegion;
hxGeomAlgo__$Tess2_ActiveRegion.__name__ = "hxGeomAlgo._Tess2.ActiveRegion";
hxGeomAlgo__$Tess2_ActiveRegion.prototype = {
	eUp: null
	,nodeUp: null
	,windingNumber: null
	,inside: null
	,sentinel: null
	,dirty: null
	,fixUpperEdge: null
	,__class__: hxGeomAlgo__$Tess2_ActiveRegion
};
var hxGeomAlgo__$Tess2_Sweep = function() { };
$hxClasses["hxGeomAlgo._Tess2.Sweep"] = hxGeomAlgo__$Tess2_Sweep;
hxGeomAlgo__$Tess2_Sweep.__name__ = "hxGeomAlgo._Tess2.Sweep";
hxGeomAlgo__$Tess2_Sweep.regionBelow = function(r) {
	return r.nodeUp.prev.key;
};
hxGeomAlgo__$Tess2_Sweep.regionAbove = function(r) {
	return r.nodeUp.next.key;
};
hxGeomAlgo__$Tess2_Sweep.debugEvent = function(tess) {
};
hxGeomAlgo__$Tess2_Sweep.addWinding = function(eDst,eSrc) {
	eDst.winding += eSrc.winding;
	eDst.Sym.winding += eSrc.Sym.winding;
};
hxGeomAlgo__$Tess2_Sweep.edgeLeq = function(tess,reg1,reg2) {
	var ev = tess.event;
	var t1;
	var t2;
	var e1 = reg1.eUp;
	var e2 = reg2.eUp;
	if(e1.get_Dst() == ev) {
		if(e2.get_Dst() == ev) {
			if(hxGeomAlgo__$Tess2_Geom.vertLeq(e1.Org,e2.Org)) {
				return hxGeomAlgo__$Tess2_Geom.edgeSign(e2.get_Dst(),e1.Org,e2.Org) <= 0;
			}
			return hxGeomAlgo__$Tess2_Geom.edgeSign(e1.get_Dst(),e2.Org,e1.Org) >= 0;
		}
		return hxGeomAlgo__$Tess2_Geom.edgeSign(e2.get_Dst(),ev,e2.Org) <= 0;
	}
	if(e2.get_Dst() == ev) {
		return hxGeomAlgo__$Tess2_Geom.edgeSign(e1.get_Dst(),ev,e1.Org) >= 0;
	}
	var t1 = hxGeomAlgo__$Tess2_Geom.edgeEval(e1.get_Dst(),ev,e1.Org);
	var t2 = hxGeomAlgo__$Tess2_Geom.edgeEval(e2.get_Dst(),ev,e2.Org);
	return t1 >= t2;
};
hxGeomAlgo__$Tess2_Sweep.deleteRegion = function(tess,reg) {
	var reg1 = reg.fixUpperEdge;
	reg.eUp.activeRegion = null;
	tess.dict.delete(reg.nodeUp);
};
hxGeomAlgo__$Tess2_Sweep.fixUpperEdge = function(tess,reg,newEdge) {
	tess.mesh.delete(reg.eUp);
	reg.fixUpperEdge = false;
	reg.eUp = newEdge;
	newEdge.activeRegion = reg;
};
hxGeomAlgo__$Tess2_Sweep.topLeftRegion = function(tess,reg) {
	var org = reg.eUp.Org;
	var e;
	while(true) {
		reg = hxGeomAlgo__$Tess2_Sweep.regionAbove(reg);
		if(!(reg.eUp.Org == org)) {
			break;
		}
	}
	if(reg.fixUpperEdge) {
		e = tess.mesh.connect(hxGeomAlgo__$Tess2_Sweep.regionBelow(reg).eUp.Sym,reg.eUp.Lnext);
		if(e == null) {
			return null;
		}
		hxGeomAlgo__$Tess2_Sweep.fixUpperEdge(tess,reg,e);
		reg = hxGeomAlgo__$Tess2_Sweep.regionAbove(reg);
	}
	return reg;
};
hxGeomAlgo__$Tess2_Sweep.topRightRegion = function(reg) {
	var dst = reg.eUp.get_Dst();
	while(true) {
		reg = hxGeomAlgo__$Tess2_Sweep.regionAbove(reg);
		if(!(reg.eUp.get_Dst() == dst)) {
			break;
		}
	}
	return reg;
};
hxGeomAlgo__$Tess2_Sweep.addRegionBelow = function(tess,regAbove,eNewUp) {
	var regNew = new hxGeomAlgo__$Tess2_ActiveRegion();
	regNew.eUp = eNewUp;
	regNew.nodeUp = tess.dict.insertBefore(regAbove.nodeUp,regNew);
	regNew.fixUpperEdge = false;
	regNew.sentinel = false;
	regNew.dirty = false;
	eNewUp.activeRegion = regNew;
	return regNew;
};
hxGeomAlgo__$Tess2_Sweep.isWindingInside = function(tess,n) {
	switch(tess.windingRule._hx_index) {
	case 0:
		return (n & 1) != 0;
	case 1:
		return n != 0;
	case 2:
		return n > 0;
	case 3:
		return n < 0;
	case 4:
		if(n < 2) {
			return n <= -2;
		} else {
			return true;
		}
		break;
	}
};
hxGeomAlgo__$Tess2_Sweep.computeWinding = function(tess,reg) {
	reg.windingNumber = hxGeomAlgo__$Tess2_Sweep.regionAbove(reg).windingNumber + reg.eUp.winding;
	reg.inside = hxGeomAlgo__$Tess2_Sweep.isWindingInside(tess,reg.windingNumber);
};
hxGeomAlgo__$Tess2_Sweep.finishRegion = function(tess,reg) {
	var e = reg.eUp;
	var f = e.Lface;
	f.inside = reg.inside;
	f.anEdge = e;
	hxGeomAlgo__$Tess2_Sweep.deleteRegion(tess,reg);
};
hxGeomAlgo__$Tess2_Sweep.finishLeftRegions = function(tess,regFirst,regLast) {
	var e;
	var ePrev;
	var reg = null;
	var regPrev = regFirst;
	var ePrev = regFirst.eUp;
	while(regPrev != regLast) {
		regPrev.fixUpperEdge = false;
		reg = hxGeomAlgo__$Tess2_Sweep.regionBelow(regPrev);
		e = reg.eUp;
		if(e.Org != ePrev.Org) {
			if(!reg.fixUpperEdge) {
				hxGeomAlgo__$Tess2_Sweep.finishRegion(tess,regPrev);
				break;
			}
			e = tess.mesh.connect(ePrev.get_Lprev(),e.Sym);
			hxGeomAlgo__$Tess2_Sweep.fixUpperEdge(tess,reg,e);
		}
		if(ePrev.Onext != e) {
			tess.mesh.splice(e.get_Oprev(),e);
			tess.mesh.splice(ePrev,e);
		}
		hxGeomAlgo__$Tess2_Sweep.finishRegion(tess,regPrev);
		ePrev = reg.eUp;
		regPrev = reg;
	}
	return ePrev;
};
hxGeomAlgo__$Tess2_Sweep.addRightEdges = function(tess,regUp,eFirst,eLast,eTopLeft,cleanUp) {
	var reg = null;
	var firstTime = true;
	var e = eFirst;
	while(true) {
		var cond = hxGeomAlgo__$Tess2_Geom.vertLeq(e.Org,e.get_Dst());
		hxGeomAlgo__$Tess2_Sweep.addRegionBelow(tess,regUp,e.Sym);
		e = e.Onext;
		if(!(e != eLast)) {
			break;
		}
	}
	if(eTopLeft == null) {
		eTopLeft = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp).eUp.get_Rprev();
	}
	var regPrev = regUp;
	var ePrev = eTopLeft;
	while(true) {
		reg = hxGeomAlgo__$Tess2_Sweep.regionBelow(regPrev);
		e = reg.eUp.Sym;
		if(e.Org != ePrev.Org) {
			break;
		}
		if(e.Onext != ePrev) {
			tess.mesh.splice(e.get_Oprev(),e);
			tess.mesh.splice(ePrev.get_Oprev(),e);
		}
		reg.windingNumber = regPrev.windingNumber - e.winding;
		reg.inside = hxGeomAlgo__$Tess2_Sweep.isWindingInside(tess,reg.windingNumber);
		regPrev.dirty = true;
		if(!firstTime && hxGeomAlgo__$Tess2_Sweep.checkForRightSplice(tess,regPrev)) {
			hxGeomAlgo__$Tess2_Sweep.addWinding(e,ePrev);
			hxGeomAlgo__$Tess2_Sweep.deleteRegion(tess,regPrev);
			tess.mesh.delete(ePrev);
		}
		firstTime = false;
		regPrev = reg;
		ePrev = e;
	}
	regPrev.dirty = true;
	if(cleanUp) {
		hxGeomAlgo__$Tess2_Sweep.walkDirtyRegions(tess,regPrev);
	}
};
hxGeomAlgo__$Tess2_Sweep.spliceMergeVertices = function(tess,e1,e2) {
	tess.mesh.splice(e1,e2);
};
hxGeomAlgo__$Tess2_Sweep.vertexWeights = function(isect,org,dst) {
	var t1 = hxGeomAlgo__$Tess2_Geom.vertL1dist(org,isect);
	var t2 = hxGeomAlgo__$Tess2_Geom.vertL1dist(dst,isect);
	var w0 = 0.5 * t2 / (t1 + t2);
	var w1 = 0.5 * t1 / (t1 + t2);
	isect.coords[0] += w0 * org.coords[0] + w1 * dst.coords[0];
	isect.coords[1] += w0 * org.coords[1] + w1 * dst.coords[1];
	isect.coords[2] += w0 * org.coords[2] + w1 * dst.coords[2];
};
hxGeomAlgo__$Tess2_Sweep.getIntersectData = function(tess,isect,orgUp,dstUp,orgLo,dstLo) {
	var tmp = isect.coords[1] = isect.coords[2] = 0;
	isect.coords[0] = tmp;
	isect.idx = -1;
	hxGeomAlgo__$Tess2_Sweep.vertexWeights(isect,orgUp,dstUp);
	hxGeomAlgo__$Tess2_Sweep.vertexWeights(isect,orgLo,dstLo);
};
hxGeomAlgo__$Tess2_Sweep.checkForRightSplice = function(tess,regUp) {
	var regLo = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
	var eUp = regUp.eUp;
	var eLo = regLo.eUp;
	if(hxGeomAlgo__$Tess2_Geom.vertLeq(eUp.Org,eLo.Org)) {
		if(hxGeomAlgo__$Tess2_Geom.edgeSign(eLo.get_Dst(),eUp.Org,eLo.Org) > 0) {
			return false;
		}
		if(!hxGeomAlgo__$Tess2_Geom.vertEq(eUp.Org,eLo.Org)) {
			tess.mesh.splitEdge(eLo.Sym);
			tess.mesh.splice(eUp,eLo.get_Oprev());
			regUp.dirty = regLo.dirty = true;
		} else if(eUp.Org != eLo.Org) {
			tess.pq.delete(eUp.Org.pqHandle);
			hxGeomAlgo__$Tess2_Sweep.spliceMergeVertices(tess,eLo.get_Oprev(),eUp);
		}
	} else {
		if(hxGeomAlgo__$Tess2_Geom.edgeSign(eUp.get_Dst(),eLo.Org,eUp.Org) < 0) {
			return false;
		}
		hxGeomAlgo__$Tess2_Sweep.regionAbove(regUp).dirty = regUp.dirty = true;
		tess.mesh.splitEdge(eUp.Sym);
		tess.mesh.splice(eLo.get_Oprev(),eUp);
	}
	return true;
};
hxGeomAlgo__$Tess2_Sweep.checkForLeftSplice = function(tess,regUp) {
	var regLo = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
	var eUp = regUp.eUp;
	var eLo = regLo.eUp;
	var e;
	var cond = !hxGeomAlgo__$Tess2_Geom.vertEq(eUp.get_Dst(),eLo.get_Dst());
	if(hxGeomAlgo__$Tess2_Geom.vertLeq(eUp.get_Dst(),eLo.get_Dst())) {
		if(hxGeomAlgo__$Tess2_Geom.edgeSign(eUp.get_Dst(),eLo.get_Dst(),eUp.Org) < 0) {
			return false;
		}
		hxGeomAlgo__$Tess2_Sweep.regionAbove(regUp).dirty = regUp.dirty = true;
		e = tess.mesh.splitEdge(eUp);
		tess.mesh.splice(eLo.Sym,e);
		e.Lface.inside = regUp.inside;
	} else {
		if(hxGeomAlgo__$Tess2_Geom.edgeSign(eLo.get_Dst(),eUp.get_Dst(),eLo.Org) > 0) {
			return false;
		}
		regUp.dirty = regLo.dirty = true;
		e = tess.mesh.splitEdge(eLo);
		tess.mesh.splice(eUp.Lnext,eLo.Sym);
		e.get_Rface().inside = regUp.inside;
	}
	return true;
};
hxGeomAlgo__$Tess2_Sweep.checkForIntersect = function(tess,regUp) {
	var regLo = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
	var eUp = regUp.eUp;
	var eLo = regLo.eUp;
	var orgUp = eUp.Org;
	var orgLo = eLo.Org;
	var dstUp = eUp.get_Dst();
	var dstLo = eLo.get_Dst();
	var isect = new hxGeomAlgo__$Tess2_TessVertex();
	var e;
	var cond = !hxGeomAlgo__$Tess2_Geom.vertEq(dstLo,dstUp);
	var cond = hxGeomAlgo__$Tess2_Geom.edgeSign(dstUp,tess.event,orgUp) <= 0;
	var cond = hxGeomAlgo__$Tess2_Geom.edgeSign(dstLo,tess.event,orgLo) >= 0;
	if(orgUp == orgLo) {
		return false;
	}
	var tMinUp = Math.min(orgUp.t,dstUp.t);
	var tMaxLo = Math.max(orgLo.t,dstLo.t);
	if(tMinUp > tMaxLo) {
		return false;
	}
	if(hxGeomAlgo__$Tess2_Geom.vertLeq(orgUp,orgLo)) {
		if(hxGeomAlgo__$Tess2_Geom.edgeSign(dstLo,orgUp,orgLo) > 0) {
			return false;
		}
	} else if(hxGeomAlgo__$Tess2_Geom.edgeSign(dstUp,orgLo,orgUp) < 0) {
		return false;
	}
	hxGeomAlgo__$Tess2_Sweep.debugEvent(tess);
	hxGeomAlgo__$Tess2_Geom.intersect(dstUp,orgUp,dstLo,orgLo,isect);
	if(hxGeomAlgo__$Tess2_Geom.vertLeq(isect,tess.event)) {
		isect.s = tess.event.s;
		isect.t = tess.event.t;
	}
	var orgMin = hxGeomAlgo__$Tess2_Geom.vertLeq(orgUp,orgLo) ? orgUp : orgLo;
	if(hxGeomAlgo__$Tess2_Geom.vertLeq(orgMin,isect)) {
		isect.s = orgMin.s;
		isect.t = orgMin.t;
	}
	if(hxGeomAlgo__$Tess2_Geom.vertEq(isect,orgUp) || hxGeomAlgo__$Tess2_Geom.vertEq(isect,orgLo)) {
		hxGeomAlgo__$Tess2_Sweep.checkForRightSplice(tess,regUp);
		return false;
	}
	if(!hxGeomAlgo__$Tess2_Geom.vertEq(dstUp,tess.event) && hxGeomAlgo__$Tess2_Geom.edgeSign(dstUp,tess.event,isect) >= 0 || !hxGeomAlgo__$Tess2_Geom.vertEq(dstLo,tess.event) && hxGeomAlgo__$Tess2_Geom.edgeSign(dstLo,tess.event,isect) <= 0) {
		if(dstLo == tess.event) {
			tess.mesh.splitEdge(eUp.Sym);
			tess.mesh.splice(eLo.Sym,eUp);
			regUp = hxGeomAlgo__$Tess2_Sweep.topLeftRegion(tess,regUp);
			eUp = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp).eUp;
			hxGeomAlgo__$Tess2_Sweep.finishLeftRegions(tess,hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp),regLo);
			hxGeomAlgo__$Tess2_Sweep.addRightEdges(tess,regUp,eUp.get_Oprev(),eUp,eUp,true);
			return true;
		}
		if(dstUp == tess.event) {
			tess.mesh.splitEdge(eLo.Sym);
			tess.mesh.splice(eUp.Lnext,eLo.get_Oprev());
			regLo = regUp;
			regUp = hxGeomAlgo__$Tess2_Sweep.topRightRegion(regUp);
			e = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp).eUp.get_Rprev();
			regLo.eUp = eLo.get_Oprev();
			eLo = hxGeomAlgo__$Tess2_Sweep.finishLeftRegions(tess,regLo,null);
			hxGeomAlgo__$Tess2_Sweep.addRightEdges(tess,regUp,eLo.Onext,eUp.get_Rprev(),e,true);
			return true;
		}
		if(hxGeomAlgo__$Tess2_Geom.edgeSign(dstUp,tess.event,isect) >= 0) {
			hxGeomAlgo__$Tess2_Sweep.regionAbove(regUp).dirty = regUp.dirty = true;
			tess.mesh.splitEdge(eUp.Sym);
			eUp.Org.s = tess.event.s;
			eUp.Org.t = tess.event.t;
		}
		if(hxGeomAlgo__$Tess2_Geom.edgeSign(dstLo,tess.event,isect) <= 0) {
			regUp.dirty = regLo.dirty = true;
			tess.mesh.splitEdge(eLo.Sym);
			eLo.Org.s = tess.event.s;
			eLo.Org.t = tess.event.t;
		}
		return false;
	}
	tess.mesh.splitEdge(eUp.Sym);
	tess.mesh.splitEdge(eLo.Sym);
	tess.mesh.splice(eLo.get_Oprev(),eUp);
	eUp.Org.s = isect.s;
	eUp.Org.t = isect.t;
	eUp.Org.pqHandle = tess.pq.insert(eUp.Org);
	hxGeomAlgo__$Tess2_Sweep.getIntersectData(tess,eUp.Org,orgUp,dstUp,orgLo,dstLo);
	hxGeomAlgo__$Tess2_Sweep.regionAbove(regUp).dirty = regUp.dirty = regLo.dirty = true;
	return false;
};
hxGeomAlgo__$Tess2_Sweep.walkDirtyRegions = function(tess,regUp) {
	var regLo = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
	var eUp;
	var eLo;
	while(true) {
		while(regLo.dirty) {
			regUp = regLo;
			regLo = hxGeomAlgo__$Tess2_Sweep.regionBelow(regLo);
		}
		if(!regUp.dirty) {
			regLo = regUp;
			regUp = hxGeomAlgo__$Tess2_Sweep.regionAbove(regUp);
			if(regUp == null || !regUp.dirty) {
				return;
			}
		}
		regUp.dirty = false;
		eUp = regUp.eUp;
		eLo = regLo.eUp;
		if(eUp.get_Dst() != eLo.get_Dst()) {
			if(hxGeomAlgo__$Tess2_Sweep.checkForLeftSplice(tess,regUp)) {
				if(regLo.fixUpperEdge) {
					hxGeomAlgo__$Tess2_Sweep.deleteRegion(tess,regLo);
					tess.mesh.delete(eLo);
					regLo = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
					eLo = regLo.eUp;
				} else if(regUp.fixUpperEdge) {
					hxGeomAlgo__$Tess2_Sweep.deleteRegion(tess,regUp);
					tess.mesh.delete(eUp);
					regUp = hxGeomAlgo__$Tess2_Sweep.regionAbove(regLo);
					eUp = regUp.eUp;
				}
			}
		}
		if(eUp.Org != eLo.Org) {
			if(eUp.get_Dst() != eLo.get_Dst() && !regUp.fixUpperEdge && !regLo.fixUpperEdge && (eUp.get_Dst() == tess.event || eLo.get_Dst() == tess.event)) {
				if(hxGeomAlgo__$Tess2_Sweep.checkForIntersect(tess,regUp)) {
					return;
				}
			} else {
				hxGeomAlgo__$Tess2_Sweep.checkForRightSplice(tess,regUp);
			}
		}
		if(eUp.Org == eLo.Org && eUp.get_Dst() == eLo.get_Dst()) {
			hxGeomAlgo__$Tess2_Sweep.addWinding(eLo,eUp);
			hxGeomAlgo__$Tess2_Sweep.deleteRegion(tess,regUp);
			tess.mesh.delete(eUp);
			regUp = hxGeomAlgo__$Tess2_Sweep.regionAbove(regLo);
		}
	}
};
hxGeomAlgo__$Tess2_Sweep.connectRightVertex = function(tess,regUp,eBottomLeft) {
	var eNew;
	var eTopLeft = eBottomLeft.Onext;
	var regLo = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
	var eUp = regUp.eUp;
	var eLo = regLo.eUp;
	var degenerate = false;
	if(eUp.get_Dst() != eLo.get_Dst()) {
		hxGeomAlgo__$Tess2_Sweep.checkForIntersect(tess,regUp);
	}
	if(hxGeomAlgo__$Tess2_Geom.vertEq(eUp.Org,tess.event)) {
		tess.mesh.splice(eTopLeft.get_Oprev(),eUp);
		regUp = hxGeomAlgo__$Tess2_Sweep.topLeftRegion(tess,regUp);
		eTopLeft = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp).eUp;
		hxGeomAlgo__$Tess2_Sweep.finishLeftRegions(tess,hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp),regLo);
		degenerate = true;
	}
	if(hxGeomAlgo__$Tess2_Geom.vertEq(eLo.Org,tess.event)) {
		tess.mesh.splice(eBottomLeft,eLo.get_Oprev());
		eBottomLeft = hxGeomAlgo__$Tess2_Sweep.finishLeftRegions(tess,regLo,null);
		degenerate = true;
	}
	if(degenerate) {
		hxGeomAlgo__$Tess2_Sweep.addRightEdges(tess,regUp,eBottomLeft.Onext,eTopLeft,eTopLeft,true);
		return;
	}
	if(hxGeomAlgo__$Tess2_Geom.vertLeq(eLo.Org,eUp.Org)) {
		eNew = eLo.get_Oprev();
	} else {
		eNew = eUp;
	}
	eNew = tess.mesh.connect(eBottomLeft.get_Lprev(),eNew);
	hxGeomAlgo__$Tess2_Sweep.addRightEdges(tess,regUp,eNew,eNew.Onext,eNew.Onext,false);
	eNew.Sym.activeRegion.fixUpperEdge = true;
	hxGeomAlgo__$Tess2_Sweep.walkDirtyRegions(tess,regUp);
};
hxGeomAlgo__$Tess2_Sweep.connectLeftDegenerate = function(tess,regUp,vEvent) {
	var e = regUp.eUp;
	if(hxGeomAlgo__$Tess2_Geom.vertEq(e.Org,vEvent)) {
		hxGeomAlgo__$Tess2_Sweep.spliceMergeVertices(tess,e,vEvent.anEdge);
		return;
	}
	if(!hxGeomAlgo__$Tess2_Geom.vertEq(e.get_Dst(),vEvent)) {
		tess.mesh.splitEdge(e.Sym);
		if(regUp.fixUpperEdge) {
			tess.mesh.delete(e.Onext);
			regUp.fixUpperEdge = false;
		}
		tess.mesh.splice(vEvent.anEdge,e);
		hxGeomAlgo__$Tess2_Sweep.sweepEvent(tess,vEvent);
		return;
	}
	regUp = hxGeomAlgo__$Tess2_Sweep.topRightRegion(regUp);
	var reg = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
	var eTopRight = reg.eUp.Sym;
	var eLast = eTopRight.Onext;
	var eTopLeft = eLast;
	if(reg.fixUpperEdge) {
		hxGeomAlgo__$Tess2_Sweep.deleteRegion(tess,reg);
		tess.mesh.delete(eTopRight);
		eTopRight = eTopLeft.get_Oprev();
	}
	tess.mesh.splice(vEvent.anEdge,eTopRight);
	if(!hxGeomAlgo__$Tess2_Geom.edgeGoesLeft(eTopLeft)) {
		eTopLeft = null;
	}
	hxGeomAlgo__$Tess2_Sweep.addRightEdges(tess,regUp,eTopRight.Onext,eLast,eTopLeft,true);
};
hxGeomAlgo__$Tess2_Sweep.connectLeftVertex = function(tess,vEvent) {
	var eNew;
	var tmp = new hxGeomAlgo__$Tess2_ActiveRegion();
	tmp.eUp = vEvent.anEdge.Sym;
	var regUp = tess.dict.search(tmp).key;
	var regLo = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
	if(regLo == null) {
		return;
	}
	var eUp = regUp.eUp;
	var eLo = regLo.eUp;
	if(hxGeomAlgo__$Tess2_Geom.edgeSign(eUp.get_Dst(),vEvent,eUp.Org) == 0.0) {
		hxGeomAlgo__$Tess2_Sweep.connectLeftDegenerate(tess,regUp,vEvent);
		return;
	}
	var reg = hxGeomAlgo__$Tess2_Geom.vertLeq(eLo.get_Dst(),eUp.get_Dst()) ? regUp : regLo;
	if(regUp.inside || reg.fixUpperEdge) {
		if(reg == regUp) {
			eNew = tess.mesh.connect(vEvent.anEdge.Sym,eUp.Lnext);
		} else {
			var tempHalfEdge = tess.mesh.connect(eLo.get_Dnext(),vEvent.anEdge);
			eNew = tempHalfEdge.Sym;
		}
		if(reg.fixUpperEdge) {
			hxGeomAlgo__$Tess2_Sweep.fixUpperEdge(tess,reg,eNew);
		} else {
			hxGeomAlgo__$Tess2_Sweep.computeWinding(tess,hxGeomAlgo__$Tess2_Sweep.addRegionBelow(tess,regUp,eNew));
		}
		hxGeomAlgo__$Tess2_Sweep.sweepEvent(tess,vEvent);
	} else {
		hxGeomAlgo__$Tess2_Sweep.addRightEdges(tess,regUp,vEvent.anEdge,vEvent.anEdge,null,true);
	}
};
hxGeomAlgo__$Tess2_Sweep.sweepEvent = function(tess,vEvent) {
	tess.event = vEvent;
	hxGeomAlgo__$Tess2_Sweep.debugEvent(tess);
	var e = vEvent.anEdge;
	while(e.activeRegion == null) {
		e = e.Onext;
		if(e == vEvent.anEdge) {
			hxGeomAlgo__$Tess2_Sweep.connectLeftVertex(tess,vEvent);
			return;
		}
	}
	var regUp = hxGeomAlgo__$Tess2_Sweep.topLeftRegion(tess,e.activeRegion);
	var reg = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
	var eTopLeft = reg.eUp;
	var eBottomLeft = hxGeomAlgo__$Tess2_Sweep.finishLeftRegions(tess,reg,null);
	if(eBottomLeft.Onext == eTopLeft) {
		hxGeomAlgo__$Tess2_Sweep.connectRightVertex(tess,regUp,eBottomLeft);
	} else {
		hxGeomAlgo__$Tess2_Sweep.addRightEdges(tess,regUp,eBottomLeft.Onext,eTopLeft,eTopLeft,true);
	}
};
hxGeomAlgo__$Tess2_Sweep.addSentinel = function(tess,smin,smax,t) {
	var reg = new hxGeomAlgo__$Tess2_ActiveRegion();
	var e = tess.mesh.makeEdge();
	e.Org.s = smax;
	e.Org.t = t;
	e.get_Dst().s = smin;
	e.get_Dst().t = t;
	tess.event = e.get_Dst();
	reg.eUp = e;
	reg.windingNumber = 0;
	reg.inside = false;
	reg.fixUpperEdge = false;
	reg.sentinel = true;
	reg.dirty = false;
	reg.nodeUp = tess.dict.insert(reg);
};
hxGeomAlgo__$Tess2_Sweep.initEdgeDict = function(tess) {
	tess.dict = new hxGeomAlgo__$Tess2_Dict(tess,hxGeomAlgo__$Tess2_Sweep.edgeLeq);
	var w = tess.bmax[0] - tess.bmin[0];
	var h = tess.bmax[1] - tess.bmin[1];
	var smin = tess.bmin[0] - w;
	var smax = tess.bmax[0] + w;
	var tmin = tess.bmin[1] - h;
	var tmax = tess.bmax[1] + h;
	hxGeomAlgo__$Tess2_Sweep.addSentinel(tess,smin,smax,tmin);
	hxGeomAlgo__$Tess2_Sweep.addSentinel(tess,smin,smax,tmax);
};
hxGeomAlgo__$Tess2_Sweep.doneEdgeDict = function(tess) {
	var reg;
	var fixedEdges = 0;
	while(true) {
		reg = tess.dict.min().key;
		if(!(reg != null)) {
			break;
		}
		if(!reg.sentinel) {
			var cond = ++fixedEdges == 1;
		}
		hxGeomAlgo__$Tess2_Sweep.deleteRegion(tess,reg);
	}
};
hxGeomAlgo__$Tess2_Sweep.removeDegenerateEdges = function(tess) {
	var eNext;
	var eLnext;
	var eHead = tess.mesh.eHead;
	var e = eHead.next;
	while(e != eHead) {
		eNext = e.next;
		eLnext = e.Lnext;
		if(hxGeomAlgo__$Tess2_Geom.vertEq(e.Org,e.get_Dst()) && e.Lnext.Lnext != e) {
			hxGeomAlgo__$Tess2_Sweep.spliceMergeVertices(tess,eLnext,e);
			tess.mesh.delete(e);
			e = eLnext;
			eLnext = e.Lnext;
		}
		if(eLnext.Lnext == e) {
			if(eLnext != e) {
				if(eLnext == eNext || eLnext == eNext.Sym) {
					eNext = eNext.next;
				}
				tess.mesh.delete(eLnext);
			}
			if(e == eNext || e == eNext.Sym) {
				eNext = eNext.next;
			}
			tess.mesh.delete(e);
		}
		e = eNext;
	}
};
hxGeomAlgo__$Tess2_Sweep.initPriorityQ = function(tess) {
	var vertexCount = 0;
	var vHead = tess.mesh.vHead;
	var v = vHead.next;
	while(v != vHead) {
		++vertexCount;
		v = v.next;
	}
	vertexCount += 8;
	var pq = tess.pq = new hxGeomAlgo__$Tess2_PriorityQ(vertexCount,hxGeomAlgo__$Tess2_Geom.vertLeq);
	vHead = tess.mesh.vHead;
	v = vHead.next;
	while(v != vHead) {
		v.pqHandle = pq.insert(v);
		v = v.next;
	}
	if(v != vHead) {
		return false;
	}
	pq.init();
	return true;
};
hxGeomAlgo__$Tess2_Sweep.donePriorityQ = function(tess) {
	tess.pq = null;
};
hxGeomAlgo__$Tess2_Sweep.removeDegenerateFaces = function(tess,mesh) {
	var fNext;
	var e;
	var f = mesh.fHead.next;
	while(f != mesh.fHead) {
		fNext = f.next;
		e = f.anEdge;
		if(e.Lnext.Lnext == e) {
			hxGeomAlgo__$Tess2_Sweep.addWinding(e.Onext,e);
			tess.mesh.delete(e);
		}
		f = fNext;
	}
	return true;
};
hxGeomAlgo__$Tess2_Sweep.computeInterior = function(tess) {
	var v;
	var vNext;
	hxGeomAlgo__$Tess2_Sweep.removeDegenerateEdges(tess);
	if(!hxGeomAlgo__$Tess2_Sweep.initPriorityQ(tess)) {
		return false;
	}
	hxGeomAlgo__$Tess2_Sweep.initEdgeDict(tess);
	var pq = tess.pq;
	while(true) {
		v = tess.pq.extractMin();
		if(!(v != null)) {
			break;
		}
		while(true) {
			vNext = tess.pq.min();
			if(vNext == null || !hxGeomAlgo__$Tess2_Geom.vertEq(vNext,v)) {
				break;
			}
			vNext = tess.pq.extractMin();
			hxGeomAlgo__$Tess2_Sweep.spliceMergeVertices(tess,v.anEdge,vNext.anEdge);
		}
		hxGeomAlgo__$Tess2_Sweep.sweepEvent(tess,v);
	}
	tess.event = tess.dict.min().key.eUp.Org;
	hxGeomAlgo__$Tess2_Sweep.debugEvent(tess);
	hxGeomAlgo__$Tess2_Sweep.doneEdgeDict(tess);
	hxGeomAlgo__$Tess2_Sweep.donePriorityQ(tess);
	if(!hxGeomAlgo__$Tess2_Sweep.removeDegenerateFaces(tess,tess.mesh)) {
		return false;
	}
	tess.mesh.check();
	return true;
};
var hxGeomAlgo_Tesselator = $hx_exports["hxGeomAlgo"]["Tesselator"] = function() {
	this.elementCount = 0;
	this.elements = [];
	this.vertexCount = 0;
	this.vertexIndices = [];
	this.vertices = [];
	this.vertexIndexCounter = 0;
	this.event = null;
	this.pq = null;
	this.dict = null;
	this.bmax = [0.0,0.0];
	this.bmin = [0.0,0.0];
	this.tUnit = [0.0,0.0,0.0];
	this.sUnit = [0.0,0.0,0.0];
	this.normal = [0.0,0.0,0.0];
	this.mesh = null;
	this.windingRule = hxGeomAlgo_WindingRule.ODD;
};
$hxClasses["hxGeomAlgo.Tesselator"] = hxGeomAlgo_Tesselator;
hxGeomAlgo_Tesselator.__name__ = "hxGeomAlgo.Tesselator";
hxGeomAlgo_Tesselator.prototype = {
	mesh: null
	,normal: null
	,sUnit: null
	,tUnit: null
	,bmin: null
	,bmax: null
	,windingRule: null
	,dict: null
	,pq: null
	,event: null
	,vertexIndexCounter: null
	,vertices: null
	,vertexIndices: null
	,vertexCount: null
	,elements: null
	,elementCount: null
	,dot_: function(u,v) {
		return u[0] * v[0] + u[1] * v[1] + u[2] * v[2];
	}
	,normalize_: function(v) {
		var len = v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
		len = Math.sqrt(len);
		v[0] /= len;
		v[1] /= len;
		v[2] /= len;
	}
	,longAxis_: function(v) {
		var i = 0;
		if(Math.abs(v[1]) > Math.abs(v[0])) {
			i = 1;
		}
		if(Math.abs(v[2]) > Math.abs(v[i])) {
			i = 2;
		}
		return i;
	}
	,computeNormal_: function(norm) {
		var c;
		var tLen2;
		var maxVal = [.0,.0,.0];
		var minVal = [.0,.0,.0];
		var d1 = [.0,.0,.0];
		var d2_0 = .0;
		var d2_1 = .0;
		var d2_2 = .0;
		var tNorm_0 = .0;
		var tNorm_1 = .0;
		var tNorm_2 = .0;
		var maxVert = [null,null,null];
		var minVert = [null,null,null];
		var vHead = this.mesh.vHead;
		var v = vHead.next;
		c = v.coords[0];
		minVal[0] = c;
		minVert[0] = v;
		maxVal[0] = c;
		maxVert[0] = v;
		c = v.coords[1];
		minVal[1] = c;
		minVert[1] = v;
		maxVal[1] = c;
		maxVert[1] = v;
		c = v.coords[2];
		minVal[2] = c;
		minVert[2] = v;
		maxVal[2] = c;
		maxVert[2] = v;
		v = vHead.next;
		while(v != vHead) {
			c = v.coords[0];
			if(c < minVal[0]) {
				minVal[0] = c;
				minVert[0] = v;
			}
			if(c > maxVal[0]) {
				maxVal[0] = c;
				maxVert[0] = v;
			}
			c = v.coords[1];
			if(c < minVal[1]) {
				minVal[1] = c;
				minVert[1] = v;
			}
			if(c > maxVal[1]) {
				maxVal[1] = c;
				maxVert[1] = v;
			}
			c = v.coords[2];
			if(c < minVal[2]) {
				minVal[2] = c;
				minVert[2] = v;
			}
			if(c > maxVal[2]) {
				maxVal[2] = c;
				maxVert[2] = v;
			}
			v = v.next;
		}
		var i = 0;
		if(maxVal[1] - minVal[1] > maxVal[0] - minVal[0]) {
			i = 1;
		}
		if(maxVal[2] - minVal[2] > maxVal[i] - minVal[i]) {
			i = 2;
		}
		if(minVal[i] >= maxVal[i]) {
			norm[0] = 0;
			norm[1] = 0;
			norm[2] = 1;
			return;
		}
		var maxLen2 = .0;
		var v1 = minVert[i];
		var v2 = maxVert[i];
		d1[0] = v1.coords[0] - v2.coords[0];
		d1[1] = v1.coords[1] - v2.coords[1];
		d1[2] = v1.coords[2] - v2.coords[2];
		v = vHead.next;
		while(v != vHead) {
			d2_0 = v.coords[0] - v2.coords[0];
			d2_1 = v.coords[1] - v2.coords[1];
			d2_2 = v.coords[2] - v2.coords[2];
			tNorm_0 = d1[1] * d2_2 - d1[2] * d2_1;
			tNorm_1 = d1[2] * d2_0 - d1[0] * d2_2;
			tNorm_2 = d1[0] * d2_1 - d1[1] * d2_0;
			tLen2 = tNorm_0 * tNorm_0 + tNorm_1 * tNorm_1 + tNorm_2 * tNorm_2;
			if(tLen2 > maxLen2) {
				maxLen2 = tLen2;
				norm[0] = tNorm_0;
				norm[1] = tNorm_1;
				norm[2] = tNorm_2;
			}
			v = v.next;
		}
		if(maxLen2 <= 0) {
			norm[0] = norm[1] = norm[2] = 0;
			norm[this.longAxis_(d1)] = 1;
		}
	}
	,checkOrientation_: function() {
		var fHead = this.mesh.fHead;
		var v;
		var vHead = this.mesh.vHead;
		var e;
		var area = .0;
		var f = fHead.next;
		while(f != fHead) {
			e = f.anEdge;
			if(e.winding <= 0) {
				f = f.next;
				continue;
			}
			while(true) {
				area += (e.Org.s - e.get_Dst().s) * (e.Org.t + e.get_Dst().t);
				e = e.Lnext;
				if(!(e != f.anEdge)) {
					break;
				}
			}
			f = f.next;
		}
		if(area < 0) {
			v = vHead.next;
			while(v != vHead) {
				v.t = -v.t;
				v = v.next;
			}
			this.tUnit[0] = -this.tUnit[0];
			this.tUnit[1] = -this.tUnit[1];
			this.tUnit[2] = -this.tUnit[2];
		}
	}
	,projectPolygon_: function() {
		var vHead = this.mesh.vHead;
		var norm = [.0,.0,.0];
		var computedNormal = false;
		norm[0] = this.normal[0];
		norm[1] = this.normal[1];
		norm[2] = this.normal[2];
		if(norm[0] == 0.0 && norm[1] == 0.0 && norm[2] == 0.0) {
			this.computeNormal_(norm);
			computedNormal = true;
		}
		var sUnit = this.sUnit;
		var tUnit = this.tUnit;
		var i = this.longAxis_(norm);
		sUnit[i] = 0;
		sUnit[(i + 1) % 3] = 1.0;
		sUnit[(i + 2) % 3] = 0.0;
		tUnit[i] = 0;
		tUnit[(i + 1) % 3] = 0.0;
		tUnit[(i + 2) % 3] = norm[i] > 0 ? 1.0 : -1.0;
		var v = vHead.next;
		while(v != vHead) {
			v.s = this.dot_(v.coords,sUnit);
			v.t = this.dot_(v.coords,tUnit);
			v = v.next;
		}
		if(computedNormal) {
			this.checkOrientation_();
		}
		var first = true;
		v = vHead.next;
		while(v != vHead) {
			if(first) {
				var tmp = this.bmax[0] = v.s;
				this.bmin[0] = tmp;
				var tmp1 = this.bmax[1] = v.t;
				this.bmin[1] = tmp1;
				first = false;
			} else {
				if(v.s < this.bmin[0]) {
					this.bmin[0] = v.s;
				}
				if(v.s > this.bmax[0]) {
					this.bmax[0] = v.s;
				}
				if(v.t < this.bmin[1]) {
					this.bmin[1] = v.t;
				}
				if(v.t > this.bmax[1]) {
					this.bmax[1] = v.t;
				}
			}
			v = v.next;
		}
	}
	,addWinding_: function(eDst,eSrc) {
		eDst.winding += eSrc.winding;
		eDst.Sym.winding += eSrc.Sym.winding;
	}
	,tessellateMonoRegion_: function(mesh,face) {
		var up = face.anEdge;
		while(hxGeomAlgo__$Tess2_Geom.vertLeq(up.get_Dst(),up.Org)) up = up.get_Lprev();
		while(hxGeomAlgo__$Tess2_Geom.vertLeq(up.Org,up.get_Dst())) up = up.Lnext;
		var lo = up.get_Lprev();
		while(up.Lnext != lo) if(hxGeomAlgo__$Tess2_Geom.vertLeq(up.get_Dst(),lo.Org)) {
			while(lo.Lnext != up && (hxGeomAlgo__$Tess2_Geom.edgeGoesLeft(lo.Lnext) || hxGeomAlgo__$Tess2_Geom.edgeSign(lo.Org,lo.get_Dst(),lo.Lnext.get_Dst()) <= 0.0)) {
				var tempHalfEdge = mesh.connect(lo.Lnext,lo);
				lo = tempHalfEdge.Sym;
			}
			lo = lo.get_Lprev();
		} else {
			while(lo.Lnext != up && (hxGeomAlgo__$Tess2_Geom.edgeGoesRight(up.get_Lprev()) || hxGeomAlgo__$Tess2_Geom.edgeSign(up.get_Dst(),up.Org,up.get_Lprev().Org) >= 0.0)) {
				var tempHalfEdge1 = mesh.connect(up,up.get_Lprev());
				up = tempHalfEdge1.Sym;
			}
			up = up.Lnext;
		}
		while(lo.Lnext.Lnext != up) {
			var tempHalfEdge = mesh.connect(lo.Lnext,lo);
			lo = tempHalfEdge.Sym;
		}
		return true;
	}
	,tessellateInterior_: function(mesh) {
		var next;
		var f = mesh.fHead.next;
		while(f != mesh.fHead) {
			next = f.next;
			if(f.inside) {
				if(!this.tessellateMonoRegion_(mesh,f)) {
					return false;
				}
			}
			f = next;
		}
		return true;
	}
	,refineDelaunay_: function(mesh) {
		var stack = [];
		var e;
		var edges_0 = null;
		var edges_1 = null;
		var edges_2 = null;
		var edges_3 = null;
		var f = mesh.fHead.next;
		while(f != mesh.fHead) {
			if(f.inside) {
				e = f.anEdge;
				while(true) {
					e.mark = hxGeomAlgo__$Tess2_Geom.edgeIsInternal(e);
					if(e.mark && !e.Sym.mark) {
						stack.push(e);
					}
					e = e.Lnext;
					if(!(e != f.anEdge)) {
						break;
					}
				}
			}
			f = f.next;
		}
		while(stack.length > 0) {
			e = stack.pop();
			e.mark = e.Sym.mark = false;
			if(!hxGeomAlgo__$Tess2_Geom.edgeIsLocallyDelaunay(e)) {
				hxGeomAlgo__$Tess2_TessMesh.flipEdge(mesh,e);
				edges_0 = e.Lnext;
				edges_1 = e.get_Lprev();
				edges_2 = e.Sym.Lnext;
				edges_3 = e.Sym.get_Lprev();
				if(!edges_0.mark && hxGeomAlgo__$Tess2_Geom.edgeIsInternal(edges_0)) {
					edges_0.mark = edges_0.Sym.mark = true;
					stack.push(edges_0);
				}
				if(!edges_1.mark && hxGeomAlgo__$Tess2_Geom.edgeIsInternal(edges_1)) {
					edges_1.mark = edges_1.Sym.mark = true;
					stack.push(edges_1);
				}
				if(!edges_2.mark && hxGeomAlgo__$Tess2_Geom.edgeIsInternal(edges_2)) {
					edges_2.mark = edges_2.Sym.mark = true;
					stack.push(edges_2);
				}
			}
		}
		var _g = 0;
		while(_g < stack.length) {
			var e = stack[_g];
			++_g;
			stack.pop();
		}
		stack = null;
	}
	,discardExterior_: function(mesh) {
		var next;
		var f = mesh.fHead.next;
		while(f != mesh.fHead) {
			next = f.next;
			if(!f.inside) {
				mesh.zapFace(f);
			}
			f = next;
		}
	}
	,setWindingNumber_: function(mesh,value,keepOnlyBoundary) {
		var eNext;
		var e = mesh.eHead.next;
		while(e != mesh.eHead) {
			eNext = e.next;
			if(e.get_Rface().inside != e.Lface.inside) {
				e.winding = e.Lface.inside ? value : -value;
			} else if(!keepOnlyBoundary) {
				e.winding = 0;
			} else {
				mesh.delete(e);
			}
			e = eNext;
		}
	}
	,getNeighbourFace_: function(edge) {
		if(edge.get_Rface() == null) {
			return -1;
		}
		if(!edge.get_Rface().inside) {
			return -1;
		}
		return edge.get_Rface().n;
	}
	,outputPolymesh_: function(mesh,resultsType,polySize,vertexDim) {
		var edge;
		var maxFaceCount = 0;
		var maxVertexCount = 0;
		var faceVerts;
		var i;
		var elements = 0;
		var vert;
		if(polySize > 3) {
			mesh.mergeConvexFaces(polySize);
		}
		var v = mesh.vHead.next;
		while(v != mesh.vHead) {
			v.n = -1;
			v = v.next;
		}
		var f = mesh.fHead.next;
		while(f != mesh.fHead) {
			f.n = -1;
			if(!f.inside) {
				f = f.next;
				continue;
			}
			edge = f.anEdge;
			faceVerts = 0;
			while(true) {
				v = edge.Org;
				if(v.n == -1) {
					v.n = maxVertexCount;
					++maxVertexCount;
				}
				++faceVerts;
				edge = edge.Lnext;
				if(!(edge != f.anEdge)) {
					break;
				}
			}
			f.n = maxFaceCount;
			++maxFaceCount;
			f = f.next;
		}
		this.elementCount = maxFaceCount;
		if(resultsType == hxGeomAlgo_ResultType.CONNECTED_POLYGONS) {
			maxFaceCount *= 2;
		}
		this.elements = [];
		this.vertexCount = maxVertexCount;
		this.vertices = [];
		this.vertexIndices = [];
		v = mesh.vHead.next;
		while(v != mesh.vHead) {
			if(v.n != -1) {
				var idx = v.n * vertexDim;
				this.vertices[idx] = v.coords[0];
				this.vertices[idx + 1] = v.coords[1];
				if(vertexDim > 2) {
					this.vertices[idx + 2] = v.coords[2];
				}
				this.vertexIndices[v.n] = v.idx;
			}
			v = v.next;
		}
		var nel = 0;
		f = mesh.fHead.next;
		while(f != mesh.fHead) {
			if(!f.inside) {
				f = f.next;
				continue;
			}
			edge = f.anEdge;
			faceVerts = 0;
			while(true) {
				v = edge.Org;
				this.elements[nel++] = v.n;
				++faceVerts;
				edge = edge.Lnext;
				if(!(edge != f.anEdge)) {
					break;
				}
			}
			var _g = faceVerts;
			var _g1 = polySize;
			while(_g < _g1) {
				var i = _g++;
				this.elements[nel++] = -1;
			}
			if(resultsType == hxGeomAlgo_ResultType.CONNECTED_POLYGONS) {
				edge = f.anEdge;
				while(true) {
					this.elements[nel++] = this.getNeighbourFace_(edge);
					edge = edge.Lnext;
					if(!(edge != f.anEdge)) {
						break;
					}
				}
				var _g2 = faceVerts;
				var _g3 = polySize;
				while(_g2 < _g3) {
					var i1 = _g2++;
					this.elements[nel++] = -1;
				}
			}
			f = f.next;
		}
	}
	,outputContours_: function(mesh,vertexDim) {
		var edge;
		var start;
		var verts;
		var elements;
		var vertInds;
		var startVert = 0;
		var vertCount = 0;
		this.vertexCount = 0;
		this.elementCount = 0;
		var f = mesh.fHead.next;
		while(f != mesh.fHead) {
			if(!f.inside) {
				f = f.next;
				continue;
			}
			edge = f.anEdge;
			start = edge;
			while(true) {
				this.vertexCount++;
				edge = edge.Lnext;
				if(!(edge != start)) {
					break;
				}
			}
			this.elementCount++;
			f = f.next;
		}
		this.elements = [];
		this.vertices = [];
		this.vertexIndices = [];
		var nv = 0;
		var nvi = 0;
		var nel = 0;
		startVert = 0;
		f = mesh.fHead.next;
		while(f != mesh.fHead) {
			if(!f.inside) {
				f = f.next;
				continue;
			}
			vertCount = 0;
			edge = f.anEdge;
			start = edge;
			while(true) {
				this.vertices[nv++] = edge.Org.coords[0];
				this.vertices[nv++] = edge.Org.coords[1];
				if(vertexDim > 2) {
					this.vertices[nv++] = edge.Org.coords[2];
				}
				this.vertexIndices[nvi++] = edge.Org.idx;
				++vertCount;
				edge = edge.Lnext;
				if(!(edge != start)) {
					break;
				}
			}
			this.elements[nel++] = startVert;
			this.elements[nel++] = vertCount;
			startVert += vertCount;
			f = f.next;
		}
	}
	,addContour: function(vertexDim,vertices) {
		if(this.mesh == null) {
			this.mesh = new hxGeomAlgo__$Tess2_TessMesh();
		}
		if(vertexDim < 2) {
			vertexDim = 2;
		}
		if(vertexDim > 3) {
			vertexDim = 3;
		}
		var e = null;
		var i = 0;
		while(i < vertices.length) {
			if(e == null) {
				e = this.mesh.makeEdge();
				this.mesh.splice(e,e.Sym);
			} else {
				this.mesh.splitEdge(e);
				e = e.Lnext;
			}
			e.Org.coords[0] = vertices[i];
			e.Org.coords[1] = vertices[i + 1];
			if(vertexDim > 2) {
				e.Org.coords[2] = vertices[i + 2];
			} else {
				e.Org.coords[2] = 0.0;
			}
			e.Org.idx = this.vertexIndexCounter++;
			e.winding = 1;
			e.Sym.winding = -1;
			i += vertexDim;
		}
	}
	,tesselate: function(windingRule,resultType,polySize,vertexDim,normal) {
		this.vertices = [];
		this.elements = [];
		this.vertexIndices = [];
		this.vertexIndexCounter = 0;
		if(normal != null) {
			this.normal[0] = normal[0];
			this.normal[1] = normal[1];
			this.normal[2] = normal[2];
		}
		this.windingRule = windingRule;
		if(vertexDim < 2) {
			vertexDim = 2;
		}
		if(vertexDim > 3) {
			vertexDim = 3;
		}
		if(this.mesh == null) {
			return false;
		}
		this.projectPolygon_();
		hxGeomAlgo__$Tess2_Sweep.computeInterior(this);
		var mesh = this.mesh;
		if(resultType == hxGeomAlgo_ResultType.BOUNDARY_CONTOURS) {
			this.setWindingNumber_(mesh,1,true);
		} else {
			this.tessellateInterior_(mesh);
			if(resultType == hxGeomAlgo_ResultType.EXPERIMENTAL_DELAUNAY) {
				this.refineDelaunay_(mesh);
				polySize = 3;
			}
		}
		mesh.check();
		if(resultType == hxGeomAlgo_ResultType.BOUNDARY_CONTOURS) {
			this.outputContours_(mesh,vertexDim);
		} else {
			this.outputPolymesh_(mesh,resultType,polySize,vertexDim);
		}
		return true;
	}
	,__class__: hxGeomAlgo_Tesselator
};
var hxGeomAlgo_Version = $hx_exports["hxGeomAlgo"]["Version"] = function() { };
$hxClasses["hxGeomAlgo.Version"] = hxGeomAlgo_Version;
hxGeomAlgo_Version.__name__ = "hxGeomAlgo.Version";
hxGeomAlgo_Version.toString = function() {
	return "" + 0 + "." + 5 + "." + 0;
};
var hxGeomAlgo_VertexType = $hxEnums["hxGeomAlgo.VertexType"] = { __ename__ : "hxGeomAlgo.VertexType", __constructs__ : ["UNKNOWN","RIGHT_LID","LEFT_LID","RIGHT_WALL","LEFT_WALL"]
	,UNKNOWN: {_hx_index:0,__enum__:"hxGeomAlgo.VertexType",toString:$estr}
	,RIGHT_LID: {_hx_index:1,__enum__:"hxGeomAlgo.VertexType",toString:$estr}
	,LEFT_LID: {_hx_index:2,__enum__:"hxGeomAlgo.VertexType",toString:$estr}
	,RIGHT_WALL: {_hx_index:3,__enum__:"hxGeomAlgo.VertexType",toString:$estr}
	,LEFT_WALL: {_hx_index:4,__enum__:"hxGeomAlgo.VertexType",toString:$estr}
};
hxGeomAlgo_VertexType.__empty_constructs__ = [hxGeomAlgo_VertexType.UNKNOWN,hxGeomAlgo_VertexType.RIGHT_LID,hxGeomAlgo_VertexType.LEFT_LID,hxGeomAlgo_VertexType.RIGHT_WALL,hxGeomAlgo_VertexType.LEFT_WALL];
var hxGeomAlgo_Visibility = $hx_exports["hxGeomAlgo"]["Visibility"] = function() { };
$hxClasses["hxGeomAlgo.Visibility"] = hxGeomAlgo_Visibility;
hxGeomAlgo_Visibility.__name__ = "hxGeomAlgo.Visibility";
hxGeomAlgo_Visibility.origPoint = null;
hxGeomAlgo_Visibility.stackTop = null;
hxGeomAlgo_Visibility.poly = null;
hxGeomAlgo_Visibility.leftLidIdx = null;
hxGeomAlgo_Visibility.rightLidIdx = null;
hxGeomAlgo_Visibility.reversed = null;
hxGeomAlgo_Visibility.getVisibleIndicesFrom = function(simplePoly,origIdx) {
	if(origIdx == null) {
		origIdx = 0;
	}
	var res = [];
	hxGeomAlgo_Visibility.poly = [];
	hxGeomAlgo_Visibility.stack.length = 0;
	hxGeomAlgo_Visibility.vertexType.length = 0;
	if(simplePoly.length <= 0) {
		return res;
	}
	hxGeomAlgo_Visibility.stackTop = -1;
	var _g = 0;
	var _g1 = simplePoly.length;
	while(_g < _g1) {
		var i = _g++;
		hxGeomAlgo_Visibility.poly.push(hxGeomAlgo_HxPoint._new(simplePoly[i].x,simplePoly[i].y));
		hxGeomAlgo_Visibility.stack.push(-1);
		hxGeomAlgo_Visibility.vertexType.push(hxGeomAlgo_VertexType.UNKNOWN);
	}
	hxGeomAlgo_Visibility.reversed = hxGeomAlgo_PolyTools.makeCW(hxGeomAlgo_Visibility.poly);
	if(hxGeomAlgo_Visibility.reversed) {
		origIdx = hxGeomAlgo_Visibility.poly.length - origIdx - 1;
	}
	var edgeJ;
	hxGeomAlgo_Visibility.origPoint = hxGeomAlgo_Visibility.poly[origIdx];
	var j = origIdx;
	hxGeomAlgo_Visibility.push(j++,hxGeomAlgo_VertexType.RIGHT_WALL);
	while(true) {
		hxGeomAlgo_Visibility.push(j++,hxGeomAlgo_VertexType.RIGHT_WALL);
		if(j >= hxGeomAlgo_Visibility.poly.length + origIdx) {
			break;
		}
		var poly = hxGeomAlgo_Visibility.poly;
		var idx = j - 1;
		var idx1 = idx;
		var len = poly.length;
		if(idx1 < 0) {
			idx1 += len;
		}
		idx = idx1 % len;
		var poly1 = hxGeomAlgo_Visibility.poly;
		var idx2 = j;
		var idx3 = idx2;
		var len1 = poly1.length;
		if(idx3 < 0) {
			idx3 += len1;
		}
		idx2 = idx3 % len1;
		edgeJ = hxGeomAlgo_PolyTools.meet(poly[idx],poly1[idx2]);
		if(edgeJ.left(hxGeomAlgo_Visibility.origPoint)) {
			if(!(j < hxGeomAlgo_Visibility.poly.length + origIdx)) {
				break;
			} else {
				continue;
			}
		}
		var poly2 = hxGeomAlgo_Visibility.poly;
		var idx4 = j - 2;
		var idx5 = idx4;
		var len2 = poly2.length;
		if(idx5 < 0) {
			idx5 += len2;
		}
		idx4 = idx5 % len2;
		if(!edgeJ.left(poly2[idx4])) {
			var poly3 = hxGeomAlgo_Visibility.poly;
			var idx6 = hxGeomAlgo_Visibility.stack[hxGeomAlgo_Visibility.stackTop];
			var idx7 = idx6;
			var len3 = poly3.length;
			if(idx7 < 0) {
				idx7 += len3;
			}
			idx6 = idx7 % len3;
			j = hxGeomAlgo_Visibility.exitRightBay(hxGeomAlgo_Visibility.poly,j,poly3[idx6],hxGeomAlgo_HomogCoord.INFINITY);
			hxGeomAlgo_Visibility.push(j++,hxGeomAlgo_VertexType.RIGHT_LID);
			if(!(j < hxGeomAlgo_Visibility.poly.length + origIdx)) {
				break;
			} else {
				continue;
			}
		}
		hxGeomAlgo_Visibility.saveLid();
		while(true) {
			var p = hxGeomAlgo_Visibility.origPoint;
			var poly4 = hxGeomAlgo_Visibility.poly;
			var idx8 = hxGeomAlgo_Visibility.stack[hxGeomAlgo_Visibility.stackTop];
			var idx9 = idx8;
			var len4 = poly4.length;
			if(idx9 < 0) {
				idx9 += len4;
			}
			idx8 = idx9 % len4;
			var a = poly4[idx8];
			var poly5 = hxGeomAlgo_Visibility.poly;
			var idx10 = j;
			var idx11 = idx10;
			var len5 = poly5.length;
			if(idx11 < 0) {
				idx11 += len5;
			}
			idx10 = idx11 % len5;
			var b = poly5[idx10];
			if((a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) > 0) {
				var poly6 = hxGeomAlgo_Visibility.poly;
				var idx12 = j;
				var idx13 = idx12;
				var len6 = poly6.length;
				if(idx13 < 0) {
					idx13 += len6;
				}
				idx12 = idx13 % len6;
				var p1 = poly6[idx12];
				var poly7 = hxGeomAlgo_Visibility.poly;
				var idx14 = j + 1;
				var idx15 = idx14;
				var len7 = poly7.length;
				if(idx15 < 0) {
					idx15 += len7;
				}
				idx14 = idx15 % len7;
				var a1 = poly7[idx14];
				var b1 = hxGeomAlgo_Visibility.origPoint;
				if((a1.x - p1.x) * (b1.y - p1.y) - (b1.x - p1.x) * (a1.y - p1.y) < 0) {
					++j;
				} else {
					var poly8 = hxGeomAlgo_Visibility.poly;
					var idx16 = j + 1;
					var idx17 = idx16;
					var len8 = poly8.length;
					if(idx17 < 0) {
						idx17 += len8;
					}
					idx16 = idx17 % len8;
					if(edgeJ.left(poly8[idx16])) {
						var poly9 = hxGeomAlgo_Visibility.poly;
						var idx18 = j;
						var idx19 = idx18;
						var len9 = poly9.length;
						if(idx19 < 0) {
							idx19 += len9;
						}
						idx18 = idx19 % len9;
						var poly10 = hxGeomAlgo_Visibility.poly;
						var idx20 = hxGeomAlgo_Visibility.leftLidIdx;
						var idx21 = idx20;
						var len10 = poly10.length;
						if(idx21 < 0) {
							idx21 += len10;
						}
						idx20 = idx21 % len10;
						var poly11 = hxGeomAlgo_Visibility.poly;
						var idx22 = hxGeomAlgo_Visibility.leftLidIdx - 1;
						var idx23 = idx22;
						var len11 = poly11.length;
						if(idx23 < 0) {
							idx23 += len11;
						}
						idx22 = idx23 % len11;
						j = hxGeomAlgo_Visibility.exitLeftBay(hxGeomAlgo_Visibility.poly,j,poly9[idx18],hxGeomAlgo_PolyTools.meet(poly10[idx20],poly11[idx22])) + 1;
					} else {
						hxGeomAlgo_Visibility.restoreLid();
						hxGeomAlgo_Visibility.push(j++,hxGeomAlgo_VertexType.LEFT_WALL);
						break;
					}
				}
				var poly12 = hxGeomAlgo_Visibility.poly;
				var idx24 = j - 1;
				var idx25 = idx24;
				var len12 = poly12.length;
				if(idx25 < 0) {
					idx25 += len12;
				}
				idx24 = idx25 % len12;
				var poly13 = hxGeomAlgo_Visibility.poly;
				var idx26 = j;
				var idx27 = idx26;
				var len13 = poly13.length;
				if(idx27 < 0) {
					idx27 += len13;
				}
				idx26 = idx27 % len13;
				edgeJ = hxGeomAlgo_PolyTools.meet(poly12[idx24],poly13[idx26]);
			} else {
				var poly14 = hxGeomAlgo_Visibility.poly;
				var idx28 = hxGeomAlgo_Visibility.stack[hxGeomAlgo_Visibility.stackTop];
				var idx29 = idx28;
				var len14 = poly14.length;
				if(idx29 < 0) {
					idx29 += len14;
				}
				idx28 = idx29 % len14;
				if(!edgeJ.left(poly14[idx28])) {
					var poly15 = hxGeomAlgo_Visibility.poly;
					var idx30 = hxGeomAlgo_Visibility.stack[hxGeomAlgo_Visibility.stackTop];
					var idx31 = idx30;
					var len15 = poly15.length;
					if(idx31 < 0) {
						idx31 += len15;
					}
					idx30 = idx31 % len15;
					j = hxGeomAlgo_Visibility.exitRightBay(hxGeomAlgo_Visibility.poly,j,poly15[idx30],edgeJ.neg());
					hxGeomAlgo_Visibility.push(j++,hxGeomAlgo_VertexType.RIGHT_LID);
					break;
				} else {
					hxGeomAlgo_Visibility.saveLid();
				}
			}
		}
		if(!(j < hxGeomAlgo_Visibility.poly.length + origIdx)) {
			break;
		}
	}
	var _g = 0;
	var _g1 = hxGeomAlgo_Visibility.stackTop + 1;
	while(_g < _g1) {
		var i = _g++;
		if(hxGeomAlgo_Visibility.vertexType[i] == hxGeomAlgo_VertexType.LEFT_WALL || hxGeomAlgo_Visibility.vertexType[i] == hxGeomAlgo_VertexType.RIGHT_WALL) {
			var idx = hxGeomAlgo_Visibility.stack[i] % hxGeomAlgo_Visibility.poly.length;
			if(hxGeomAlgo_Visibility.reversed) {
				idx = hxGeomAlgo_Visibility.poly.length - idx - 1;
			}
			res.push(idx);
		}
	}
	return res;
};
hxGeomAlgo_Visibility.getVisiblePolyFrom = function(simplePoly,origIdx) {
	if(origIdx == null) {
		origIdx = 0;
	}
	var indices = hxGeomAlgo_Visibility.getVisibleIndicesFrom(simplePoly,origIdx);
	var res = [];
	if(indices.length <= 0) {
		return res;
	}
	var q;
	var poly = hxGeomAlgo_Visibility.poly;
	var idx = hxGeomAlgo_Visibility.stack[hxGeomAlgo_Visibility.stackTop];
	var idx1 = idx;
	var len = poly.length;
	if(idx1 < 0) {
		idx1 += len;
	}
	idx = idx1 % len;
	var last = poly[idx];
	var lastPushed = null;
	var lastType = hxGeomAlgo_VertexType.UNKNOWN;
	var vType = hxGeomAlgo_VertexType.UNKNOWN;
	var _g = 0;
	var _g1 = hxGeomAlgo_Visibility.stackTop + 1;
	while(_g < _g1) {
		var i = _g++;
		vType = hxGeomAlgo_Visibility.vertexType[i];
		if(vType == hxGeomAlgo_VertexType.RIGHT_LID) {
			var q1 = hxGeomAlgo_PolyTools.meet(hxGeomAlgo_Visibility.origPoint,last);
			var poly = hxGeomAlgo_Visibility.poly;
			var idx = hxGeomAlgo_Visibility.stack[i];
			var idx1 = idx;
			var len = poly.length;
			if(idx1 < 0) {
				idx1 += len;
			}
			idx = idx1 % len;
			var poly1 = hxGeomAlgo_Visibility.poly;
			var idx2 = hxGeomAlgo_Visibility.stack[i + 1];
			var idx3 = idx2;
			var len1 = poly1.length;
			if(idx3 < 0) {
				idx3 += len1;
			}
			idx2 = idx3 % len1;
			q = q1.meet(hxGeomAlgo_PolyTools.meet(poly[idx],poly1[idx2]));
			if(lastPushed != null && !(last != null && lastPushed.x == last.x && lastPushed.y == last.y)) {
				res.push(hxGeomAlgo_HxPoint._new(last.x,last.y));
			}
			res.push(q.toPoint());
		} else if(vType == hxGeomAlgo_VertexType.LEFT_WALL) {
			var poly2 = hxGeomAlgo_Visibility.poly;
			var idx4 = hxGeomAlgo_Visibility.stack[i];
			var idx5 = idx4;
			var len2 = poly2.length;
			if(idx5 < 0) {
				idx5 += len2;
			}
			idx4 = idx5 % len2;
			var q2 = hxGeomAlgo_PolyTools.meet(hxGeomAlgo_Visibility.origPoint,poly2[idx4]);
			var poly3 = hxGeomAlgo_Visibility.poly;
			var idx6 = hxGeomAlgo_Visibility.stack[i - 2];
			var idx7 = idx6;
			var len3 = poly3.length;
			if(idx7 < 0) {
				idx7 += len3;
			}
			idx6 = idx7 % len3;
			var poly4 = hxGeomAlgo_Visibility.poly;
			var idx8 = hxGeomAlgo_Visibility.stack[i - 1];
			var idx9 = idx8;
			var len4 = poly4.length;
			if(idx9 < 0) {
				idx9 += len4;
			}
			idx8 = idx9 % len4;
			q = q2.meet(hxGeomAlgo_PolyTools.meet(poly3[idx6],poly4[idx8]));
			res.push(q.toPoint());
		} else if(!(vType == hxGeomAlgo_VertexType.RIGHT_WALL && lastType == hxGeomAlgo_VertexType.RIGHT_LID || vType == hxGeomAlgo_VertexType.LEFT_LID && lastType == hxGeomAlgo_VertexType.RIGHT_LID)) {
			res.push(hxGeomAlgo_HxPoint._new(last.x,last.y));
		}
		lastPushed = res[res.length - 1];
		var poly5 = hxGeomAlgo_Visibility.poly;
		var idx10 = hxGeomAlgo_Visibility.stack[i];
		var idx11 = idx10;
		var len5 = poly5.length;
		if(idx11 < 0) {
			idx11 += len5;
		}
		idx10 = idx11 % len5;
		last = poly5[idx10];
		lastType = vType;
	}
	return res;
};
hxGeomAlgo_Visibility.exitRightBay = function(poly,j,bot,lid) {
	var windingNum = 0;
	var mouth = hxGeomAlgo_PolyTools.meet(hxGeomAlgo_Visibility.origPoint,bot);
	var lastLeft;
	var currLeft = false;
	while(++j < 3 * poly.length) {
		lastLeft = currLeft;
		var idx = j;
		var idx1 = idx;
		var len = poly.length;
		if(idx1 < 0) {
			idx1 += len;
		}
		idx = idx1 % len;
		currLeft = mouth.left(poly[idx]);
		var tmp;
		if(currLeft != lastLeft) {
			var idx2 = j - 1;
			var idx3 = idx2;
			var len1 = poly.length;
			if(idx3 < 0) {
				idx3 += len1;
			}
			idx2 = idx3 % len1;
			var p = poly[idx2];
			var idx4 = j;
			var idx5 = idx4;
			var len2 = poly.length;
			if(idx5 < 0) {
				idx5 += len2;
			}
			idx4 = idx5 % len2;
			var a = poly[idx4];
			var b = hxGeomAlgo_Visibility.origPoint;
			tmp = (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) > 0 == currLeft;
		} else {
			tmp = false;
		}
		if(tmp) {
			if(!currLeft) {
				--windingNum;
			} else if(windingNum++ == 0) {
				var idx6 = j - 1;
				var idx7 = idx6;
				var len3 = poly.length;
				if(idx7 < 0) {
					idx7 += len3;
				}
				idx6 = idx7 % len3;
				var idx8 = j;
				var idx9 = idx8;
				var len4 = poly.length;
				if(idx9 < 0) {
					idx9 += len4;
				}
				idx8 = idx9 % len4;
				var edge = hxGeomAlgo_PolyTools.meet(poly[idx6],poly[idx8]);
				if(edge.left(bot) && !hxGeomAlgo_HomogCoord.cw(mouth,edge,lid)) {
					return j - 1;
				}
			}
		}
	}
	return j;
};
hxGeomAlgo_Visibility.exitLeftBay = function(poly,j,bot,lid) {
	var windingNum = 0;
	var mouth = hxGeomAlgo_PolyTools.meet(hxGeomAlgo_Visibility.origPoint,bot);
	var lastRight;
	var currRight = false;
	while(++j < 3 * poly.length) {
		lastRight = currRight;
		var idx = j;
		var idx1 = idx;
		var len = poly.length;
		if(idx1 < 0) {
			idx1 += len;
		}
		idx = idx1 % len;
		currRight = mouth.right(poly[idx]);
		var tmp;
		if(currRight != lastRight) {
			var idx2 = j - 1;
			var idx3 = idx2;
			var len1 = poly.length;
			if(idx3 < 0) {
				idx3 += len1;
			}
			idx2 = idx3 % len1;
			var p = poly[idx2];
			var idx4 = j;
			var idx5 = idx4;
			var len2 = poly.length;
			if(idx5 < 0) {
				idx5 += len2;
			}
			idx4 = idx5 % len2;
			var a = poly[idx4];
			var b = hxGeomAlgo_Visibility.origPoint;
			tmp = (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) < 0 == currRight;
		} else {
			tmp = false;
		}
		if(tmp) {
			if(!currRight) {
				++windingNum;
			} else if(windingNum-- == 0) {
				var idx6 = j - 1;
				var idx7 = idx6;
				var len3 = poly.length;
				if(idx7 < 0) {
					idx7 += len3;
				}
				idx6 = idx7 % len3;
				var idx8 = j;
				var idx9 = idx8;
				var len4 = poly.length;
				if(idx9 < 0) {
					idx9 += len4;
				}
				idx8 = idx9 % len4;
				var edge = hxGeomAlgo_PolyTools.meet(poly[idx6],poly[idx8]);
				if(edge.right(bot) && !hxGeomAlgo_HomogCoord.cw(mouth,edge,lid)) {
					return j - 1;
				}
			}
		}
	}
	return j;
};
hxGeomAlgo_Visibility.push = function(idx,vType) {
	hxGeomAlgo_Visibility.stackTop++;
	hxGeomAlgo_Visibility.stack[hxGeomAlgo_Visibility.stackTop] = idx;
	hxGeomAlgo_Visibility.vertexType[hxGeomAlgo_Visibility.stackTop] = vType;
};
hxGeomAlgo_Visibility.saveLid = function() {
	if(hxGeomAlgo_Visibility.vertexType[hxGeomAlgo_Visibility.stackTop] == hxGeomAlgo_VertexType.LEFT_WALL) {
		hxGeomAlgo_Visibility.stackTop--;
	}
	hxGeomAlgo_Visibility.leftLidIdx = hxGeomAlgo_Visibility.stack[hxGeomAlgo_Visibility.stackTop--];
	if(hxGeomAlgo_Visibility.vertexType[hxGeomAlgo_Visibility.stackTop] == hxGeomAlgo_VertexType.RIGHT_LID) {
		hxGeomAlgo_Visibility.rightLidIdx = hxGeomAlgo_Visibility.stack[hxGeomAlgo_Visibility.stackTop--];
	} else {
		hxGeomAlgo_Visibility.rightLidIdx = -1;
	}
};
hxGeomAlgo_Visibility.restoreLid = function() {
	if(hxGeomAlgo_Visibility.rightLidIdx != -1) {
		hxGeomAlgo_Visibility.push(hxGeomAlgo_Visibility.rightLidIdx,hxGeomAlgo_VertexType.RIGHT_LID);
	}
	hxGeomAlgo_Visibility.push(hxGeomAlgo_Visibility.leftLidIdx,hxGeomAlgo_VertexType.LEFT_LID);
};
var hxGeomAlgo_SimplificationMethod = $hxEnums["hxGeomAlgo.SimplificationMethod"] = { __ename__ : "hxGeomAlgo.SimplificationMethod", __constructs__ : ["MaxPoints","ThresholdArea","Ratio"]
	,MaxPoints: ($_=function(n) { return {_hx_index:0,n:n,__enum__:"hxGeomAlgo.SimplificationMethod",toString:$estr}; },$_.__params__ = ["n"],$_)
	,ThresholdArea: ($_=function(a) { return {_hx_index:1,a:a,__enum__:"hxGeomAlgo.SimplificationMethod",toString:$estr}; },$_.__params__ = ["a"],$_)
	,Ratio: ($_=function(r) { return {_hx_index:2,r:r,__enum__:"hxGeomAlgo.SimplificationMethod",toString:$estr}; },$_.__params__ = ["r"],$_)
};
hxGeomAlgo_SimplificationMethod.__empty_constructs__ = [];
var hxGeomAlgo_VisvalingamWhyatt = $hx_exports["hxGeomAlgo"]["VisvalingamWhyatt"] = function() { };
$hxClasses["hxGeomAlgo.VisvalingamWhyatt"] = hxGeomAlgo_VisvalingamWhyatt;
hxGeomAlgo_VisvalingamWhyatt.__name__ = "hxGeomAlgo.VisvalingamWhyatt";
hxGeomAlgo_VisvalingamWhyatt.method = null;
hxGeomAlgo_VisvalingamWhyatt.minHeap = null;
hxGeomAlgo_VisvalingamWhyatt.simplify = function(points,method) {
	var numPoints = points.length;
	if(numPoints < 3) {
		return [].concat(points);
	}
	hxGeomAlgo_VisvalingamWhyatt.method = method == null ? hxGeomAlgo_SimplificationMethod.ThresholdArea(0) : method;
	var thresholdArea = 0.0;
	var maxPoints = numPoints;
	var _g = hxGeomAlgo_VisvalingamWhyatt.method;
	switch(_g._hx_index) {
	case 0:
		var n = _g.n;
		maxPoints = n;
		break;
	case 1:
		var a = _g.a;
		thresholdArea = a;
		break;
	case 2:
		var r = _g.r;
		maxPoints = points.length * r | 0;
		break;
	}
	if(maxPoints < 2) {
		maxPoints = 2;
	}
	if(thresholdArea < 0) {
		thresholdArea = 0;
	}
	hxGeomAlgo_VisvalingamWhyatt.minHeap = new hxGeomAlgo_Heap();
	var triangles = [];
	var triangle;
	var _g = 1;
	var _g1 = numPoints - 1;
	while(_g < _g1) {
		var i = _g++;
		triangle = new hxGeomAlgo__$VisvalingamWhyatt_Triangle(points[i - 1],points[i],points[i + 1]);
		triangle.calcArea();
		if(triangle.area > thresholdArea) {
			triangles.push(triangle);
		}
	}
	var numTriangles = triangles.length;
	var _g = 0;
	var _g1 = numTriangles;
	while(_g < _g1) {
		var i = _g++;
		triangle = triangles[i];
		if(i > 0) {
			triangle.prev = triangles[i - 1];
			triangle.points[0] = triangle.prev.points[1];
		} else {
			triangle.points[0] = points[0];
		}
		if(i < numTriangles - 1) {
			triangle.next = triangles[i + 1];
			triangle.points[2] = triangle.next.points[1];
		} else {
			triangle.points[2] = points[numPoints - 1];
		}
		triangle.calcArea();
		hxGeomAlgo_VisvalingamWhyatt.minHeap.push(triangle);
	}
	var firstTriangle = triangles[0];
	while(hxGeomAlgo_VisvalingamWhyatt.minHeap.length > maxPoints - 2) {
		triangle = hxGeomAlgo_VisvalingamWhyatt.minHeap.pop();
		if(triangle.prev != null) {
			triangle.prev.next = triangle.next;
			triangle.prev.points[2] = triangle.points[2];
			hxGeomAlgo_VisvalingamWhyatt.updateTriangle(triangle.prev);
		} else if(triangle.next != null) {
			firstTriangle = triangle.next;
		}
		if(triangle.next != null) {
			triangle.next.prev = triangle.prev;
			triangle.next.points[0] = triangle.points[0];
			hxGeomAlgo_VisvalingamWhyatt.updateTriangle(triangle.next);
		}
	}
	var res = [points[0]];
	triangle = maxPoints > 2 ? firstTriangle : null;
	while(triangle != null) {
		res.push(triangle.points[1]);
		triangle = triangle.next;
	}
	res.push(points[numPoints - 1]);
	return res;
};
hxGeomAlgo_VisvalingamWhyatt.updateTriangle = function(triangle) {
	hxGeomAlgo_VisvalingamWhyatt.minHeap.remove(triangle);
	triangle.calcArea();
	hxGeomAlgo_VisvalingamWhyatt.minHeap.push(triangle);
};
var hxGeomAlgo__$VisvalingamWhyatt_Triangle = function(a,b,c) {
	this.area = 0;
	this.next = null;
	this.prev = null;
	this.points = [a,b,c];
};
$hxClasses["hxGeomAlgo._VisvalingamWhyatt.Triangle"] = hxGeomAlgo__$VisvalingamWhyatt_Triangle;
hxGeomAlgo__$VisvalingamWhyatt_Triangle.__name__ = "hxGeomAlgo._VisvalingamWhyatt.Triangle";
hxGeomAlgo__$VisvalingamWhyatt_Triangle.__interfaces__ = [hxGeomAlgo_Heapable];
hxGeomAlgo__$VisvalingamWhyatt_Triangle.prototype = {
	position: null
	,points: null
	,prev: null
	,next: null
	,area: null
	,calcArea: function() {
		this.area = (this.points[0].x * this.points[2].y - this.points[2].x * this.points[0].y + (this.points[1].x * this.points[0].y - this.points[0].x * this.points[1].y) + (this.points[2].x * this.points[1].y - this.points[1].x * this.points[2].y)) * .5;
		if(this.area < 0) {
			this.area = -this.area;
		}
		return this.area;
	}
	,compare: function(other) {
		var diff = this.area - other.area;
		if(diff < 0) {
			return -1;
		} else if(diff > 0) {
			return 1;
		} else {
			return 0;
		}
	}
	,__class__: hxGeomAlgo__$VisvalingamWhyatt_Triangle
};
var hxGeomAlgo_WuYongZhang = $hx_exports["hxGeomAlgo"]["WuYongZhang"] = function() { };
$hxClasses["hxGeomAlgo.WuYongZhang"] = hxGeomAlgo_WuYongZhang;
hxGeomAlgo_WuYongZhang.__name__ = "hxGeomAlgo.WuYongZhang";
hxGeomAlgo_WuYongZhang.buildCache = function(k) {
	var pow2_minus1 = Math.pow(2,-1);
	var pow2_minusK_minus1 = Math.pow(2,-k - 1);
	var pow2_minusK = Math.pow(2,-k);
	var pow2_K = Math.pow(2,k) | 0;
	if(hxGeomAlgo_WuYongZhang.F.h.hasOwnProperty(pow2_K) && hxGeomAlgo_WuYongZhang.F.h[pow2_K].h.hasOwnProperty(k)) {
		return;
	}
	var _g = 1;
	var _g1 = pow2_K + 1;
	while(_g < _g1) {
		var j = _g++;
		if(!hxGeomAlgo_WuYongZhang.F.h.hasOwnProperty(j)) {
			var this1 = hxGeomAlgo_WuYongZhang.F;
			var v = new haxe_ds_IntMap();
			this1.h[j] = v;
			var this2 = hxGeomAlgo_WuYongZhang.G;
			var v1 = new haxe_ds_IntMap();
			this2.h[j] = v1;
			var this3 = hxGeomAlgo_WuYongZhang.H;
			var v2 = new haxe_ds_IntMap();
			this3.h[j] = v2;
		}
		if(!hxGeomAlgo_WuYongZhang.F.h[j].h.hasOwnProperty(k)) {
			var v3 = pow2_minus1 - pow2_minusK_minus1 - (j - 1) * (pow2_minusK - j * Math.pow(2,-2 * k - 1));
			hxGeomAlgo_WuYongZhang.F.h[j].h[k] = v3;
			var v4 = pow2_minus1 + pow2_minusK_minus1 + (j - 1) * (pow2_minusK - j * Math.pow(2,-2 * k));
			hxGeomAlgo_WuYongZhang.G.h[j].h[k] = v4;
			var v5 = (j - 1) * j * Math.pow(2,-2 * k - 1);
			hxGeomAlgo_WuYongZhang.H.h[j].h[k] = v5;
		}
	}
};
hxGeomAlgo_WuYongZhang.scale = function(a,s) {
	a.x = s * a.x;
	a.y = s * a.y;
	return a;
};
hxGeomAlgo_WuYongZhang.add = function(a,b) {
	a.x += b.x;
	a.y += b.y;
	return a;
};
hxGeomAlgo_WuYongZhang.smooth = function(poly,iterations,close) {
	if(close == null) {
		close = false;
	}
	if(iterations == null) {
		iterations = 3;
	}
	if(iterations <= 0 || poly.length <= 2) {
		return poly.slice();
	}
	var P0 = poly.slice();
	var k = iterations;
	if(close) {
		P0.push(P0[0]);
		P0.push(P0[1]);
	}
	hxGeomAlgo_WuYongZhang.buildCache(k);
	var smoothedPoints = [];
	var n0 = P0.length - 1;
	var newLength = Math.pow(2,k) * n0 - Math.pow(2,k) + 2 | 0;
	smoothedPoints.length = newLength;
	var factor1 = Math.pow(2,-1) + Math.pow(2,-k - 1);
	var factor2 = Math.pow(2,-1) - Math.pow(2,-k - 1);
	if(!close) {
		var this1 = poly[0];
		smoothedPoints[0] = hxGeomAlgo_HxPoint._new(this1.x,this1.y);
		var this1 = poly[poly.length - 1];
		smoothedPoints[newLength - 1] = hxGeomAlgo_HxPoint._new(this1.x,this1.y);
	} else {
		var this1 = P0[0];
		var a = hxGeomAlgo_HxPoint._new(this1.x,this1.y);
		a.x = factor1 * a.x;
		a.y = factor1 * a.y;
		var a1 = a;
		var this1 = P0[1];
		var a = hxGeomAlgo_HxPoint._new(this1.x,this1.y);
		a.x = factor2 * a.x;
		a.y = factor2 * a.y;
		var b = a;
		a1.x += b.x;
		a1.y += b.y;
		var firstPoint = a1;
		smoothedPoints[0] = firstPoint;
		var this1 = P0[n0 - 1];
		var a = hxGeomAlgo_HxPoint._new(this1.x,this1.y);
		a.x = factor2 * a.x;
		a.y = factor2 * a.y;
		var a1 = a;
		var this1 = P0[n0];
		var a = hxGeomAlgo_HxPoint._new(this1.x,this1.y);
		a.x = factor1 * a.x;
		a.y = factor1 * a.y;
		var b = a;
		a1.x += b.x;
		a1.y += b.y;
		var lastPoint = a1;
		smoothedPoints[newLength - 1] = lastPoint;
	}
	var pow2_k = Math.pow(2,k) | 0;
	var _g = 0;
	var _g1 = n0 - 1;
	while(_g < _g1) {
		var i = _g++;
		var _g2 = 0;
		var _g3 = pow2_k;
		while(_g2 < _g3) {
			var j = _g2++;
			var idx = pow2_k * i + j + 1;
			var this1 = P0[i];
			var a = hxGeomAlgo_HxPoint._new(this1.x,this1.y);
			var s = hxGeomAlgo_WuYongZhang.F.h[j + 1].h[k];
			a.x = s * a.x;
			a.y = s * a.y;
			var a1 = a;
			var this2 = P0[i + 1];
			var a2 = hxGeomAlgo_HxPoint._new(this2.x,this2.y);
			var s1 = hxGeomAlgo_WuYongZhang.G.h[j + 1].h[k];
			a2.x = s1 * a2.x;
			a2.y = s1 * a2.y;
			var b = a2;
			a1.x += b.x;
			a1.y += b.y;
			var a3 = a1;
			var this3 = P0[i + 2];
			var a4 = hxGeomAlgo_HxPoint._new(this3.x,this3.y);
			var s2 = hxGeomAlgo_WuYongZhang.H.h[j + 1].h[k];
			a4.x = s2 * a4.x;
			a4.y = s2 * a4.y;
			var b1 = a4;
			a3.x += b1.x;
			a3.y += b1.y;
			smoothedPoints[idx] = a3;
		}
	}
	if(close && smoothedPoints.length > 2) {
		smoothedPoints.splice(newLength - 2,2);
	}
	return smoothedPoints;
};
var Pixels = $hx_exports["Pixels"] = {};
Pixels._new = function(width,height,alloc) {
	if(alloc == null) {
		alloc = true;
	}
	var this1 = new hxPixels__$Pixels_PixelsData(width,height,alloc);
	return this1;
};
Pixels.getByte = function(this1,i) {
	return this1.bytes.b[(i & -4) + this1.format.channelMap[i & 3]];
};
Pixels.getRawInt32 = function(this1,i) {
	return this1.bytes.getInt32(i << 2);
};
Pixels.getRawPixel32 = function(this1,x,y) {
	var pos = y * this1.width + x << 2;
	return this1.bytes.getInt32(pos);
};
Pixels.getPixel = function(this1,x,y) {
	var pos = y * this1.width + x << 2;
	var r = this1.bytes.b[pos + this1.format.ch1] << 16;
	var g = this1.bytes.b[pos + this1.format.ch2] << 8;
	var b = this1.bytes.b[pos + this1.format.ch3];
	return r | g | b;
};
Pixels.getPixel32 = function(this1,x,y) {
	var pos = y * this1.width + x << 2;
	var a = this1.bytes.b[pos + this1.format.ch0] << 24;
	var r = this1.bytes.b[pos + this1.format.ch1] << 16;
	var g = this1.bytes.b[pos + this1.format.ch2] << 8;
	var b = this1.bytes.b[pos + this1.format.ch3];
	return a | r | g | b;
};
Pixels.setByte = function(this1,i,value) {
	this1.bytes.b[(i & -4) + this1.format.channelMap[i & 3]] = value;
};
Pixels.setRawInt32 = function(this1,i,value) {
	this1.bytes.setInt32(i << 2,value);
};
Pixels.setRawPixel32 = function(this1,x,y,value) {
	var pos = y * this1.width + x << 2;
	this1.bytes.setInt32(pos,value);
};
Pixels.setPixel = function(this1,x,y,value) {
	var pos = y * this1.width + x << 2;
	var r = value >> 16 & 255;
	var g = value >> 8 & 255;
	var b = value & 255;
	this1.bytes.b[pos + this1.format.ch1] = r;
	this1.bytes.b[pos + this1.format.ch2] = g;
	this1.bytes.b[pos + this1.format.ch3] = b;
};
Pixels.setPixel32 = function(this1,x,y,value) {
	var pos = y * this1.width + x << 2;
	var a = value >> 24 & 255;
	var r = value >> 16 & 255;
	var g = value >> 8 & 255;
	var b = value & 255;
	this1.bytes.b[pos + this1.format.ch0] = a;
	this1.bytes.b[pos + this1.format.ch1] = r;
	this1.bytes.b[pos + this1.format.ch2] = g;
	this1.bytes.b[pos + this1.format.ch3] = b;
};
Pixels.fillRect = function(this1,x,y,width,height,value) {
	var pos = y * this1.width + x << 2;
	var alloc = true;
	if(alloc == null) {
		alloc = true;
	}
	var this2 = new hxPixels__$Pixels_PixelsData(width,1,alloc);
	var stridePixels = this2;
	stridePixels.format = this1.format;
	var stride = width << 2;
	var _g = 0;
	var _g1 = width;
	while(_g < _g1) {
		var x = _g++;
		var pos1 = 0 * stridePixels.width + x << 2;
		var a = value >> 24 & 255;
		var r = value >> 16 & 255;
		var g = value >> 8 & 255;
		var b = value & 255;
		stridePixels.bytes.b[pos1 + stridePixels.format.ch0] = a;
		stridePixels.bytes.b[pos1 + stridePixels.format.ch1] = r;
		stridePixels.bytes.b[pos1 + stridePixels.format.ch2] = g;
		stridePixels.bytes.b[pos1 + stridePixels.format.ch3] = b;
	}
	var _g = 0;
	var _g1 = height;
	while(_g < _g1) {
		var y = _g++;
		this1.bytes.blit(pos,stridePixels.bytes,0,stride);
		pos += this1.width << 2;
	}
};
Pixels.clone = function(this1) {
	var alloc = true;
	if(alloc == null) {
		alloc = true;
	}
	var this2 = new hxPixels__$Pixels_PixelsData(this1.width,this1.height,alloc);
	var clone = this2;
	clone.bytes.blit(0,this1.bytes,0,this1.bytes.length);
	clone.format = this1.format;
	return clone;
};
Pixels.fromBytes = function(bytes,width,height,format) {
	var alloc = false;
	if(alloc == null) {
		alloc = true;
	}
	var this1 = new hxPixels__$Pixels_PixelsData(width,height,alloc);
	var pixels = this1;
	pixels.format = format != null ? format : hxPixels_PixelFormat.ARGB;
	pixels.bytes = bytes;
	pixels.uint8Array = haxe_io_UInt8Array.fromBytes(bytes);
	pixels.uint32Array = haxe_io_UInt32Array.fromBytes(bytes);
	return pixels;
};
Pixels.convertTo = function(this1,format) {
	return Pixels.convert(this1,format,true);
};
Pixels.convert = function(pixels,toFormat,inPlace) {
	if(inPlace == null) {
		inPlace = false;
	}
	var res = inPlace ? pixels : Pixels.clone(pixels);
	if(toFormat == pixels.format) {
		return res;
	}
	var i = 0;
	var pos = 0;
	if(pixels.format == hxPixels_PixelFormat.BGRA && toFormat == hxPixels_PixelFormat.RGBA || pixels.format == hxPixels_PixelFormat.RGBA && toFormat == hxPixels_PixelFormat.BGRA) {
		while(i < pixels.count) {
			var i1 = pos + 1;
			var r = pixels.bytes.b[(i1 & -4) + pixels.format.channelMap[i1 & 3]];
			var i2 = pos + 3;
			var b = pixels.bytes.b[(i2 & -4) + pixels.format.channelMap[i2 & 3]];
			res.bytes.b[pos + toFormat.ch1] = r;
			res.bytes.b[pos + toFormat.ch3] = b;
			++i;
			pos += 4;
		}
	} else {
		while(i < pixels.count) {
			var a = pixels.bytes.b[(pos & -4) + pixels.format.channelMap[pos & 3]];
			var i1 = pos + 1;
			var r = pixels.bytes.b[(i1 & -4) + pixels.format.channelMap[i1 & 3]];
			var i2 = pos + 2;
			var g = pixels.bytes.b[(i2 & -4) + pixels.format.channelMap[i2 & 3]];
			var i3 = pos + 3;
			var b = pixels.bytes.b[(i3 & -4) + pixels.format.channelMap[i3 & 3]];
			res.bytes.b[pos + toFormat.ch0] = a;
			res.bytes.b[pos + toFormat.ch1] = r;
			res.bytes.b[pos + toFormat.ch2] = g;
			res.bytes.b[pos + toFormat.ch3] = b;
			++i;
			pos += 4;
		}
	}
	res.format = toFormat;
	return res;
};
Pixels.fromImageData = function(image) {
	var alloc = false;
	if(alloc == null) {
		alloc = true;
	}
	var this1 = new hxPixels__$Pixels_PixelsData(image.width,image.height,alloc);
	var pixels = this1;
	pixels.format = hxPixels_PixelFormat.RGBA;
	var u8ClampedArray = image.data;
	var u8Array = u8ClampedArray;
	var bytes = haxe_io_Bytes.ofData(u8Array.buffer);
	pixels.bytes = bytes;
	pixels.uint8Array = haxe_io_UInt8Array.fromBytes(bytes);
	pixels.uint32Array = haxe_io_UInt32Array.fromBytes(bytes);
	return pixels;
};
Pixels.applyToImageData = function(this1,imageData) {
	var u8clampedArray = new Uint8ClampedArray(this1.bytes.b.bufferValue);
	imageData.data.set(u8clampedArray);
	return imageData;
};
var hxPixels__$Pixels_PixelsData = function(width,height,alloc,format) {
	if(alloc == null) {
		alloc = true;
	}
	this.uint32Array = null;
	this.uint8Array = null;
	this.count = width * height;
	if(alloc) {
		var bytes = new haxe_io_Bytes(new ArrayBuffer(this.count << 2));
		this.bytes = bytes;
		this.uint8Array = haxe_io_UInt8Array.fromBytes(bytes);
		this.uint32Array = haxe_io_UInt32Array.fromBytes(bytes);
	}
	this.width = width;
	this.height = height;
	this.format = format != null ? format : hxPixels_PixelFormat.ARGB;
};
$hxClasses["hxPixels._Pixels.PixelsData"] = hxPixels__$Pixels_PixelsData;
hxPixels__$Pixels_PixelsData.__name__ = "hxPixels._Pixels.PixelsData";
hxPixels__$Pixels_PixelsData.prototype = {
	count: null
	,bytes: null
	,set_bytes: function(bytes) {
		this.bytes = bytes;
		this.uint8Array = haxe_io_UInt8Array.fromBytes(bytes);
		this.uint32Array = haxe_io_UInt32Array.fromBytes(bytes);
		return this.bytes;
	}
	,width: null
	,height: null
	,format: null
	,uint8Array: null
	,uint32Array: null
	,__class__: hxPixels__$Pixels_PixelsData
	,__properties__: {set_bytes:"set_bytes"}
};
var hxPixels_PixelFormat = $hx_exports["hxPixels"]["PixelFormat"] = function(a,r,g,b,name) {
	if(name == null) {
		name = "PixelFormat";
	}
	this.channelMap = [a,r,g,b];
	this.ch0 = a;
	this.ch1 = r;
	this.ch2 = g;
	this.ch3 = b;
	this.name = name;
};
$hxClasses["hxPixels.PixelFormat"] = hxPixels_PixelFormat;
hxPixels_PixelFormat.__name__ = "hxPixels.PixelFormat";
hxPixels_PixelFormat.ARGB = null;
hxPixels_PixelFormat.RGBA = null;
hxPixels_PixelFormat.BGRA = null;
hxPixels_PixelFormat.convert = function(px,fromFormat,toFormat) {
	return (px >> 8 * (3 - fromFormat.ch0) & 255) << 8 * (3 - toFormat.ch0) | (px >> 8 * (3 - fromFormat.ch1) & 255) << 8 * (3 - toFormat.ch1) | (px >> 8 * (3 - fromFormat.ch2) & 255) << 8 * (3 - toFormat.ch2) | (px >> 8 * (3 - fromFormat.ch3) & 255) << 8 * (3 - toFormat.ch3);
};
hxPixels_PixelFormat.getNativeFormatFor = function(target) {
	switch(target) {
	case "flambe flash":case "flash":case "nme desktop":case "nme flash":case "openfl flash":
		return hxPixels_PixelFormat.ARGB;
	case "format":
		return hxPixels_PixelFormat.BGRA;
	case "java":
		return hxPixels_PixelFormat.RGBA;
	case "openfl desktop":
		return hxPixels_PixelFormat.BGRA;
	case "flambe web":case "js":case "luxe":case "openfl js":
		return hxPixels_PixelFormat.RGBA;
	default:
		throw haxe_Exception.thrown("Unhandled target!");
	}
};
hxPixels_PixelFormat.prototype = {
	channelMap: null
	,ch0: null
	,ch1: null
	,ch2: null
	,ch3: null
	,name: null
	,A: null
	,get_A: function() {
		return this.ch0;
	}
	,R: null
	,get_R: function() {
		return this.ch1;
	}
	,G: null
	,get_G: function() {
		return this.ch2;
	}
	,B: null
	,get_B: function() {
		return this.ch3;
	}
	,toString: function() {
		return this.name;
	}
	,__class__: hxPixels_PixelFormat
	,__properties__: {get_B:"get_B",get_G:"get_G",get_R:"get_R",get_A:"get_A"}
};
var hxPixels_Channel = {};
var Pixel = $hx_exports["Pixel"] = {};
Pixel.__properties__ = {set_fB:"set_fB",get_fB:"get_fB",set_fG:"set_fG",get_fG:"get_fG",set_fR:"set_fR",get_fR:"get_fR",set_fA:"set_fA",get_fA:"get_fA",set_B:"set_B",get_B:"get_B",set_G:"set_G",get_G:"get_G",set_R:"set_R",get_R:"get_R",set_A:"set_A",get_A:"get_A"};
Pixel.fclamp = function(value) {
	if(value <= 0.) {
		return 0.;
	} else if(value >= 1.) {
		return 1.;
	} else {
		return value;
	}
};
Pixel.iclamp = function(value) {
	if(value <= 0) {
		return 0;
	} else if(value >= 255) {
		return 255;
	} else {
		return value;
	}
};
Pixel.iround = function(value) {
	return value + .5 | 0;
};
Pixel.multiplyAlpha = function(this1) {
	var fA = (this1 >> 24 & 255) / 255.;
	var value = fA * (this1 >> 16 & 255) + .5 | 0;
	var value1 = fA * (this1 >> 8 & 255) + .5 | 0;
	var value2 = fA * (this1 & 255) + .5 | 0;
	return this1 & -16777216 | (value <= 0 ? 0 : value >= 255 ? 255 : value) << 16 | (value1 <= 0 ? 0 : value1 >= 255 ? 255 : value1) << 8 | (value2 <= 0 ? 0 : value2 >= 255 ? 255 : value2);
};
Pixel.unmultiplyAlpha = function(this1) {
	var inv_fA = 1. / ((this1 >> 24 & 255) / 255. + 0.00000001);
	var value = inv_fA * (this1 >> 16 & 255) + .5 | 0;
	var value1 = inv_fA * (this1 >> 8 & 255) + .5 | 0;
	var value2 = inv_fA * (this1 & 255) + .5 | 0;
	return this1 & -16777216 | (value <= 0 ? 0 : value >= 255 ? 255 : value) << 16 | (value1 <= 0 ? 0 : value1 >= 255 ? 255 : value1) << 8 | (value2 <= 0 ? 0 : value2 >= 255 ? 255 : value2);
};
Pixel.create = function(a,r,g,b) {
	return (a & 255) << 24 | (r & 255) << 16 | (g & 255) << 8 | b;
};
Pixel.fcreate = function(a,r,g,b) {
	return ((a * 255. | 0) & 255) << 24 | ((r * 255. | 0) & 255) << 16 | ((g * 255. | 0) & 255) << 8 | (b * 255. | 0);
};
Pixel.getChannel = function(this1,ch) {
	return this1 >> 8 * (3 - ch) & 255;
};
Pixel.setChannel = function(this1,ch,value) {
	this1 = this1 & ~hxPixels_Channel.MASK[ch] | value << 8 * (3 - ch);
	return value;
};
Pixel.get_A = function(this1) {
	return this1 >> 24 & 255;
};
Pixel.set_A = function(this1,a) {
	this1 = this1 & 16777215 | a << 24;
	return a;
};
Pixel.get_R = function(this1) {
	return this1 >> 16 & 255;
};
Pixel.set_R = function(this1,r) {
	this1 = this1 & -16711681 | r << 16;
	return r;
};
Pixel.get_G = function(this1) {
	return this1 >> 8 & 255;
};
Pixel.set_G = function(this1,g) {
	this1 = this1 & -65281 | g << 8;
	return g;
};
Pixel.get_B = function(this1) {
	return this1 & 255;
};
Pixel.set_B = function(this1,b) {
	this1 = this1 & -256 | b;
	return b;
};
Pixel.get_fA = function(this1) {
	return (this1 >> 24 & 255) / 255.;
};
Pixel.set_fA = function(this1,a) {
	this1 = this1 & 16777215 | (a * 255 | 0) << 24;
	return a;
};
Pixel.get_fR = function(this1) {
	return (this1 >> 16 & 255) / 255.;
};
Pixel.set_fR = function(this1,r) {
	this1 = this1 & -16711681 | (r * 255 | 0) << 16;
	return r;
};
Pixel.get_fG = function(this1) {
	return (this1 >> 8 & 255) / 255.;
};
Pixel.set_fG = function(this1,g) {
	this1 = this1 & -65281 | (g * 255 | 0) << 8;
	return g;
};
Pixel.get_fB = function(this1) {
	return (this1 & 255) / 255.;
};
Pixel.set_fB = function(this1,b) {
	this1 = this1 & -256 | (b * 255 | 0);
	return b;
};
var hxPixels_TargetType = {};
hxPixels_TargetType.getCurrent = function() {
	return "js";
};
var hxPixels_Endianness = {};
hxPixels_Endianness.getCurrent = function() {
	var a = haxe_io_UInt32Array.fromArray([-573785174]);
	var b = haxe_io_UInt8Array.fromBytes(haxe_io_Bytes.ofData(a.buffer));
	if(b[0] == 221) {
		return 0;
	} else {
		return 1;
	}
};
hxPixels_Endianness.getName = function(endian) {
	return hxPixels_Endianness.names[endian];
};
var js_Boot = function() { };
$hxClasses["js.Boot"] = js_Boot;
js_Boot.__name__ = "js.Boot";
js_Boot.isClass = function(o) {
	return o.__name__;
};
js_Boot.isInterface = function(o) {
	return o.__isInterface__;
};
js_Boot.isEnum = function(e) {
	return e.__ename__;
};
js_Boot.getClass = function(o) {
	if(o == null) {
		return null;
	} else if(((o) instanceof Array)) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var n = e.__constructs__[o._hx_index];
			var con = e[n];
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g = 0;
		var _g1 = intf.length;
		while(_g < _g1) {
			var i = _g++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		return ((o) instanceof Array);
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return o != null;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return ((o | 0) === o);
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(js_Boot.__downcastCheck(o,cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(((o) instanceof cl)) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ != null ? $hxEnums[o.__enum__] == cl : false;
	}
};
js_Boot.__downcastCheck = function(o,cl) {
	if(!((o) instanceof cl)) {
		if(cl.__isInterface__) {
			return js_Boot.__interfLoop(js_Boot.getClass(o),cl);
		} else {
			return false;
		}
	} else {
		return true;
	}
};
js_Boot.__implements = function(o,iface) {
	return js_Boot.__interfLoop(js_Boot.getClass(o),iface);
};
js_Boot.__cast = function(o,t) {
	if(o == null || js_Boot.__instanceof(o,t)) {
		return o;
	} else {
		throw haxe_Exception.thrown("Cannot cast " + Std.string(o) + " to " + Std.string(t));
	}
};
js_Boot.__toStr = null;
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var js_Lib = function() { };
$hxClasses["js.Lib"] = js_Lib;
js_Lib.__name__ = "js.Lib";
js_Lib.__properties__ = {get_undefined:"get_undefined"};
js_Lib.debug = function() {
	debugger;
};
js_Lib.alert = function(v) {
	alert(js_Boot.__string_rec(v,""));
};
js_Lib.eval = function(code) {
	return eval(code);
};
js_Lib.get_undefined = function() {
	return undefined;
};
js_Lib.rethrow = function() {
};
js_Lib.getOriginalException = function() {
	return null;
};
js_Lib.getNextHaxeUID = function() {
	return $global.$haxeUID++;
};
var js_lib__$ArrayBuffer_ArrayBufferCompat = function() { };
$hxClasses["js.lib._ArrayBuffer.ArrayBufferCompat"] = js_lib__$ArrayBuffer_ArrayBufferCompat;
js_lib__$ArrayBuffer_ArrayBufferCompat.__name__ = "js.lib._ArrayBuffer.ArrayBufferCompat";
js_lib__$ArrayBuffer_ArrayBufferCompat.sliceImpl = function(begin,end) {
	var u = new Uint8Array(this,begin,end == null ? null : end - begin);
	var resultArray = new Uint8Array(u.byteLength);
	resultArray.set(u);
	return resultArray.buffer;
};
var js_lib_KeyValue = {};
js_lib_KeyValue.__properties__ = {get_value:"get_value",get_key:"get_key"};
js_lib_KeyValue.get_key = function(this1) {
	return this1[0];
};
js_lib_KeyValue.get_value = function(this1) {
	return this1[1];
};
var js_lib_ObjectEntry = {};
js_lib_ObjectEntry.__properties__ = {get_value:"get_value",get_key:"get_key"};
js_lib_ObjectEntry.get_key = function(this1) {
	return this1[0];
};
js_lib_ObjectEntry.get_value = function(this1) {
	return this1[1];
};
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
$hxClasses["Math"] = Math;
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.prototype.__class__ = $hxClasses["String"] = String;
String.__name__ = "String";
$hxClasses["Array"] = Array;
Array.__name__ = "Array";
Date.prototype.__class__ = $hxClasses["Date"] = Date;
Date.__name__ = "Date";
var Int = { };
var Dynamic = { };
var Float = Number;
var Bool = Boolean;
var Class = { };
var Enum = { };
haxe_ds_ObjectMap.count = 0;
hxGeomAlgo_PolyTools.exposeEnum(hxGeomAlgo_Connectivity);
hxGeomAlgo_PoleOfInaccessibility.SQRT2 = Math.sqrt(2.0);
hxGeomAlgo_PolyTools.exposeEnum(hxGeomAlgo_WindingRule);
hxGeomAlgo_PolyTools.exposeEnum(hxGeomAlgo_ResultType);
hxGeomAlgo_PolyTools.exposeEnum(hxGeomAlgo_SimplificationMethod);
hxPixels_PixelFormat.ARGB = new hxPixels_PixelFormat(0,1,2,3,"ARGB");
hxPixels_PixelFormat.RGBA = new hxPixels_PixelFormat(3,0,1,2,"RGBA");
hxPixels_PixelFormat.BGRA = new hxPixels_PixelFormat(3,2,1,0,"BGRA");
js_Boot.__toStr = ({ }).toString;
if(ArrayBuffer.prototype.slice == null) {
	ArrayBuffer.prototype.slice = js_lib__$ArrayBuffer_ArrayBufferCompat.sliceImpl;
}
EReg.escapeRe = new RegExp("[.*+?^${}()|[\\]\\\\]","g");
haxe_SysTools.winMetaCharacters = [32,40,41,37,33,94,34,60,62,38,124,10,13,44,59];
StringTools.winMetaCharacters = haxe_SysTools.winMetaCharacters;
StringTools.MIN_SURROGATE_CODE_POINT = 65536;
haxe_Int32._mul = Math.imul != null ? Math.imul : function(a,b) {
	return a * (b & 65535) + (a * (b >>> 16) << 16 | 0) | 0;
};
haxe_io_UInt32Array.BYTES_PER_ELEMENT = 4;
haxe_io_UInt8Array.BYTES_PER_ELEMENT = 1;
hxGeomAlgo_HxPoint.EMPTY = hxGeomAlgo_HxPoint._new(NaN,NaN);
hxGeomAlgo_PolyTools.point = hxGeomAlgo_HxPoint._new();
hxGeomAlgo_PolyTools.zero = hxGeomAlgo_HxPoint._new(0,0);
hxGeomAlgo_PolyTools.EPSILON = .00000001;
hxGeomAlgo_HomogCoord.INFINITY = new hxGeomAlgo_HomogCoord();
hxGeomAlgo_DecompPoly.INFINITY = 100000;
hxGeomAlgo_DecompPoly.BAD = 999990;
hxGeomAlgo_DecompPoly.NONE = 0;
hxGeomAlgo_Version.major = 0;
hxGeomAlgo_Version.minor = 5;
hxGeomAlgo_Version.patch = 0;
hxGeomAlgo_Visibility.NOT_SAVED = -1;
hxGeomAlgo_Visibility.stack = [];
hxGeomAlgo_Visibility.vertexType = [];
hxGeomAlgo_WuYongZhang.F = new haxe_ds_IntMap();
hxGeomAlgo_WuYongZhang.G = new haxe_ds_IntMap();
hxGeomAlgo_WuYongZhang.H = new haxe_ds_IntMap();
Pixels.CHANNEL_MASK = 3;
hxPixels__$Pixels_PixelsData.BYTES_PER_PIXEL = 4;
hxPixels_Channel.MASK = [-16777216,16711680,65280,255];
hxPixels_Channel.CH_0 = 0;
hxPixels_Channel.CH_1 = 1;
hxPixels_Channel.CH_2 = 2;
hxPixels_Channel.CH_3 = 3;
hxPixels_TargetType.FLASH = "flash";
hxPixels_TargetType.FORMAT = "format";
hxPixels_TargetType.FLAMBE_FLASH = "flambe flash";
hxPixels_TargetType.FLAMBE_WEB = "flambe web";
hxPixels_TargetType.LUXE = "luxe";
hxPixels_TargetType.OPENFL_JS = "openfl js";
hxPixels_TargetType.OPENFL_DESKTOP = "openfl desktop";
hxPixels_TargetType.OPENFL_FLASH = "openfl flash";
hxPixels_TargetType.NME_DESKTOP = "nme desktop";
hxPixels_TargetType.NME_FLASH = "nme flash";
hxPixels_TargetType.JAVA = "java";
hxPixels_TargetType.JS = "js";
hxPixels_TargetType.UNKNOWN = "unknown";
hxPixels_Endianness.BIG = 0;
hxPixels_Endianness.LITTLE = 1;
hxPixels_Endianness.names = ["BIG_ENDIAN","LITTLE_ENDIAN"];
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
